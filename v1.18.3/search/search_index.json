{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"basedpyright <p>Basedpyright is a fork of pyright with various type checking improvements, improved vscode support and pylance features built into the language server.</p> <p>\ud83d\udedd Playground</p>"},{"location":"#why","title":"why?","text":"<p>there are two main reasons for this fork:</p> <ol> <li>pyright lacks many features which are made exclusive to pylance, microsoft's closed-source vscode extension</li> <li>the maintainer of pyright closes valid issues for no reason and lashes out at users</li> </ol> <p>see the Benefits over Pyright section for a comprehensive list of new features and improvements we've made to pyright.</p>"},{"location":"shoutouts/","title":"Shoutouts","text":"<p>some projects that helped make basedpyright possible</p>"},{"location":"shoutouts/#basedmypy","title":"basedmypy","text":"<p>basedmypy is a fork of mypy with a similar goal in mind: to fix some of the serious problems in mypy that do not seem to be a priority for the maintainers. it also adds many new features which may not be standardized but greatly improve the developer experience when working with python's far-from-perfect type system.</p> <p>basedmypy heavily inspired me to create basedpyright. while the two projects have similar goals, there are some differences:</p> <ul> <li>basedmypy makes breaking changes to improve the typing system and its syntax. for example, it supports intersections, <code>(int) -&gt; str</code> function type syntax and <code>foo is int</code> syntax for type guards. more info here</li> <li>basedpyright intends to be fully backwards compatible with all standard typing functionality. non-standard features will be fully optional and can be disabled, as we intend to support library developers who can't control what type checker their library is used with.</li> <li>basedpyright's two main goals are to improve the type checker's accuracy and reliability with existing syntax, and to bridge the gap between pylance and pyright</li> </ul>"},{"location":"shoutouts/#pyright-inlay-hints","title":"pyright-inlay-hints","text":"<p>one of the first pylance features we added was inlay hints and semantic highlighting. i had no clue where to begin until i found this project which had already done the bulk of the work which i was able to expand upon</p>"},{"location":"shoutouts/#docify","title":"docify","text":"<p>used for our builtin docstrings support</p>"},{"location":"shoutouts/#nodejs-wheel","title":"nodejs-wheel","text":"<p>this project made the basedpyright pypi package possible, which significantly simplified the process of installing pyright for python developers who aren't familiar with nodejs and npm. since we started using it in basedpyright, it has since been adopted by the unofficial pyright pypi package as well.</p>"},{"location":"shoutouts/#pyprojectx","title":"pyprojectx","text":"<p>this tool makes working on multiple different python projects so much less stressful. instead of installing all these project management tools like pdm, uv, etc. globally you can install and pin them inside your project without ever having to install anything first.</p>"},{"location":"benefits-over-pyright/baseline/","title":"baseline (beta)","text":"<p>have you ever wanted to adopt a new tool or enable new checks in an existing project, only to be immediately bombarded with thousands of errors you'd have to fix? baseline solves this problem by allowing you to only report errors on new or modified code. it works by generating a baseline file keeping track of the existing errors in your project so that only errors in newly written or modified code get reported.</p> <p>to enable baseline, run <code>basedpyright --writebaseline</code> in your terminal or run the \"basedpyright: Write new errors to baseline\" task in vscode. this will generate a <code>./basedpyright/baseline.json</code> for your project. you should commit this file so others working on your project can benefit from it too.</p>"},{"location":"benefits-over-pyright/baseline/#how-often-do-i-need-to-update-the-baseline-file","title":"how often do i need to update the baseline file?","text":"<p>this file gets automatically updated as errors are removed over time in both the CLI and the language server. you should only manually run the write baseline command in the following scenarios:</p> <ul> <li>a baselined error incorrectly resurfaces when updating unrelated code</li> <li>you're enabling a new diagnostic rule and want to baseline all the new errors it reported</li> </ul> <p>if you need to suppress a diagnostic for another reason, consider using a <code># pyright: ignore</code> comment instead.</p>"},{"location":"benefits-over-pyright/baseline/#how-does-it-work","title":"how does it work?","text":"<p>each baselined error is stored and matched by the following details:</p> <ul> <li>the path of the file it's in (relative to the project root)</li> <li>its diagnostic rule name (eg. <code>reportGeneralTypeIssues</code>)</li> <li>the position of the error in the file (column only, which prevents errors from resurfacing when you add or remove lines in a file)</li> </ul> <p>no baseline matching strategy is perfect, so this is subject to change. baseline is in beta so if you have any feedback please raise an issue.</p>"},{"location":"benefits-over-pyright/baseline/#how-is-this-different-to-pyright-ignore-comments","title":"how is this different to <code># pyright: ignore</code> comments?","text":"<p>ignore comments are typically used to suppress a false positive or workaround some limitation in the type checker. baselining is a way to suppress many valid instances of an error across your whole project, to avoid the burden of having to update thousands of lines of old code just to adopt stricter checks on your new code.</p>"},{"location":"benefits-over-pyright/baseline/#credit","title":"credit","text":"<p>this is heavily inspired by basedmypy.</p>"},{"location":"benefits-over-pyright/better-defaults/","title":"better defaults","text":"<p>we believe that type checkers and linters should be as strict as possible by default, making the user aware of all the available rules so they can more easily make informed decisions about which rules they don't want enabled in their project. that's why the following defaults have been changed in basedpyright</p>"},{"location":"benefits-over-pyright/better-defaults/#typecheckingmode","title":"<code>typeCheckingMode</code>","text":"<p>used to be <code>basic</code>, but now defaults to <code>all</code>. while this may seem daunting at first, we support baselining to allow for easy adoption of more strict rules in existing codebases.</p>"},{"location":"benefits-over-pyright/better-defaults/#pythonplatform","title":"<code>pythonPlatform</code>","text":"<p>used to assume that the operating system pyright is being run on is the only operating system your code will run on, which is rarely the case. in basedpyright, <code>pythonPlatform</code> defaults to <code>All</code>, which assumes your code can run on any operating system.</p>"},{"location":"benefits-over-pyright/errors-on-invalid-configuration/","title":"errors on invalid configuration","text":"<p>in pyright, if you have any invalid configuration, it may or may not print a warning to the console, then it will continue type-checking and the exit code will be 0 as long as there were no type errors:</p> pyproject.toml<pre><code>[tool.pyright]\nmode = \"strict\"  # wrong! the setting you're looking for is called `typeCheckingMode`\n</code></pre> <p>in this example, it's very easy for errors to go undetected because you thought you were on strict mode, but in reality pyright just ignored the setting and silently continued type-checking on \"basic\" mode.</p> <p>to solve this problem, basedpyright will exit with code 3 on any invalid config when using the CLI, and show an error notification when using the language server.</p>"},{"location":"benefits-over-pyright/fixes-for-rules/","title":"fixes for the <code>reportRedeclaration</code> and <code>reportDuplicateImport</code> rules","text":"<p>pyright does not report redeclarations if the redeclaration has the same type:</p> <pre><code>foo: int = 1\nfoo: int = 2  # no error\n</code></pre> <p>nor does it care if you have a duplicated import in multiple different <code>import</code> statements, or in aliases:</p> <pre><code>from foo import bar\nfrom bar import bar  # no error\nfrom baz import foo as baz, bar as baz  # no error\n</code></pre> <p>basedpyright solves both of these problems by always reporting an error on a redeclaration or an import with the same name as an existing import.</p>"},{"location":"benefits-over-pyright/improved-ci-integration/","title":"improved integration with CI platforms","text":"<p>regular pyright has third party integrations for github actions and gitlab, but they are difficult to install/set up. these integrations are built into basedpyright, which makes them much easier to use.</p>"},{"location":"benefits-over-pyright/improved-ci-integration/#github-actions","title":"github actions","text":"<p>basedpyright automatically detects when it's running in a github action, and modifies its output to use github workflow commands. this means errors will be displayed on the affected lines of code in your pull requests automatically:</p> <p></p> <p>this is an improvement to regular pyright, which requires you to use a third party action that requires boilerplate to get working. basedpyright just does it automatically without you having to do anything special:</p> .github/workflows/your_workflow.yaml<pre><code>jobs:\n    check:\n        steps:\n            - run: ... # checkout repo, install dependencies, etc\n            - run: basedpyright # no additional arguments required. it automatically detects if it's running in a github action\n</code></pre>"},{"location":"benefits-over-pyright/improved-ci-integration/#gitlab-code-quality-reports","title":"gitlab code quality reports","text":"<p>the <code>--gitlabcodequality</code> argument will output a gitlab code quality report which shows up on merge requests:</p> <p></p> <p>to enable this in your gitlab CI, just specify a file path to output the report to, and in the <code>artifacts.reports.codequality</code> section of your <code>.gitlab-ci.yml</code> file:</p> .gitlab-ci.yml<pre><code>basedpyright:\n    script: basedpyright --gitlabcodequality report.json\n    artifacts:\n        reports:\n            codequality: report.json\n</code></pre>"},{"location":"benefits-over-pyright/improved-translations/","title":"improved translations","text":"<p>the translations in pyright come from microsoft's localization team, who are not programmers. not only does this result in poor quality translations, but microsoft also doesn't accept contributions to fix them (more info here).</p> <p>we accept translation fixes in basedpyright. see the localization guidelines for information on how to contribute.</p>"},{"location":"benefits-over-pyright/inline-typed-dict/","title":"inline <code>TypedDict</code> support","text":"<p>pyright used to support defining <code>TypedDict</code>s inline, like so:</p> <pre><code>foo: dict[{\"foo\": int, \"bar\": str}] = {\"foo\": \"a\", \"bar\": 1}\n</code></pre> <p>this was an experimental feature and was removed because it never made it into a PEP. but this functionality is very convenient and we see no reason not to continue supporting it, so we added it back in basedpyright.</p> <p>this can be disabled by setting <code>enableExperimentalFeatures</code> to <code>false</code>.</p>"},{"location":"benefits-over-pyright/new-diagnostic-rules/","title":"new diagnostic rules","text":"<p>this section lists all of the new diagnostic rules that are exclusive to basedpyright and the motivationbehind them. for a complete list of all diagnostic rules, see here.</p>"},{"location":"benefits-over-pyright/new-diagnostic-rules/#reportunreachable","title":"<code>reportUnreachable</code>","text":"<p>pyright often incorrectly marks code as unreachable. in most cases, unreachable code is a mistake and therefore should be an error, but pyright does not have an option to report unreachable code as an error, only as agreyed-out hint in your IDE:</p> <pre><code>if sys.platform == \"win32\":\n  do_thing() # no error\n</code></pre> <p></p> <p>this is very easy to miss, especially since it doesn't cause the CLI to fail so such a mistake could easily pass your CI.</p> <p>by default, pyright will treat the body in the code above as unreachable if pyright itself was run on an operating system other than windows. this is bad of course, because chances are if you write such a check, you intend for your code to be executed on multiple platforms.</p> <p>to make things worse, unreachable code is not even type-checked at all! so if the code is reached, and the <code>do_thing</code> function isn't being called with the correct arguments, pyright will not complain!</p> <p><code>reportUnreachable</code> solves this problem by reporting unreachable code as an error by default.</p> <p>Note</p> <p>the above example with <code>sys.platform</code> won't happen by default in basedpyright anyway, because we've changed the default <code>pythonPlatform</code> to <code>\"All\"</code>. but other cases such as python version checks will still benefit from this rule.</p>"},{"location":"benefits-over-pyright/new-diagnostic-rules/#reportany","title":"<code>reportAny</code>","text":"<p>pyright has a few options to ban \"Unknown\" types such as <code>reportUnknownVariableType</code>, <code>reportUnknownParameterType</code>, etc. but \"Unknown\" is not a real type, rather a distinction pyright uses used to represent <code>Any</code>s that come from untyped code or unfollowed imports. if you want to ban all kinds of <code>Any</code>, pyright has no way to do that:</p> <pre><code>def foo(bar, baz: Any) -&gt; Any:\n    print(bar) # error: unknown type\n    print(baz) # no error\n</code></pre> <p>basedpyright introduces the <code>reportAny</code> option, which will report an error on usages of anything typed as <code>Any</code>.</p>"},{"location":"benefits-over-pyright/new-diagnostic-rules/#reportignorecommentwithoutrule","title":"<code>reportIgnoreCommentWithoutRule</code>","text":"<p>it's good practice to specify an error code in your <code>pyright: ignore</code> comments:</p> <pre><code># pyright: ignore[reportUnreachable]\n</code></pre> <p>this way, if the error changes or a new error appears on the same line in the future, you'll get a new error because the comment doesn't account for the other error.</p> <p>Note</p> <p><code>type: ignore</code> comments (<code>enableTypeIgnoreComments</code>) are unsafe and are disabled by default (see #330 and #55). we recommend using <code>pyright: ignore</code> comments instead.</p>"},{"location":"benefits-over-pyright/new-diagnostic-rules/#reportprivatelocalimportusage","title":"<code>reportPrivateLocalImportUsage</code>","text":"<p>pyright's <code>reportPrivateImportUsage</code> rule only checks for private imports of third party modules inside <code>py.typed</code> packages. but there's no reason your own code shouldn't be subject to the same restrictions. to explicitly re-export something, give it a redundant alias as described in the \"Stub Files\" section of PEP484 (although it only mentions stub files, other type checkers like mypy have also extended this behavior to source files as well):</p> <pre><code># foo.py\n\nfrom .some_module import a  # private import\nfrom .some_module import b as b  # explicit re-export\n</code></pre> <pre><code># bar.py\n\n# reportPrivateLocalImportUsage error, because `a` is not explicitly re-exported by the `foo` module:\nfrom foo import a\n\n# no error, because `b` is explicitly re-exported:\nfrom foo import b\n</code></pre>"},{"location":"benefits-over-pyright/new-diagnostic-rules/#reportimplicitrelativeimport","title":"<code>reportImplicitRelativeImport</code>","text":"<p>pyright allows invalid imports such as this:</p> <pre><code># ./module_name/foo.py:\n</code></pre> <pre><code># ./module_name/bar.py:\nimport foo # wrong! should be `import module_name.foo` or `from module_name import foo`\n</code></pre> <p>this may look correct at first glance, and will work when running <code>bar.py</code> directly as a script, but when it's imported as a module, it will crash:</p> <pre><code># ./main.py:\nimport module_name.bar  # ModuleNotFoundError: No module named 'foo'\n</code></pre> <p>the new <code>reportImplicitRelativeImport</code> rule bans imports like this. if you want to do a relative import, the correct way to do it is by importing it from <code>.</code> (the current package):</p> <pre><code># ./module_name/bar.py:\nfrom . import foo\n</code></pre>"},{"location":"benefits-over-pyright/new-diagnostic-rules/#reportinvalidcast","title":"<code>reportInvalidCast</code>","text":"<p>most of the time when casting, you want to either cast to a narrower or wider type:</p> <pre><code>foo: int | None\ncast(int, foo) #  narrower type\ncast(object, foo) #  wider type\n</code></pre> <p>but pyright doesn't prevent casts to a type that doesn't overlap with the original:</p> <pre><code>foo: int\ncast(str, foo)\n</code></pre> <p>in this example, it's impossible to be <code>foo</code> to be a <code>str</code> if it's also an <code>int</code>, because the <code>int</code> and <code>str</code> types do not overlap. the <code>reportInvalidCast</code> rule will report invalid casts like these.</p> <p>note about casting with <code>TypedDict</code>s</p> <p>a common use case of <code>cast</code> is to convert a regular <code>dict</code> into a <code>TypedDict</code>:</p> <pre><code>foo: dict[str, int | str]\nbar = cast(dict[{\"foo\": int, \"bar\": str}], foo)\n</code></pre> <p>unfortunately, this will cause a <code>reportInvalidCast</code> error when this rule is enabled, because although at runtime <code>TypedDict</code> is a <code>dict</code>, type checkers treat it as an unrelated subtype of <code>Mapping</code> that doesn't have a <code>clear</code> method, which would break its type-safety if it were to be called on a <code>TypedDict</code>.</p> <p>this means that although casting between them is a common use case, <code>TypedDict</code>s and <code>dict</code>s technically do not overlap.</p>"},{"location":"benefits-over-pyright/new-diagnostic-rules/#reportunsafemultipleinheritance","title":"<code>reportUnsafeMultipleInheritance</code>","text":"<p>multiple inheritance in python is awful:</p> <pre><code>class Foo:\n    def __init__(self):\n        super().__init__()\nclass Bar:\n    def __init__(self):\n        ...\n\nclass Baz(Foo, Bar):\n    ...\n\nBaz()\n</code></pre> <p>in this example, <code>Baz()</code> calls <code>Foo.__init__</code>, and the <code>super().__init__()</code> in <code>Foo</code> now calls to <code>Bar.__init__</code> even though <code>Foo</code> does not extend <code>Bar</code>.</p> <p>this is complete nonsense and very unsafe, because there's no way to statically know what the super class will be.</p> <p>pyright has the <code>reportMissingSuperCall</code> rule which, for this reason, complains even when your class doesn't have a base class. but that sucks because there's no way to know what arguments the unknown <code>__init__</code> takes, which means even if you do add a call to <code>super().__init__()</code> you have no clue what arguments it may take. so this rule is super annoying when it's enabled, and has very little benefit because it barely makes a difference in terms of safety.</p> <p><code>reportUnsafeMultipleInheritance</code> bans multiple inheritance when there are multiple base classes with an <code>__init__</code> or <code>__new__</code> method, as there's no way to guarantee that all of them will get called with the correct arguments (or at all). this allows <code>reportMissingSuperCall</code> to be more lenient. ie. when <code>reportUnsafeMultipleInheritance</code> is enabled, missing <code>super()</code> calls will only be reported on classes that actually have a base class.</p>"},{"location":"benefits-over-pyright/new-diagnostic-rules/#reportunusedparameter","title":"<code>reportUnusedParameter</code>","text":"<p>pyright will report an unused diagnostic on unused function parameters:</p> <pre><code>def print_value(value: str): # \"value\" is not accessed\n  print(\"something else\")\n</code></pre> <p>but like with unreachable code, this just greys out code instead of actually reporting it as an error. basedpyright introduces a new <code>reportUnusedParameter</code> diagnostic rule which supports all the severity options (<code>\"error\"</code>, <code>\"warning\"</code> and <code>\"none\"</code>) as well as <code>\"unused\"</code>, which is the default behavior in pyright.</p>"},{"location":"benefits-over-pyright/pylance-features/","title":"pylance features","text":"<p>basedpyright re-implements some of the features that microsoft made exclusive to pylance, which is microsoft's closed-source vscode extension built on top of the pyright language server with some additional exclusive functionality (see the pylance FAQ for more information).</p> <p>the following features have been re-implemented in basedpyright's language server, meaning they are no longer exclusive to vscode. you can use any editor that supports the language server protocol. for more information on installing pyright in your editor of choice, see the installation instructions.</p>"},{"location":"benefits-over-pyright/pylance-features/#import-suggestion-code-actions","title":"import suggestion code actions","text":"<p>pyright only supports import suggestions as autocomplete suggestions, but not as quick fixes (see this issue).</p> <p>basedpyright re-implements pylance's import suggestion code actions:</p> <p></p>"},{"location":"benefits-over-pyright/pylance-features/#semantic-highlighting","title":"semantic highlighting","text":"before after <p>basedpyright re-implements pylance's semantic highlighting along with some additional improvements:</p> <ul> <li>variables marked as <code>Final</code> have the correct \"read-only\" colour</li> <li>supports the new <code>type</code> keyword in python 3.12</li> <li><code>Final</code> variables are coloured as read-only</li> </ul> <p>initial implementation of the semantic highlighting provider was adapted from the pyright-inlay-hints project.</p>"},{"location":"benefits-over-pyright/pylance-features/#inlay-hints","title":"inlay hints","text":"<p>basedpyright contains several improvements and bug fixes to the original implementation adapted from pyright-inlay-hints.</p>"},{"location":"benefits-over-pyright/pylance-features/#docstrings-for-compiled-builtin-modules","title":"docstrings for compiled builtin modules","text":"<p>many of the builtin modules are written in c, meaning the pyright language server cannot statically inspect and display their docstrings to the user. unfortunately they are also not available in the <code>.pyi</code> stubs for these modules, as the typeshed maintainers consider it to be too much of a maintanance nightmare.</p> <p>pylance works around this problem by running a \"docstring scraper\" script on the user's machine, which imports compiled builtin modules, scrapes all the docstrings from them at runtime, then saves them so that the language server can read them. however this isn't ideal for a few reasons:</p> <ul> <li>only docstrings for modules and functions available on the user's current OS and python version will be generated. so if you're working on a cross-platform project, or code that's intended to be run on multiple versions of python, you won't be able to see docstrings for compiled builtin modules that are not available in your current python installation.</li> <li>the check to determine whether a builtin object is compiled is done at the module level, meaning modules like <code>re</code> and <code>os</code> which have python source files but contain re-exports of compiled functions, are treated as if they are entirely written in python. this means many of their docstrings are still missing in pylance.</li> <li>it's (probably) slower because these docstrings need to be scraped either when the user launches vscode, or when the user hovers over a builtin class/function (disclaimer: i don't actually know when it runs, because pylance is closed source)</li> </ul> <p>basedpyright solves all of these problems by using docify to scrape the docstrings from all compiled builtin functions/classes for all currently supported python versions and all platforms (macos, windows and linux), and including them in the default typeshed stubs that come with the basedpyright package.</p>"},{"location":"benefits-over-pyright/pylance-features/#examples","title":"examples","text":"<p>here's a demo of basedpyright's builtin docstrings when running on windows, compared to pylance:</p>"},{"location":"benefits-over-pyright/pylance-features/#basedpyright","title":"basedpyright","text":""},{"location":"benefits-over-pyright/pylance-features/#pylance","title":"pylance","text":""},{"location":"benefits-over-pyright/pylance-features/#generating-your-own-stubs-with-docstrings","title":"generating your own stubs with docstrings","text":"<p>basedpyright uses docify to add docstrings to its stubs. if you have third party compiled modules and you want basedpyright to see its docstrings, you can do the same:</p> <pre><code>python -m docify path/to/stubs/for/package --in-place\n</code></pre> <p>or if you're using a different version of typeshed, you can use the <code>--if-needed</code> argument to replicate how basedpyright's version of typeshed is generated for your current platform and python version:</p> <pre><code>python -m docify path/to/typeshed/stdlib --if-needed --in-place\n</code></pre>"},{"location":"benefits-over-pyright/pylance-features/#renaming-packages-and-modules","title":"renaming packages and modules","text":"<p>when renaming a package or module, basedpyright will update all usages to the new name, just like pylance does:</p> <p></p>"},{"location":"benefits-over-pyright/pypi-package-vscode-pinning/","title":"pypi package and version pinning","text":""},{"location":"benefits-over-pyright/pypi-package-vscode-pinning/#pypi-package-no-nodejs-required","title":"pypi package - no nodejs required","text":"<p>pyright is only published as an npm package, which requires you to install nodejs. the version on pypi is just an unofficial wrapper that installs node and the npm package the first time you invoke the cli, which is quite flaky.</p> <p>python developers should not be expected to have to install nodejs in order to typecheck their python code. it should just be a regular pypi package like mypy, ruff, and pretty much all other python tooling. this is why basedpyright is officially published on pypi, which comes bundled with the npm package.</p>"},{"location":"benefits-over-pyright/pypi-package-vscode-pinning/#ability-to-pin-the-version-used-by-vscode","title":"ability to pin the version used by vscode","text":"<p>in pyright, if the vscode extension gets updated, you may see errors in your project that don't appear in the CI, or vice-versa. see this issue.</p> <p>basedpyright fixes this problem by adding an <code>importStrategy</code> option to the extension, which defaults to looking in your project for the basedpyright pypi package.</p>"},{"location":"configuration/command-line/","title":"Command line","text":""},{"location":"configuration/command-line/#command-line","title":"Command-Line","text":"<p>Usage: basedpyright [options] [files...] (1)</p> <p>basedpyright can be run as either a VS Code extension or as a command-line tool. The command-line version allows for the following options:</p> Flag Description --createstub <code>&lt;IMPORT&gt;</code> Create type stub file(s) for import --dependencies Emit import dependency information -h, --help Show help message --ignoreexternal Ignore external imports for --verifytypes --level  Minimum diagnostic level (error or warning) --outputjson Output results in JSON format --gitlabcodequality Output results to a gitlab code quality report --writebaseline Write new errors to the baseline file -p, --project <code>&lt;FILE OR DIRECTORY&gt;</code> Use the configuration file at this location --pythonpath <code>&lt;FILE&gt;</code> Path to the Python interpreter (2) --pythonplatform <code>&lt;PLATFORM&gt;</code> Analyze for platform (Darwin, Linux, Windows) --pythonversion <code>&lt;VERSION&gt;</code> Analyze for version (3.3, 3.4, etc.) --skipunannotated Skip type analysis of unannotated functions --stats Print detailed performance stats -t, --typeshedpath <code>&lt;DIRECTORY&gt;</code> Use typeshed type stubs at this location (3) --threads  Use up to N threads to parallelize type checking (4) -v, --venvpath <code>&lt;DIRECTORY&gt;</code> Directory that contains virtual environments (5) --verbose Emit verbose diagnostics --verifytypes <code>&lt;IMPORT&gt;</code> Verify completeness of types in py.typed package --version Print pyright version and exit --warnings Use exit code of 1 if warnings are reported -w, --watch Continue to run and watch for changes (6) - Read file or directory list from stdin <p>(1) If specific files are specified on the command line, it overrides the files or directories specified in the pyrightconfig.json or pyproject.toml file.</p> <p>(2) This option is the same as the language server setting <code>python.pythonPath</code>. It cannot be used with --venvpath. The --pythonpath options is recommended over --venvpath in most cases. For more details, refer to the import resolution documentation.</p> <p>(3) Pyright has built-in typeshed type stubs for Python stdlib functionality. To use a different version of typeshed type stubs, specify the directory with this option.</p> <p>(4) This feature is experimental. If thread count is &gt; 1, multiple copies of pyright are executed in parallel to type check files in a project. If no thread count is specified, the thread count is based on the number of available logical processors (if at least 4) or 1 (if less than 4).</p> <p>(5) This option is the same as the language server setting <code>python.venvPath</code>. It used in conjunction with configuration file, which can refer to different virtual environments by name. For more details, refer to the configuration and import resolution documentation. This allows a common config file to be checked in to the project and shared by everyone on the development team without making assumptions about the local paths to the venv directory on each developer\u2019s computer.</p> <p>(6) When running in watch mode, pyright will reanalyze only those files that have been modified. These \u201cdeltas\u201d are typically much faster than the initial analysis, which needs to analyze all files in the source tree.</p>"},{"location":"configuration/command-line/#pyright-exit-codes","title":"Pyright Exit Codes","text":"Exit Code Meaning 0 No errors reported 1 One or more errors reported 2 Fatal error occurred with no errors or warnings reported 3 Config file could not be read or parsed 4 Illegal command-line parameters specified"},{"location":"configuration/command-line/#json-output","title":"JSON Output","text":"<p>If the \u201c--outputjson\u201d option is specified on the command line, diagnostics are output in JSON format. The JSON structure is as follows: <pre><code>{\n    version: string,\n    time: string,\n    generalDiagnostics: Diagnostic[],\n    summary: {\n        filesAnalyzed: number,\n        errorCount: number,\n        warningCount: number,\n        informationCount: number,\n        timeInSec: number\n    }\n}\n</code></pre></p> <p>Each Diagnostic is output in the following format:</p> <pre><code>{\n    file: string,\n    severity: 'error' | 'warning' | 'information',\n    message: string,\n    rule?: string,\n    range: {\n        start: {\n            line: number,\n            character: number\n        },\n        end: {\n            line: number,\n            character: number\n        }\n    }\n}\n</code></pre> <p>Diagnostic line and character numbers are zero-based.</p> <p>Not all diagnostics have an associated diagnostic rule. Diagnostic rules are used only for diagnostics that can be disabled or enabled. If a rule is associated with the diagnostic, it is included in the output. If it\u2019s not, the rule field is omitted from the JSON output.</p>"},{"location":"configuration/command-line/#gitlab-code-quality-report","title":"Gitlab code quality report","text":"<p>the <code>--gitlabcodequality</code> argument will output a gitlab code quality report.</p> <p>to enable this in your gitlab CI, you need to specify a path to the code quality report file to this argument, and in the <code>artifacts</code> section in your gitlab CI file:</p> <pre><code>basedpyright:\n  script: basedpyright --gitlabcodequality report.json\n  artifacts:\n    reports:\n      codequality: report.json\n</code></pre>"},{"location":"configuration/command-line/#regenerating-the-baseline-file","title":"Regenerating the baseline file","text":"<p>if you're using baseline, as baselined errors are removed from your code, the CLI will automatically update the <code>./.basedpyright/baseline.json</code> file to remove them:</p> <pre><code>&gt;basedpyright\nupdated ./.basedpyright/baseline.json with 200 errors (went down by 5)\n0 errors, 0 warnings, 0 notes\n</code></pre> <p>the <code>--writebaseline</code> argument is only required if you are intentionally writing new errors to the baseline file. for more information about when to use this argument, see here.</p>"},{"location":"configuration/comments/","title":"Comments","text":"<p>Some behaviors of pyright can be controlled through the use of comments within the source file.</p>"},{"location":"configuration/comments/#file-level-type-controls","title":"File-level Type Controls","text":"<p>Strict type checking, where most supported type-checking switches generate errors, can be enabled for a file through the use of a special comment. Typically this comment is placed at or near the top of a code file on its own line.</p> <pre><code># pyright: strict\n</code></pre> <p>Likewise, basic type checking can be enabled for a file. If you use <code># pyright: basic</code>, the settings for the file use the default \u201cbasic\u201d settings, not any override settings specified in the configuration file or language server settings. You can override the basic default settings within the file by specifying them individually (see below).</p> <pre><code># pyright: basic\n</code></pre> <p>Individual configuration settings can also be overridden on a per-file basis and optionally combined with \u201cstrict\u201d or \u201cbasic\u201d type checking. For example, if you want to enable all type checks except for \u201creportPrivateUsage\u201d, you could add the following comment:</p> <pre><code># pyright: strict, reportPrivateUsage=false\n</code></pre> <p>Diagnostic levels are also supported.</p> <pre><code># pyright: reportPrivateUsage=warning, reportOptionalCall=error\n</code></pre>"},{"location":"configuration/comments/#line-level-diagnostic-suppression","title":"Line-level Diagnostic Suppression","text":"<p>PEP 484 defines a special comment <code># type: ignore</code> that can be used at the end of a line to suppress all diagnostics emitted by a type checker on that line. Pyright supports this mechanism. this is disabled by default in basedpyright. see below for more information.</p> <p>Pyright also supports a <code># pyright: ignore</code> comment at the end of a line to suppress all Pyright diagnostics on that line. This can be useful if you use multiple type checkers on your source base and want to limit suppression of diagnostics to Pyright only.</p> <p>The <code># pyright: ignore</code> comment accepts an optional list of comma-delimited diagnostic rule names surrounded by square brackets. If such a list is present, only diagnostics within those diagnostic rule categories are suppressed on that line. For example, <code># pyright: ignore [reportPrivateUsage, reportGeneralTypeIssues]</code> would suppress diagnostics related to those two categories but no others.</p> <p>If the <code>reportUnnecessaryTypeIgnoreComment</code> configuration option is enabled, any unnecessary <code># type: ignore</code> and <code># pyright: ignore</code> comments will be reported so they can be removed.</p>"},{"location":"configuration/comments/#prefer-pyrightignore-comments","title":"prefer <code># pyright:ignore</code> comments","text":"<p><code># pyright:ignore</code> comments are preferred over <code># type:ignore</code> comments because they are more strict than <code>#type:ignore</code> comments:</p> <ul> <li><code># type:ignore</code> comments will always suppress all errors on the line, regardless of what diagnostic rules are specified in brackets</li> <li><code># type:ignore</code> comments are not checked to ensure that the specified rule is valud:   <pre><code># no error here, even though you are suppressing an invalid diagnostic code.\n1 + \"\" # type:ignore[asdf]\n</code></pre>   this decision was probably made to support other type checkers like mypy which use different codes to pyright, but in that case you should just disable <code>enableTypeIgnoreComments</code> to prevent pyright from looking at them.</li> </ul> <p>in basedpyright, <code>enableTypeIgnoreComments</code> is disabled by default to avoid these issues.</p>"},{"location":"configuration/config-files/","title":"Config files","text":""},{"location":"configuration/config-files/#pyright-configuration","title":"Pyright Configuration","text":"<p>basedpyright offers flexible configuration options specified in a JSON-formatted text configuration. By default, the file is called \u201cpyrightconfig.json\u201d and is located within the root directory of your project. Multi-root workspaces (\u201cAdd Folder to Workspace\u2026\u201d) are supported, and each workspace root can have its own \u201cpyrightconfig.json\u201d file. For a sample pyrightconfig.json file, see below.</p> <p>basedpyright settings can also be specified in a <code>[tool.basedpyright]</code> section of a \u201cpyproject.toml\u201d file. A \u201cpyrightconfig.json\u201d file always takes precedent over \u201cpyproject.toml\u201d if both are present. For a sample pyproject.toml file, see below.</p> <p>Info</p> <p>the <code>[tool.pyright]</code> section in <code>pyproject.toml</code> is also supported for backwards compatibility with existing pyright configs.</p> <p>Relative paths specified within the config file are relative to the config file\u2019s location. Paths with shell variables (including <code>~</code>) are not supported. Paths within a config file should generally be relative paths so the config file can be shared by other developers who contribute to the project.</p>"},{"location":"configuration/config-files/#environment-options","title":"Environment Options","text":"<p>The following settings control the environment in which basedpyright will check for diagnostics. These settings determine how Pyright finds source files, imports, and what Python version specific rules are applied.</p> <ul> <li> <p>include [array of paths, optional]: Paths of directories or files that should be considered part of the project. If no paths are specified, pyright defaults to the directory that contains the config file. Paths may contain wildcard characters ** (a directory or multiple levels of directories), * (a sequence of zero or more characters), or ? (a single character). If no include paths are specified, the root path for the workspace is assumed.</p> </li> <li> <p>exclude [array of paths, optional]: Paths of directories or files that should not be considered part of the project. These override the directories and files that <code>include</code> matched, allowing specific subdirectories to be excluded. Note that files in the exclude paths may still be included in the analysis if they are referenced (imported) by source files that are not excluded. Paths may contain wildcard characters ** (a directory or multiple levels of directories), * (a sequence of zero or more characters), or ? (a single character). If no exclude paths are specified, Pyright automatically excludes the following: <code>**/node_modules</code>, <code>**/__pycache__</code>, <code>**/.*</code>. Pylance also excludes any virtual environment directories regardless of the exclude paths specified. For more detail on Python environment specification and discovery, refer to the import resolution documentation.</p> </li> <li> <p>strict [array of paths, optional]: Paths of directories or files that should use \u201cstrict\u201d analysis if they are included. This is the same as manually adding a \u201c# pyright: strict\u201d comment. In strict mode, most type-checking rules are enabled. Refer to this table for details about which rules are enabled in strict mode. Paths may contain wildcard characters ** (a directory or multiple levels of directories), * (a sequence of zero or more characters), or ? (a single character).</p> </li> <li> <p>extends [path, optional]: Path to another <code>.json</code> or <code>.toml</code> file that is used as a \u201cbase configuration\u201d, allowing this configuration to inherit configuration settings. Top-level keys within this configuration overwrite top-level keys in the base configuration. Multiple levels of inheritance are supported. Relative paths specified in a configuration file are resolved relative to the location of that configuration file.</p> </li> <li> <p>defineConstant [map of constants to values (boolean or string), optional]: Set of identifiers that should be assumed to contain a constant value wherever used within this program. For example, <code>{ \"DEBUG\": true }</code> indicates that pyright should assume that the identifier <code>DEBUG</code> will always be equal to <code>True</code>. If this identifier is used within a conditional expression (such as <code>if not DEBUG:</code>) pyright will use the indicated value to determine whether the guarded block is reachable or not. Member expressions that reference one of these constants (e.g. <code>my_module.DEBUG</code>) are also supported.</p> </li> <li> <p>typeshedPath [path, optional]: Path to a directory that contains typeshed type stub files. Pyright ships with a bundled copy of typeshed type stubs. If you want to use a different version of typeshed stubs, you can clone the typeshed github repo to a local directory and reference the location with this path. This option is useful if you\u2019re actively contributing updates to typeshed.</p> </li> <li> <p>stubPath [path, optional]: Path to a directory that contains custom type stubs. Each package's type stub file(s) are expected to be in its own subdirectory. The default value of this setting is \"./typings\". (typingsPath is now deprecated)</p> </li> <li> <p>venvPath [path, optional]: Path to a directory containing one or more subdirectories, each of which contains a virtual environment. When used in conjunction with a venv setting (see below), pyright will search for imports in the virtual environment\u2019s site-packages directory rather than the paths specified by the default Python interpreter. If you are working on a project with other developers, it is best not to specify this setting in the config file, since this path will typically differ for each developer. Instead, it can be specified on the command line or in a per-user setting. For more details, refer to the import resolution documentation. This setting is ignored when using Pylance. VS Code's python interpreter path is used instead.</p> </li> <li> <p>venv [string, optional]: Used in conjunction with the venvPath, specifies the virtual environment to use. For more details, refer to the import resolution documentation. This setting is ignored when using Pylance.</p> </li> <li> <p>verboseOutput [boolean]: Specifies whether output logs should be verbose. This is useful when diagnosing certain problems like import resolution issues.</p> </li> <li> <p>extraPaths [array of strings, optional]: Additional search paths that will be used when searching for modules imported by files.</p> </li> <li> <p>pythonVersion [string, optional]: Specifies the version of Python that will be used to execute the source code. The version should be specified as a string in the format \"M.m\" where M is the major version and m is the minor (e.g. <code>\"3.0\"</code> or <code>\"3.6\"</code>). If a version is provided, pyright will generate errors if the source code makes use of language features that are not supported in that version. It will also tailor its use of type stub files, which conditionalizes type definitions based on the version. If no version is specified, pyright will use the version of the current python interpreter, if one is present.</p> </li> <li> <p>pythonPlatform [string, optional]: Specifies the target platform that will be used to execute the source code. Should be one of <code>\"Windows\"</code>, <code>\"Darwin\"</code>, <code>\"Linux\"</code>, or <code>\"All\"</code>. If specified, pyright will tailor its use of type stub files, which conditionalize type definitions based on the platform. If no platform is specified, pyright will use the current platform.</p> </li> <li> <p>executionEnvironments [array of objects, optional]: Specifies a list of execution environments (see below). Execution environments are searched from start to finish by comparing the path of a source file with the root path specified in the execution environment.</p> </li> <li> <p>useLibraryCodeForTypes [boolean]: Determines whether pyright reads, parses and analyzes library code to extract type information in the absence of type stub files. Type information will typically be incomplete. We recommend using type stubs where possible. The default value for this option is true.</p> </li> </ul>"},{"location":"configuration/config-files/#type-evaluation-settings","title":"Type Evaluation Settings","text":"<p>The following settings determine how different types should be evaluated.</p> <ul> <li> <p> strictListInference [boolean]: When inferring the type of a list, use strict type assumptions. For example, the expression <code>[1, 'a', 3.4]</code> could be inferred to be of type <code>list[Any]</code> or <code>list[int | str | float]</code>. If this setting is true, it will use the latter (stricter) type. The default value for this setting is <code>false</code>.</p> </li> <li> <p> strictListInference [boolean]: When inferring the type of a list, use strict type assumptions. For example, the expression <code>[1, 'a', 3.4]</code> could be inferred to be of type <code>list[Any]</code> or <code>list[int | str | float]</code>. If this setting is true, it will use the latter (stricter) type.</p> </li> <li> <p> strictDictionaryInference [boolean]: When inferring the type of a dictionary\u2019s keys and values, use strict type assumptions. For example, the expression <code>{'a': 1, 'b': 'a'}</code> could be inferred to be of type <code>dict[str, Any]</code> or <code>dict[str, int | str]</code>. If this setting is true, it will use the latter (stricter) type.</p> </li> <li> <p> strictSetInference [boolean]: When inferring the type of a set, use strict type assumptions. For example, the expression <code>{1, 'a', 3.4}</code> could be inferred to be of type <code>set[Any]</code> or <code>set[int | str | float]</code>. If this setting is true, it will use the latter (stricter) type.</p> </li> <li> <p> analyzeUnannotatedFunctions [boolean]: Analyze and report errors for functions and methods that have no type annotations for input parameters or return types.</p> </li> <li> <p> strictParameterNoneValue [boolean]: PEP 484 indicates that when a function parameter is assigned a default value of None, its type should implicitly be Optional even if the explicit type is not. When enabled, this rule requires that parameter type annotations use Optional explicitly in this case.</p> </li> <li> <p> deprecateTypingAliases [boolean]: PEP 585 indicates that aliases to types in standard collections that were introduced solely to support generics are deprecated as of Python 3.9. This switch controls whether these are treated as deprecated. This applies only when pythonVersion is 3.9 or newer.</p> </li> <li> <p> enableExperimentalFeatures [boolean]: Enables a set of experimental (mostly undocumented) features that correspond to proposed or exploratory changes to the Python typing standard. These features will likely change or be removed, so they should not be used except for experimentation purposes.</p> </li> <li> <p> disableBytesTypePromotions [boolean]: Disables legacy behavior where <code>bytearray</code> and <code>memoryview</code> are considered subtypes of <code>bytes</code>. PEP 688 deprecates this behavior, but this switch is provided to restore the older behavior.</p> </li> </ul>"},{"location":"configuration/config-files/#type-check-diagnostics-settings","title":"Type Check Diagnostics Settings","text":"<p>The following settings control pyright\u2019s diagnostic output (warnings or errors).</p> <ul> <li> <p>typeCheckingMode [\"off\", \"basic\", \"standard\", \"strict\", \"all\"]: Specifies the default rule set to use. Some rules can be overridden using additional configuration flags documented below. The default value for this setting is \"all\". If set to \"off\", all type-checking rules are disabled, but Python syntax and semantic errors are still reported.</p> </li> <li> <p>ignore [array of paths, optional]: Paths of directories or files whose diagnostic output (errors and warnings) should be suppressed even if they are an included file or within the transitive closure of an included file. Paths may contain wildcard characters ** (a directory or multiple levels of directories), * (a sequence of zero or more characters), or ? (a single character). This setting can be overridden in VS code in your settings.json.</p> </li> </ul>"},{"location":"configuration/config-files/#type-check-rule-overrides","title":"Type Check Rule Overrides","text":"<p>The following settings allow more fine grained control over the typeCheckingMode. Unless otherwise specified, each diagnostic setting can specify a boolean value (<code>false</code> indicating that no error is generated and <code>true</code> indicating that an error is generated). Alternatively, a string value of <code>\"none\"</code>, <code>\"warning\"</code>, <code>\"information\"</code>, or <code>\"error\"</code> can be used to specify the diagnostic level.</p> <ul> <li> <p> reportGeneralTypeIssues [boolean or string, optional]: Generate or suppress diagnostics for general type inconsistencies, unsupported operations, argument/parameter mismatches, etc. This covers all of the basic type-checking rules not covered by other rules. It does not include syntax errors.</p> </li> <li> <p> reportPropertyTypeMismatch [boolean or string, optional]: Generate or suppress diagnostics for properties where the type of the value passed to the setter is not assignable to the value returned by the getter. Such mismatches violate the intended use of properties, which are meant to act like variables.</p> </li> <li> <p> reportFunctionMemberAccess [boolean or string, optional]: Generate or suppress diagnostics for non-standard member accesses for functions.</p> </li> <li> <p> reportMissingImports [boolean or string, optional]: Generate or suppress diagnostics for imports that have no corresponding imported python file or type stub file.</p> </li> <li> <p> reportMissingModuleSource [boolean or string, optional]: Generate or suppress diagnostics for imports that have no corresponding source file. This happens when a type stub is found, but the module source file was not found, indicating that the code may fail at runtime when using this execution environment. Type checking will be done using the type stub.</p> </li> <li> <p> reportInvalidTypeForm [boolean or string, optional]: Generate or suppress diagnostics for type annotations that use invalid type expression forms or are semantically invalid.</p> </li> <li> <p> reportMissingTypeStubs [boolean or string, optional]: Generate or suppress diagnostics for imports that have no corresponding type stub file (either a typeshed file or a custom type stub). The type checker requires type stubs to do its best job at analysis.</p> </li> <li> <p> reportImportCycles [boolean or string, optional]: Generate or suppress diagnostics for cyclical import chains. These are not errors in Python, but they do slow down type analysis and often hint at architectural layering issues. Generally, they should be avoided.</p> </li> <li> <p> reportUnusedImport [boolean or string, optional]: Generate or suppress diagnostics for an imported symbol that is not referenced within that file.</p> </li> <li> <p> reportUnusedClass [boolean or string, optional]: Generate or suppress diagnostics for a class with a private name (starting with an underscore) that is not accessed.</p> </li> <li> <p> reportUnusedFunction [boolean or string, optional]: Generate or suppress diagnostics for a function or method with a private name (starting with an underscore) that is not accessed.</p> </li> <li> <p> reportUnusedVariable [boolean or string, optional]: Generate or suppress diagnostics for a variable that is not accessed.</p> </li> <li> <p> reportDuplicateImport [boolean or string, optional]: Generate or suppress diagnostics for an imported symbol or module that is imported more than once.</p> </li> <li> <p> reportWildcardImportFromLibrary [boolean or string, optional]: Generate or suppress diagnostics for a wildcard import from an external library. The use of this language feature is highly discouraged and can result in bugs when the library is updated.</p> </li> <li> <p> reportAbstractUsage [boolean or string, optional]: Generate or suppress diagnostics for the attempted instantiate an abstract or protocol class or use of an abstract method.</p> </li> <li> <p> reportArgumentType [boolean or string, optional]: Generate or suppress diagnostics for argument type incompatibilities when evaluating a call expression.</p> </li> <li> <p> reportAssertTypeFailure [boolean or string, optional]: Generate or suppress diagnostics for a type mismatch detected by the <code>typing.assert_type</code> call.</p> </li> <li> <p> reportAssignmentType [boolean or string, optional]: Generate or suppress diagnostics for assignment type incompatibility.</p> </li> <li> <p> reportAttributeAccessIssue [boolean or string, optional]: Generate or suppress diagnostics related to attribute accesses.</p> </li> <li> <p> reportCallIssue [boolean or string, optional]: Generate or suppress diagnostics related to call expressions and arguments passed to a call target.</p> </li> <li> <p> reportInconsistentOverload [boolean or string, optional]: Generate or suppress diagnostics for an overloaded function that has overload signatures that are inconsistent with each other or with the implementation.</p> </li> <li> <p> reportIndexIssue [boolean or string, optional]: Generate or suppress diagnostics related to index operations and expressions.</p> </li> <li> <p> reportInvalidTypeArguments [boolean or string, optional]: Generate or suppress diagnostics for invalid type argument usage.</p> </li> <li> <p> reportNoOverloadImplementation [boolean or string, optional]: Generate or suppress diagnostics for an overloaded function or method if the implementation is not provided.</p> </li> <li> <p> reportOperatorIssue [boolean or string, optional]: Generate or suppress diagnostics related to the use of unary or binary operators (like <code>*</code> or <code>not</code>).</p> </li> <li> <p> reportOptionalSubscript [boolean or string, optional]: Generate or suppress diagnostics for an attempt to subscript (index) a variable with an Optional type.</p> </li> <li> <p> reportOptionalMemberAccess [boolean or string, optional]: Generate or suppress diagnostics for an attempt to access a member of a variable with an Optional type.</p> </li> <li> <p> reportOptionalCall [boolean or string, optional]: Generate or suppress diagnostics for an attempt to call a variable with an Optional type.</p> </li> <li> <p> reportOptionalIterable [boolean or string, optional]: Generate or suppress diagnostics for an attempt to use an Optional type as an iterable value (e.g. within a <code>for</code> statement).</p> </li> <li> <p> reportOptionalContextManager [boolean or string, optional]: Generate or suppress diagnostics for an attempt to use an Optional type as a context manager (as a parameter to a <code>with</code> statement).</p> </li> <li> <p> reportOptionalOperand [boolean or string, optional]: Generate or suppress diagnostics for an attempt to use an Optional type as an operand to a unary operator (like <code>~</code> or <code>not</code>) or the left-hand operator of a binary operator (like <code>*</code>, <code>==</code>, <code>or</code>).</p> </li> <li> <p> reportRedeclaration [boolean or string, optional]: Generate or suppress diagnostics for a symbol that has more than one type declaration.</p> </li> <li> <p> reportReturnType [boolean or string, optional]: Generate or suppress diagnostics related to function return type compatibility.</p> </li> <li> <p> reportTypedDictNotRequiredAccess [boolean or string, optional]: Generate or suppress diagnostics for an attempt to access a non-required field within a TypedDict without first checking whether it is present.</p> </li> <li> <p> reportUntypedFunctionDecorator [boolean or string, optional]: Generate or suppress diagnostics for function decorators that have no type annotations. These obscure the function type, defeating many type analysis features.</p> </li> <li> <p> reportUntypedClassDecorator [boolean or string, optional]: Generate or suppress diagnostics for class decorators that have no type annotations. These obscure the class type, defeating many type analysis features.</p> </li> <li> <p> reportUntypedBaseClass [boolean or string, optional]: Generate or suppress diagnostics for base classes whose type cannot be determined statically. These obscure the class type, defeating many type analysis features.</p> </li> <li> <p> reportUntypedNamedTuple [boolean or string, optional]: Generate or suppress diagnostics when \u201cnamedtuple\u201d is used rather than \u201cNamedTuple\u201d. The former contains no type information, whereas the latter does.</p> </li> <li> <p> reportPrivateUsage [boolean or string, optional]: Generate or suppress diagnostics for incorrect usage of private or protected variables or functions. Protected class members begin with a single underscore (\u201c_\u201d) and can be accessed only by subclasses. Private class members begin with a double underscore but do not end in a double underscore and can be accessed only within the declaring class. Variables and functions declared outside of a class are considered private if their names start with either a single or double underscore, and they cannot be accessed outside of the declaring module.</p> </li> <li> <p> reportTypeCommentUsage [boolean or string, optional]: Prior to Python 3.5, the grammar did not support type annotations, so types needed to be specified using \u201ctype comments\u201d. Python 3.5 eliminated the need for function type comments, and Python 3.6 eliminated the need for variable type comments. Future versions of Python will likely deprecate all support for type comments. If enabled, this check will flag any type comment usage unless it is required for compatibility with the specified language version.</p> </li> <li> <p> reportPrivateImportUsage [boolean or string, optional]: Generate or suppress diagnostics for use of a symbol from a third party \"py.typed\" module that is not meant to be exported from that module.</p> </li> <li> <p> reportConstantRedefinition [boolean or string, optional]: Generate or suppress diagnostics for attempts to redefine variables whose names are all-caps with underscores and numerals.</p> </li> <li> <p> reportDeprecated [boolean or string, optional]: Generate or suppress diagnostics for use of a class or function that has been marked as deprecated.</p> </li> <li> <p> reportIncompatibleMethodOverride [boolean or string, optional]: Generate or suppress diagnostics for methods that override a method of the same name in a base class in an incompatible manner (wrong number of parameters, incompatible parameter types, or incompatible return type).</p> </li> <li> <p> reportIncompatibleVariableOverride [boolean or string, optional]: Generate or suppress diagnostics for class variable declarations that override a symbol of the same name in a base class with a type that is incompatible with the base class symbol type.</p> </li> <li> <p> reportInconsistentConstructor [boolean or string, optional]: Generate or suppress diagnostics when an <code>__init__</code> method signature is inconsistent with a <code>__new__</code> signature.</p> </li> <li> <p> reportOverlappingOverload [boolean or string, optional]: Generate or suppress diagnostics for function overloads that overlap in signature and obscure each other or have incompatible return types.</p> </li> <li> <p> reportPossiblyUnboundVariable [boolean or string, optional]: Generate or suppress diagnostics for variables that are possibly unbound on some code paths.</p> </li> <li> <p> reportMissingSuperCall [boolean or string, optional]: Generate or suppress diagnostics for <code>__init__</code>, <code>__init_subclass__</code>, <code>__enter__</code> and <code>__exit__</code> methods in a subclass that fail to call through to the same-named method on a base class.</p> </li> <li> <p> reportUninitializedInstanceVariable [boolean or string, optional]: Generate or suppress diagnostics for instance variables within a class that are not initialized or declared within the class body or the <code>__init__</code> method.</p> </li> <li> <p> reportInvalidStringEscapeSequence [boolean or string, optional]: Generate or suppress diagnostics for invalid escape sequences used within string literals. The Python specification indicates that such sequences will generate a syntax error in future versions.</p> </li> <li> <p> reportUnknownParameterType [boolean or string, optional]: Generate or suppress diagnostics for input or return parameters for functions or methods that have an unknown type.</p> </li> <li> <p> reportUnknownArgumentType [boolean or string, optional]: Generate or suppress diagnostics for call arguments for functions or methods that have an unknown type.</p> </li> <li> <p> reportUnknownLambdaType [boolean or string, optional]: Generate or suppress diagnostics for input or return parameters for lambdas that have an unknown type.</p> </li> <li> <p> reportUnknownVariableType [boolean or string, optional]: Generate or suppress diagnostics for variables that have an unknown type.</p> </li> <li> <p> reportUnknownMemberType [boolean or string, optional]: Generate or suppress diagnostics for class or instance variables that have an unknown type.</p> </li> <li> <p> reportMissingParameterType [boolean or string, optional]: Generate or suppress diagnostics for input parameters for functions or methods that are missing a type annotation. The <code>self</code> and <code>cls</code> parameters used within methods are exempt from this check.</p> </li> <li> <p> reportMissingTypeArgument [boolean or string, optional]: Generate or suppress diagnostics when a generic class is used without providing explicit or implicit type arguments.</p> </li> <li> <p> reportInvalidTypeVarUse [boolean or string, optional]: Generate or suppress diagnostics when a TypeVar is used inappropriately (e.g. if a TypeVar appears only once) within a generic function signature.</p> </li> <li> <p> reportCallInDefaultInitializer [boolean or string, optional]: Generate or suppress diagnostics for function calls, list expressions, set expressions, or dictionary expressions within a default value initialization expression. Such calls can mask expensive operations that are performed at module initialization time.</p> </li> <li> <p> reportUnnecessaryIsInstance [boolean or string, optional]: Generate or suppress diagnostics for <code>isinstance</code> or <code>issubclass</code> calls where the result is statically determined to be always true or always false. Such calls are often indicative of a programming error.</p> </li> <li> <p> reportUnnecessaryCast [boolean or string, optional]: Generate or suppress diagnostics for <code>cast</code> calls that are statically determined to be unnecessary. Such calls are sometimes indicative of a programming error.</p> </li> <li> <p> reportUnnecessaryComparison [boolean or string, optional]: Generate or suppress diagnostics for <code>==</code> or <code>!=</code> comparisons or other conditional expressions that are statically determined to always evaluate to False or True. Such comparisons are sometimes indicative of a programming error.</p> </li> <li> <p> reportUnnecessaryContains [boolean or string, optional]: Generate or suppress diagnostics for <code>in</code> operations that are statically determined to always evaluate to False or True. Such operations are sometimes indicative of a programming error.</p> </li> <li> <p> reportAssertAlwaysTrue [boolean or string, optional]: Generate or suppress diagnostics for <code>assert</code> statement that will provably always assert because its first argument is a parenthesized tuple (for example, <code>assert (v &gt; 0, \"Bad value\")</code> when the intent was probably <code>assert v &gt; 0, \"Bad value\"</code>). This is a common programming error.</p> </li> <li> <p> reportSelfClsParameterName [boolean or string, optional]: Generate or suppress diagnostics for a missing or misnamed \u201cself\u201d parameter in instance methods and \u201ccls\u201d parameter in class methods. Instance methods in metaclasses (classes that derive from \u201ctype\u201d) are allowed to use \u201ccls\u201d for instance methods.</p> </li> <li> <p> reportImplicitStringConcatenation [boolean or string, optional]: Generate or suppress diagnostics for two or more string literals that follow each other, indicating an implicit concatenation. This is considered a bad practice and often masks bugs such as missing commas.</p> </li> <li> <p> reportUndefinedVariable [boolean or string, optional]: Generate or suppress diagnostics for undefined variables.</p> </li> <li> <p> reportUnboundVariable [boolean or string, optional]: Generate or suppress diagnostics for unbound variables.</p> </li> <li> <p> reportUnhashable [boolean or string, optional]: Generate or suppress diagnostics for the use of an unhashable object in a container that requires hashability. The default value for this setting is <code>\"error\"</code>.</p> </li> <li> <p> reportInvalidStubStatement [boolean or string, optional]: Generate or suppress diagnostics for statements that are syntactically correct but have no purpose within a type stub file.</p> </li> <li> <p> reportIncompleteStub [boolean or string, optional]: Generate or suppress diagnostics for a module-level <code>__getattr__</code> call in a type stub file, indicating that it is incomplete.</p> </li> <li> <p> reportUnsupportedDunderAll [boolean or string, optional]: Generate or suppress diagnostics for statements that define or manipulate <code>__all__</code> in a way that is not allowed by a static type checker, thus rendering the contents of <code>__all__</code> to be unknown or incorrect. Also reports names within the <code>__all__</code> list that are not present in the module namespace.</p> </li> <li> <p> reportUnusedCallResult [boolean or string, optional]: Generate or suppress diagnostics for call statements whose return value is not used in any way and is not None.</p> </li> <li> <p> reportUnusedCoroutine [boolean or string, optional]: Generate or suppress diagnostics for call statements whose return value is not used in any way and is a Coroutine. This identifies a common error where an <code>await</code> keyword is mistakenly omitted.</p> </li> <li> <p> reportUnusedExcept [boolean or string, optional]: Generate or suppress diagnostics for an <code>except</code> clause that will never be reached.</p> </li> <li> <p> reportUnusedExpression [boolean or string, optional]: Generate or suppress diagnostics for simple expressions whose results are not used in any way.</p> </li> <li> <p> reportUnnecessaryTypeIgnoreComment [boolean or string, optional]: Generate or suppress diagnostics for a <code># type: ignore</code> or <code># pyright: ignore</code> comment that would have no effect if removed.</p> </li> <li> <p> reportMatchNotExhaustive [boolean or string, optional]: Generate or suppress diagnostics for a <code>match</code> statement that does not provide cases that exhaustively match against all potential types of the target expression.</p> </li> <li> <p> reportImplicitOverride [boolean or string, optional]: Generate or suppress diagnostics for overridden methods in a class that are missing an explicit <code>@override</code> decorator.</p> </li> <li> <p> reportShadowedImports [boolean or string, optional]: Generate or suppress diagnostics for files that are overriding a module in the stdlib.</p> </li> </ul>"},{"location":"configuration/config-files/#based-options","title":"Based options","text":"<p>the following additional options are not available in regular pyright:</p> <ul> <li> <p> reportUnreachable [boolean or string, optional]: Generate or suppress diagnostics for unreachable code.</p> </li> <li> <p> reportAny [boolean or string, optional]: Ban all usages of the <code>Any</code> type. this accounts for all scenarios not covered by the <code>reportUnknown*</code> rules (since \"Unknown\" isn't a real type, but a distinction pyright makes to disallow the <code>Any</code> type only in certain circumstances).</p> </li> <li> <p> reportIgnoreCommentWithoutRule [boolean or string, optional]: Enforce that all <code># type:ignore</code>/<code># pyright:ignore</code> comments specify a rule in brackets (eg. <code># pyright:ignore[reportAny]</code>)</p> </li> <li> <p> reportPrivateLocalImportUsage [boolean or string, optional]: Generate or suppress diagnostics for use of a symbol from a local module that is not meant to be exported from that module. Like <code>reportPrivateImportUsage</code> but also checks imports from your own code.</p> </li> <li> <p> reportImplicitRelativeImport [boolean or string, optional]: Generate or suppress diagnostics for non-relative imports that do not specify the full path to the module.</p> </li> <li> <p> reportInvalidCast [boolean or string, optional]: Generate or suppress diagnostics for <code>cast</code>s to non-overlapping types.</p> </li> <li> <p> reportUnsafeMultipleInheritance [boolean or string, optional]: Generate or suppress diagnostics for classes that inherit from multiple base classes with an <code>__init__</code> or <code>__new__</code> method, which is unsafe because those additional constructors may either never get called or get called with invalid arguments.</p> </li> <li> <p> reportUnusedParameter [boolean or string, optional]: Generate or suppress diagnostics for unused function parameters.</p> </li> </ul>"},{"location":"configuration/config-files/#discouraged-options","title":"Discouraged options","text":"<p>there are rules in pyright that are discouraged in basedpyright because we provide a better alternative. these options are still available for backwards compatibility, but you shouldn't use them.</p> <ul> <li> <p> enableTypeIgnoreComments [boolean]: PEP 484 defines support for <code># type: ignore</code> comments. This switch enables or disables support for these comments. This option is discouraged in favor of <code># pyright: ignore</code> comments in basedpyright, as they are safer. See here for more information.</p> </li> <li> <p> enableReachabilityAnalysis [boolean]: If enabled, code that is determined to be unreachable by type analysis is reported using a tagged hint. This setting does not affect code that is determined to be unreachable regardless of type analysis; such code is always reported as unreachable. This setting also has no effect when when using the command-line version of pyright because it never emits tagged hints for unreachable code. this rule is discouraged in basedpyright in favor of <code>reportUnreachable</code>.</p> </li> </ul>"},{"location":"configuration/config-files/#execution-environment-options","title":"Execution Environment Options","text":"<p>Pyright allows multiple \u201cexecution environments\u201d to be defined for different portions of your source tree. For example, a subtree may be designed to run with different import search paths or a different version of the python interpreter than the rest of the source base.</p> <p>The following settings can be specified for each execution environment. Each source file within a project is associated with at most one execution environment -- the first one whose root directory contains that file.</p> <ul> <li> <p>root [string, required]: Root path for the code that will execute within this execution environment.</p> </li> <li> <p>extraPaths [array of strings, optional]: Additional search paths (in addition to the root path) that will be used when searching for modules imported by files within this execution environment. If specified, this overrides the default extraPaths setting when resolving imports for files within this execution environment. Note that each file\u2019s execution environment mapping is independent, so if file A is in one execution environment and imports a second file B within a second execution environment, any imports from B will use the extraPaths in the second execution environment.</p> </li> <li> <p>pythonVersion [string, optional]: The version of Python used for this execution environment. If not specified, the global <code>pythonVersion</code> setting is used instead.</p> </li> <li> <p>pythonPlatform [string, optional]: Specifies the target platform that will be used for this execution environment. If not specified, the global <code>pythonPlatform</code> setting is used instead.</p> </li> </ul> <p>In addition, any of the type check diagnostics settings listed above can be specified. These settings act as overrides for the files in this execution environment.</p>"},{"location":"configuration/config-files/#sample-config-file","title":"Sample Config File","text":"<p>The following is an example of a pyright config file: pyrightconfig.json<pre><code>{\n  \"include\": [\n    \"src\"\n  ],\n\n  \"exclude\": [\n    \"**/node_modules\",\n    \"**/__pycache__\",\n    \"src/experimental\",\n    \"src/typestubs\"\n  ],\n\n  \"ignore\": [\n    \"src/oldstuff\"\n  ],\n\n  \"defineConstant\": {\n    \"DEBUG\": true\n  },\n\n  \"stubPath\": \"src/stubs\",\n\n  \"reportMissingImports\": \"error\",\n  \"reportMissingTypeStubs\": false,\n\n  \"pythonVersion\": \"3.6\",\n  \"pythonPlatform\": \"Linux\",\n\n  \"executionEnvironments\": [\n    {\n      \"root\": \"src/web\",\n      \"pythonVersion\": \"3.5\",\n      \"pythonPlatform\": \"Windows\",\n      \"extraPaths\": [\n        \"src/service_libs\"\n      ],\n      \"reportMissingImports\": \"warning\"\n    },\n    {\n      \"root\": \"src/sdk\",\n      \"pythonVersion\": \"3.0\",\n      \"extraPaths\": [\n        \"src/backend\"\n      ]\n    },\n    {\n      \"root\": \"src/tests\",\n      \"reportPrivateUsage\": false,\n      \"extraPaths\": [\n        \"src/tests/e2e\",\n        \"src/sdk\"\n      ]\n    },\n    {\n      \"root\": \"src\"\n    }\n  ]\n}\n</code></pre></p>"},{"location":"configuration/config-files/#sample-pyprojecttoml-file","title":"Sample pyproject.toml File","text":"pyproject.toml<pre><code>[tool.basedpyright]\ninclude = [\"src\"]\nexclude = [\"**/node_modules\",\n    \"**/__pycache__\",\n    \"src/experimental\",\n    \"src/typestubs\"\n]\nignore = [\"src/oldstuff\"]\ndefineConstant = { DEBUG = true }\nstubPath = \"src/stubs\"\n\nreportMissingImports = \"error\"\nreportMissingTypeStubs = false\n\npythonVersion = \"3.6\"\npythonPlatform = \"Linux\"\n\nexecutionEnvironments = [\n  { root = \"src/web\", pythonVersion = \"3.5\", pythonPlatform = \"Windows\", extraPaths = [ \"src/service_libs\" ], reportMissingImports = \"warning\" },\n  { root = \"src/sdk\", pythonVersion = \"3.0\", extraPaths = [ \"src/backend\" ] },\n  { root = \"src/tests\", reportPrivateUsage = false, extraPaths = [\"src/tests/e2e\", \"src/sdk\" ]},\n  { root = \"src\" }\n]\n</code></pre>"},{"location":"configuration/config-files/#diagnostic-settings-defaults","title":"Diagnostic Settings Defaults","text":"<p>Each diagnostic setting has a default that is dictated by the specified type checking mode. The default for each rule can be overridden in the configuration file or settings. In strict type checking mode, overrides may only increase the strictness (e.g. increase the severity level from <code>\"warning\"</code> to <code>\"error\"</code>).</p> <p>Some rules have an additional severity level such as <code>\"unused\"</code>, <code>\"deprecated\"</code> or <code>\"unreachable\"</code>. These are only used by the language server so that your editor can grey out or add a strikethrough to the symbol, which you can disable by setting it to <code>\"off\"</code>. it does not effect the outcome when running basedpyright via the CLI, so in that context these severity levels essentially mean the same thing as <code>\"off\"</code>.</p> <p>The following table lists the default severity levels for each diagnostic rule within each type checking mode (<code>\"off\"</code>, <code>\"basic\"</code>, <code>\"standard\"</code>, <code>\"strict\"</code> and <code>\"all\"</code>).</p> <p>note that some settings which are enabled by default in pyright are disabled by default in basedpyright (even though the default <code>typeCheckingMode</code> is <code>\"all\"</code>). this is because these rules are discouraged, but in the interest of backwards compatibility with pyright, they remain available to any users who still want to use them.</p> Diagnostic Rule Off Basic Standard Strict All analyzeUnannotatedFunctions true true true true true disableBytesTypePromotions true true true true true strictParameterNoneValue false true true true true enableTypeIgnoreComments true true true true false enableReachabilityAnalysis false true true true true strictListInference false false false true true strictDictionaryInference false false false true true strictSetInference false false false true true deprecateTypingAliases false false false false true enableExperimentalFeatures false false false false true reportMissingModuleSource \"none\" \"warning\" \"warning\" \"warning\" \"error\" reportInvalidTypeForm \"none\" \"error\" \"error\" \"error\" \"error\" reportMissingImports \"none\" \"error\" \"error\" \"error\" \"error\" reportUndefinedVariable \"none\" \"error\" \"error\" \"error\" \"error\" reportAssertAlwaysTrue \"none\" \"warning\" \"warning\" \"error\" \"error\" reportInvalidStringEscapeSequence \"none\" \"warning\" \"warning\" \"error\" \"error\" reportInvalidTypeVarUse \"none\" \"warning\" \"warning\" \"error\" \"error\" reportMissingTypeStubs \"none\" \"none\" \"none\" \"error\" \"error\" reportSelfClsParameterName \"none\" \"warning\" \"warning\" \"error\" \"error\" reportUnsupportedDunderAll \"none\" \"warning\" \"warning\" \"error\" \"error\" reportUnusedExpression \"none\" \"warning\" \"warning\" \"error\" \"error\" reportWildcardImportFromLibrary \"none\" \"warning\" \"warning\" \"error\" \"error\" reportAbstractUsage \"none\" \"error\" \"error\" \"error\" \"error\" reportArgumentType \"none\" \"error\" \"error\" \"error\" \"error\" reportAssertTypeFailure \"none\" \"error\" \"error\" \"error\" \"error\" reportAssignmentType \"none\" \"error\" \"error\" \"error\" \"error\" reportAttributeAccessIssue \"none\" \"error\" \"error\" \"error\" \"error\" reportCallIssue \"none\" \"error\" \"error\" \"error\" \"error\" reportGeneralTypeIssues \"none\" \"error\" \"error\" \"error\" \"error\" reportInconsistentOverload \"none\" \"error\" \"error\" \"error\" \"error\" reportIndexIssue \"none\" \"error\" \"error\" \"error\" \"error\" reportInvalidTypeArguments \"none\" \"error\" \"error\" \"error\" \"error\" reportNoOverloadImplementation \"none\" \"error\" \"error\" \"error\" \"error\" reportOperatorIssue \"none\" \"error\" \"error\" \"error\" \"error\" reportOptionalSubscript \"none\" \"error\" \"error\" \"error\" \"error\" reportOptionalMemberAccess \"none\" \"error\" \"error\" \"error\" \"error\" reportOptionalCall \"none\" \"error\" \"error\" \"error\" \"error\" reportOptionalIterable \"none\" \"error\" \"error\" \"error\" \"error\" reportOptionalContextManager \"none\" \"error\" \"error\" \"error\" \"error\" reportOptionalOperand \"none\" \"error\" \"error\" \"error\" \"error\" reportRedeclaration \"none\" \"error\" \"error\" \"error\" \"error\" reportReturnType \"none\" \"error\" \"error\" \"error\" \"error\" reportTypedDictNotRequiredAccess \"none\" \"error\" \"error\" \"error\" \"error\" reportPrivateImportUsage \"none\" \"error\" \"error\" \"error\" \"error\" reportUnboundVariable \"none\" \"error\" \"error\" \"error\" \"error\" reportUnhashable \"none\" \"error\" \"error\" \"error\" \"error\" reportUnusedCoroutine \"none\" \"error\" \"error\" \"error\" \"error\" reportUnusedExcept \"unreachable\" \"error\" \"error\" \"error\" \"error\" reportFunctionMemberAccess \"none\" \"none\" \"error\" \"error\" \"error\" reportIncompatibleMethodOverride \"none\" \"none\" \"error\" \"error\" \"error\" reportIncompatibleVariableOverride \"none\" \"none\" \"error\" \"error\" \"error\" reportOverlappingOverload \"none\" \"none\" \"error\" \"error\" \"error\" reportPossiblyUnboundVariable \"none\" \"none\" \"error\" \"error\" \"error\" reportConstantRedefinition \"none\" \"none\" \"none\" \"error\" \"error\" reportDeprecated \"deprecated\" \"deprecated\" \"deprecated\" \"error\" \"error\" reportDuplicateImport \"none\" \"none\" \"none\" \"error\" \"error\" reportIncompleteStub \"none\" \"none\" \"none\" \"error\" \"error\" reportInconsistentConstructor \"none\" \"none\" \"none\" \"error\" \"error\" reportInvalidStubStatement \"none\" \"none\" \"none\" \"error\" \"error\" reportMatchNotExhaustive \"none\" \"none\" \"none\" \"error\" \"error\" reportMissingParameterType \"none\" \"none\" \"none\" \"error\" \"error\" reportMissingTypeArgument \"none\" \"none\" \"none\" \"error\" \"error\" reportPrivateUsage \"none\" \"none\" \"none\" \"error\" \"error\" reportTypeCommentUsage \"deprecated\" \"deprecated\" \"deprecated\" \"error\" \"error\" reportUnknownArgumentType \"none\" \"none\" \"none\" \"error\" \"error\" reportUnknownLambdaType \"none\" \"none\" \"none\" \"error\" \"error\" reportUnknownMemberType \"none\" \"none\" \"none\" \"error\" \"error\" reportUnknownParameterType \"none\" \"none\" \"none\" \"error\" \"error\" reportUnknownVariableType \"none\" \"none\" \"none\" \"error\" \"error\" reportUnnecessaryCast \"none\" \"none\" \"none\" \"error\" \"error\" reportUnnecessaryComparison \"none\" \"none\" \"none\" \"error\" \"error\" reportUnnecessaryContains \"none\" \"none\" \"none\" \"error\" \"error\" reportUnnecessaryIsInstance \"none\" \"none\" \"none\" \"error\" \"error\" reportUnusedClass \"unused\" \"unused\" \"unused\" \"error\" \"error\" reportUnusedImport \"unused\" \"unused\" \"unused\" \"error\" \"error\" reportUnusedFunction \"unused\" \"unused\" \"unused\" \"error\" \"error\" reportUnusedVariable \"unused\" \"unused\" \"unused\" \"error\" \"error\" reportUntypedBaseClass \"none\" \"none\" \"none\" \"error\" \"error\" reportUntypedClassDecorator \"none\" \"none\" \"none\" \"error\" \"error\" reportUntypedFunctionDecorator \"none\" \"none\" \"none\" \"error\" \"error\" reportUntypedNamedTuple \"none\" \"none\" \"none\" \"error\" \"error\" reportCallInDefaultInitializer \"none\" \"none\" \"none\" \"none\" \"error\" reportImplicitOverride \"none\" \"none\" \"none\" \"none\" \"error\" reportImplicitStringConcatenation \"none\" \"none\" \"none\" \"none\" \"error\" reportImportCycles \"none\" \"none\" \"none\" \"none\" \"error\" reportMissingSuperCall \"none\" \"none\" \"none\" \"none\" \"error\" reportPropertyTypeMismatch \"none\" \"none\" \"none\" \"none\" \"error\" reportShadowedImports \"none\" \"none\" \"none\" \"none\" \"error\" reportUninitializedInstanceVariable \"none\" \"none\" \"none\" \"none\" \"error\" reportUnnecessaryTypeIgnoreComment \"none\" \"none\" \"none\" \"none\" \"error\" reportUnusedCallResult \"none\" \"none\" \"none\" \"none\" \"error\" reportUnreachable \"unreachable\" \"unreachable\" \"unreachable\" \"unreachable\" \"error\" reportAny \"none\" \"none\" \"none\" \"none\" \"error\" reportIgnoreCommentWithoutRule \"none\" \"none\" \"none\" \"none\" \"error\" reportPrivateLocalImportUsage \"none\" \"none\" \"none\" \"none\" \"error\" reportImplicitRelativeImport \"none\" \"none\" \"none\" \"none\" \"error\" reportInvalidCast \"none\" \"none\" \"none\" \"none\" \"error\" reportUnsafeMultipleInheritance \"none\" \"none\" \"none\" \"none\" \"error\" reportUnusedParameter \"unused\" \"unused\" \"unused\" \"unused\" \"error\""},{"location":"configuration/config-files/#overriding-language-server-settings","title":"Overriding language server settings","text":"<p>If a <code>pyproject.toml</code> (with a <code>basedpyright</code> or <code>pyright</code> section) or a <code>pyrightconfig.json</code> exists, any dicouraged language server settings (eg. in a VS Code <code>settings.json</code>) will be ignored. <code>pyrightconfig.json</code> is prescribing the environment to be used for a particular project. Changing the environment configuration options per user is not supported.</p> <p>If a <code>pyproject.toml</code> (with a <code>basedpyright</code> or <code>pyright</code> section) or a <code>pyrightconfig.json</code> does not exist, then the language server settings apply.</p> <p>for more information about why this is the case, see here.</p>"},{"location":"configuration/config-files/#locale-configuration","title":"Locale Configuration","text":"<p>Pyright provides diagnostic messages that are translated to multiple languages. By default, pyright uses the default locale of the operating system. You can override the desired locale through the use of one of the following environment variables, listed in priority order.</p> <pre><code>LC_ALL=\"de\"\nLC_MESSAGES=\"en-us\"\nLANG=\"zh-cn\"\nLANGUAGE=\"fr\"\n</code></pre> <p>When running in VS Code, the editor's locale takes precedence. Setting these environment variables applies only when using pyright outside of VS Code.</p>"},{"location":"configuration/language-server-settings/","title":"Language Server Settings","text":"<p>for users migrating from pyright or pylance</p> <p>with the exception of <code>python.pythonPath</code> and <code>python.venvPath</code>, settings prefixed with <code>python.*</code> are not supported in basedpyright. use <code>basedpyright.*</code> instead.</p> <p>The basedpyright language server honors the following settings.</p> <p>basedpyright.disableLanguageServices [boolean]: Disables all language services. This includes hover text, type completion, signature completion, find definition, find references, etc. This option is useful if you want to use pyright only as a type checker but want to run another Python language server for language service features.</p> <p>basedpyright.disableOrganizeImports [boolean]: Disables the \u201cOrganize Imports\u201d command. This is useful if you are using another extension that provides similar functionality and you don\u2019t want the two extensions to fight each other.</p> <p>basedpyright.disableTaggedHints [boolean]: Disables the use of hint diagnostics with special tags to tell the client to display text ranges in a \"grayed out\" manner (to indicate unreachable code or unreferenced symbols) or in a \"strike through\" manner (to indicate use of a deprecated feature).</p> <p>basedpyright.openFilesOnly [boolean]: Determines whether pyright analyzes (and reports errors for) all files in the workspace, as indicated by the config file. If this option is set to true, pyright analyzes only open files. This setting is deprecated in favor of basedpyright.analysis.diagnosticMode. It will be removed at a future time.</p> <p>basedpyright.useLibraryCodeForTypes [boolean]: This setting is deprecated in favor of basedpyright.analysis.useLibraryCodeForTypes. It will be removed at a future time.</p> <p>basedpyright.analysis.autoImportCompletions [boolean]: Determines whether pyright offers auto-import completions.</p> <p>basedpyright.analysis.autoSearchPaths [boolean]: Determines whether pyright automatically adds common search paths like \"src\" if there are no execution environments defined in the config file.</p> <p>basedpyright.analysis.diagnosticMode [\"openFilesOnly\", \"workspace\"]: Determines whether pyright analyzes (and reports errors for) all files in the workspace, as indicated by the config file. If this option is set to \"openFilesOnly\", pyright analyzes only open files. Defaults to \"openFilesOnly\"</p> <p>basedpyright.analysis.logLevel [\"Error\", \"Warning\", \"Information\", or \"Trace\"]: Level of logging for Output panel. The default value for this option is \"Information\".</p> <p>python.pythonPath [path]: Path to Python interpreter. This setting is being deprecated by the VS Code Python extension in favor of a setting that is stored in the Python extension\u2019s internal configuration store. Pyright supports both mechanisms but prefers the new one if both settings are present.</p> <p>python.venvPath [path]: Path to folder with subdirectories that contain virtual environments. The <code>python.pythonPath</code> setting is recommended over this mechanism for most users. For more details, refer to the import resolution documentation.</p> <p>a note about <code>python.venvPath</code></p> <p>if your venv path is the same for all users working on your project (which should be the case if you're using uv or pdm), we recommend configuring <code>venvPath</code> in a config file instead. see discouraged settings below for more information.</p>"},{"location":"configuration/language-server-settings/#discouraged-settings","title":"discouraged settings","text":"<p>these options can also be configured using a config file. it's recommended to use either a <code>pyproject.toml</code> or <code>pyrightconfig.json</code> file instead of the language server to configure type checking for the following reasons:</p> <ul> <li>the config should be the same for everybody working on your project. you should commit the config file so that other contributors don't have to manually configure their language server to match yours.</li> <li>it ensures that the basedpyright language server behaves the same as the <code>basedpyright</code> CLI, which is useful if you have your CI configured to type check your code (you should!)</li> </ul> <p>however these settings are still suppored to maintain compatibility with pyright.</p> <p>basedpyright.analysis.diagnosticSeverityOverrides [map]: Allows a user to override the severity levels for individual diagnostic rules. \"reportXXX\" rules in the type check diagnostics settings in configuration are supported. Use the rule name as a key and one of \"error,\" \"warning,\" \"information,\" \"true,\" \"false,\" or \"none\" as value.</p> <p>basedpyright.analysis.exclude [array of paths]: Paths of directories or files that should not be included. This can be overridden in the configuration file.</p> <p>basedpyright.analysis.extraPaths [array of paths]: Paths to add to the default execution environment extra paths if there are no execution environments defined in the config file.</p> <p>basedpyright.analysis.ignore [array of paths]: Paths of directories or files whose diagnostic output (errors and warnings) should be suppressed. This can be overridden in the configuration file.</p> <p>basedpyright.analysis.include [array of paths]: Paths of directories or files that should be included. This can be overridden in the configuration file.</p> <p>basedpyright.analysis.stubPath [path]: Path to directory containing custom type stub files.</p> <p>basedpyright.analysis.typeCheckingMode [\"off\", \"basic\", \"standard\", \"strict\", \"all\"]: Determines the default type-checking level used by pyright. This can be overridden in the configuration file. (Note: This setting used to be called \"pyright.typeCheckingMode\". The old name is deprecated but is still currently honored.)</p> <p>basedpyright.analysis.typeshedPaths [array of paths]: Paths to look for typeshed modules. Pyright currently honors only the first path in the array.</p> <p>basedpyright.analysis.useLibraryCodeForTypes [boolean]: Determines whether pyright reads, parses and analyzes library code to extract type information in the absence of type stub files. Type information will typically be incomplete. We recommend using type stubs where possible. The default value for this option is true.</p>"},{"location":"development/build-debug/","title":"building &amp; debugging","text":""},{"location":"development/build-debug/#building","title":"Building","text":"<p>although pyright is written in typescript, in basedpyright we've made improvements to the developer experience for python developers who are not familiar with typescript/nodejs. you should be able to work on basedpyright without ever having to install nodejs yourself. the node installation is instead managed by a pypi package and installed to the project's virtualenv. the only thing you need to have installed already is python (any version from 3.8 to 3.12 should work)</p> <p>we recommend using vscode, as there are project configuration files in the repo that set everything up correctly (linters/formatters/debug configs, etc).</p> <ol> <li>hit <code>F1</code> &gt; <code>Tasks: Run task</code> &gt; <code>install dependencies</code>, or run the following command:     <pre><code>./pw pdm install\n</code></pre>     this will install all dependencies required for the project (pyprojectx, pdm, node, typescript, etc.). all dependencies are installed locally to <code>./.venv</code> and <code>./node_modules</code></li> <li>press \"Yes\" when prompted by vscode to use the newly created virtualenv</li> </ol> <p>you can now run any node/npm commands from inside the venv.</p>"},{"location":"development/build-debug/#debugging","title":"Debugging","text":"<p>To debug pyright, open the root source directory within VS Code. Open the debug sub-panel and choose \u201cPyright CLI\u201d from the debug target menu. Click on the green \u201crun\u201d icon or press F5 to build and launch the command-line version in the VS Code debugger. There's also a similar option that provides a slightly faster build/debug loop: make sure you've built the pyright-internal project e.g. with Terminal &gt; Run Build Task &gt; tsc: watch, then choose \u201cPyright CLI (pyright-internal)\u201d.</p> <p>To debug the VS Code extension, select \u201cPyright extension\u201d from the debug target menu. Click on the green \u201crun\u201d icon or press F5 to build and launch a second copy of VS Code with the extension. Within the second VS Code instance, open a python source file so the pyright extension is loaded. Return to the first instance of VS Code and select \u201cPyright extension attach server\u201d from the debug target menu and click the green \u201crun\u201d icon. This will attach the debugger to the process that hosts the type checker. You can now set breakpoints, etc.</p> <p>To debug the VS Code extension in watch mode, you can do the above, but select \u201cPyright extension (watch mode)\u201d. When pyright's source is saved, an incremental build will occur, and you can either reload the second VS Code window or relaunch it to start using the updated code. Note that the watcher stays open when debugging stops, so you may need to stop it (or close VS Code) if you want to perform packaging steps without the output potentially being overwritten.</p>"},{"location":"development/internals/","title":"Pyright Internals","text":""},{"location":"development/internals/#code-structure","title":"Code Structure","text":"<ul> <li><code>packages/vscode-pyright/src/extension.ts</code>: Language Server Protocol (LSP) client entry point for VS Code extension.</li> <li><code>packages/pyright-internal/typeshed-fallback/</code>: Recent copy of Typeshed type stub files for Python stdlib</li> <li><code>packages/pyright-internal/src/pyright.ts</code>: Main entry point for command-line tool</li> <li><code>packages/pyright-internal/src/server.ts</code>: Main entry point for LSP server</li> <li><code>packages/pyright-internal/src/analyzer</code>: Modules that perform analysis passes over Python parse tree</li> <li><code>packages/pyright-internal/src/common</code>: Modules  that are common to the parser and analyzer</li> <li><code>packages/pyright-internal/src/parser</code>: Modules that perform tokenization and parsing of Python source</li> <li><code>packages/pyright-internal/src/tests</code>: Tests for the parser and analyzer</li> <li><code>packages/pyright</code>: basedpyright npm package (used internally by the playground)</li> <li><code>basedpyright</code>: pypi package wrapper for the npm package, so that users don't need to install nodejs themselves</li> <li><code>docstubs</code>: stubs with docstrings on compiled modules (generated from <code>packages/pyright-internal/typeshed-fallback/</code> when building the pypi package)</li> </ul>"},{"location":"development/internals/#core-concepts","title":"Core Concepts","text":"<p>Pyright implements a service, a persistent in-memory object that controls the order of analysis and provides an interface for the language server. For multi-root workspaces, each workspace gets its own service instance.</p> <p>The service owns an instance of a program, which tracks the configuration file and all of the source files that make up the source base that is to be analyzed. A source file can be added to a program if it is a) referenced by the config file, b) currently open in the editor, or c) imported directly or indirectly by another source file. The program object is responsible for setting up file system watchers and updating the program as files are added, deleted, or edited. The program is also responsible for prioritizing all phases of analysis for all files, favoring files that are open in the editor (and their import dependencies).</p> <p>The program tracks multiple sourceFile objects. Each source file represents the contents of one Python source file on disk. It tracks the status of analysis for the file, including any intermediate or final results of the analysis and the diagnostics (errors and warnings) that result.</p> <p>The program makes use of an importResolver to resolve the imported modules referenced within each source file.</p>"},{"location":"development/internals/#analysis-phases","title":"Analysis Phases","text":"<p>Pyright performs the following analysis phases for each source file.</p> <p>The tokenizer is responsible for converting the file\u2019s string contents into a stream of tokens. White space, comments, and some end-of-line characters are ignored, as they are not needed by the parser.</p> <p>The parser is responsible for converting the token stream into a parse tree. A generalized parseTreeWalker provides a convenient way to traverse the parse tree. All subsequent analysis phases utilize the parseTreeWalker.</p> <p>The binder is responsible for building scopes and populating the symbol table for each scope. It does not perform any type checking, but it detects and reports some semantic errors that will result in unintended runtime exceptions. It also detects and reports inconsistent name bindings (e.g. a variable that uses both a global and nonlocal binding in the same scope). The binder also builds a \u201creverse code flow graph\u201d for each scope, allowing the type analyzer to determine a symbol\u2019s type at any point in the code flow based on its antecedents.</p> <p>The checker is responsible for checking all of the statements and expressions within a source file. It relies heavily on the typeEvaluator module, which performs most of the heavy lifting. The checker doesn\u2019t run on all files, only those that require full diagnostic output. For example, if a source file is not part of the program but is imported by the program, the checker doesn\u2019t need to run on it.</p>"},{"location":"development/localization/","title":"Localization notes","text":"<p>the translations in pyright come from microsoft's localization team, who are not programmers. this not only results in poor quality translations, but microsoft also doesn't accept contributions to fix them (more info here).</p> <p>in basedpyright we want to fix this but we need your help! if you are fluent in a language other than english and would like to contribute, it would be greatly appreciated.</p> <p>Here are some guidelines for contributors who would like to help improve the translations in basedpyright.</p>"},{"location":"development/localization/#general-guidelines","title":"General guidelines","text":"<ul> <li>Do not use any automatic translation tools.</li> <li>In cases where a word is difficult to translate but it refers to the name of a symbol, leaving it in English and using backticks makes more sense than attempting to translate it. For example, if the English error message says \"cannot assign to Final variable\" then the translation could just be \"\u043d\u0435\u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e \u043f\u0440\u0438\u0441\u0432\u043e\u0438\u0442\u044c \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u043e\u0439 <code>Final</code>\" instead of trying to use a Russian word for \"final\".</li> <li>basedpyright is maintained by developers who only speak English, so it would be helpful if you could get someone who also speaks your language to review your changes as well.</li> <li>new rules that are specific to basedpyright currently do not have any translations at all (see this issue). Providing translations for those would be greatly appreciated.</li> <li>The initial translations from Pyright seem to be pretty low quality and low consistency. If you want to start a \"renovation\" for a particular language, it's a good idea to come up with a glossary of common terms so that the final translations will be consistent. Check if the https://docs.python.org has a translation for your language, and if it does, use that as a baseline.</li> </ul>"},{"location":"development/localization/#specific-languages","title":"Specific languages","text":""},{"location":"development/localization/#russian","title":"Russian","text":""},{"location":"development/localization/#style-guide","title":"Style guide","text":"<ul> <li>\u0411\u0443\u043a\u0432\u0430 \u0401/\u0451 \u043d\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f</li> <li>\u0417\u043d\u0430\u043a \u043f\u0440\u0435\u043f\u0438\u043d\u0430\u043d\u0438\u044f <code>;</code> \u0437\u0430\u043c\u0435\u043d\u044f\u0435\u0442\u0441\u044f \u043d\u0430 \u0442\u043e\u0447\u043a\u0443</li> <li>\u041d\u0435 \u0441\u0442\u043e\u0438\u0442 \u0432 \u0442\u043e\u0447\u043d\u043e\u0441\u0442\u0438 \u043f\u043e\u0432\u0442\u043e\u0440\u044f\u0442\u044c \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u0443 \u0430\u043d\u0433\u043b\u0438\u0439\u0441\u043a\u043e\u0433\u043e \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f, \u0435\u0441\u043b\u0438 \u043e\u043d\u0430 \u043d\u0435\u0435\u0441\u0442\u0435\u0441\u0442\u0432\u0435\u043d\u043d\u0430 \u0434\u043b\u044f \u0440\u0443\u0441\u0441\u043a\u043e\u0433\u043e \u044f\u0437\u044b\u043a\u0430.     \u0412 \u0447\u0430\u0441\u0442\u043d\u043e\u0441\u0442\u0438 \u0438\u0437\u0431\u0435\u0433\u0430\u0439\u0442\u0435 \u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0446\u0438\u0438 <code>X \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f Y</code> (<code>\u043a\u043b\u0430\u0441\u0441 Foo \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0430\u0431\u0441\u0442\u0440\u0430\u043a\u0442\u043d\u044b\u043c</code> -&gt; <code>\u043a\u043b\u0430\u0441\u0441 Foo \u0430\u0431\u0441\u0442\u0440\u0430\u043a\u0442\u043d\u044b\u0439</code>)</li> <li>\u041f\u043e \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u0438 \u0434\u0435\u043b\u0430\u0439\u0442\u0435 \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u0443 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f \u043f\u0440\u043e\u0449\u0435</li> </ul>"},{"location":"development/localization/#_1","title":"\u0413\u043b\u043e\u0441\u0441\u0430\u0440\u0438\u0439","text":"English term Canonical translation Type annotation \u0410\u043d\u043d\u043e\u0442\u0430\u0446\u0438\u044f \u0442\u0438\u043f\u0430 Comprehension \u0412\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 set (\u0432\u0441\u0442\u0440\u043e\u0435\u043d\u043d\u044b\u0439 \u0442\u0438\u043f) \u041c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u043e Type variable \u041f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0430\u044f \u0442\u0438\u043f\u0430 Final <code>Final</code> (\u043a\u0430\u043a \u0435\u0441\u0442\u044c) @final / final class <code>@final</code> (\u043a\u0430\u043a \u0435\u0441\u0442\u044c) Data class \u0414\u0430\u0442\u0430\u043a\u043b\u0430\u0441\u0441 Enum \u041f\u0435\u0440\u0435\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u0435 f-string f-\u0441\u0442\u0440\u043e\u043a\u0430 Format string literal f-\u0441\u0442\u0440\u043e\u043a\u0430 XYZ is deprecated XYZ [\u0431\u043e\u043b\u044c\u0448\u0435] \u043d\u0435 \u0440\u0435\u043a\u043e\u043c\u0435\u043d\u0434\u0443\u0435\u0442\u0441\u044f Complex [number] \u041a\u043e\u043c\u043f\u043b\u0435\u043a\u0441\u043d\u043e\u0435 \u0447\u0438\u0441\u043b\u043e keyword argument/parameter \u0418\u043c\u0435\u043d\u043e\u0432\u0430\u043d\u043d\u044b\u0439 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442/\u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440 mapping mapping (\u043d\u0435\u0442 \u043f\u0435\u0440\u0435\u0432\u043e\u0434\u0430) awaitable awaitable (\u043d\u0435\u0442 \u043f\u0435\u0440\u0435\u0432\u043e\u0434\u0430) \u0438\u043b\u0438: \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u044e\u0449\u0438\u0439 await positional-only \u0442\u043e\u043b\u044c\u043a\u043e \u043f\u043e\u0437\u0438\u0446\u0438\u043e\u043d\u043d\u044b\u0439 keyword-only \u0442\u043e\u043b\u044c\u043a\u043e \u0438\u043c\u0435\u043d\u043e\u0432\u0430\u043d\u043d\u044b\u0439"},{"location":"development/localization/#chinese","title":"Chinese","text":""},{"location":"development/localization/#style-guide_1","title":"Style guide","text":"<ul> <li>\u98ce\u683c\u8c03\u6574\u53c2\u8003\u4e86\u8be5\u9879\u76ee sparanoid/chinese-copywriting-guidelines\uff0c\u8be5\u9879\u76ee\u63d0\u4f9b\u4e86\u4e00\u4e9b\u4e2d\u6587\u6587\u6848\u6392\u7248\u7684\u57fa\u672c\u89c4\u8303\uff0c\u4ee5\u4fbf\u63d0\u9ad8\u6587\u6848\u7684\u53ef\u8bfb\u6027\u3002</li> <li>\u901a\u5e38\u5728\u4e2d\u82f1\u6587\u6df7\u6392\u65f6\uff0c\u4e2d\u6587\u4e0e\u82f1\u6587\u4e4b\u95f4\u9700\u8981\u6dfb\u52a0\u7a7a\u683c\uff0c\u4ee5\u589e\u52a0\u53ef\u8bfb\u6027\u3002\u5728\u539f\u59cb\u7ffb\u8bd1\u4e2d\uff0c\u8fd9\u4e00\u89c4\u5219\u4ec5\u5728\u90e8\u5206\u6587\u672c\u4e2d\u5f97\u5230\u4e86\u9075\u5faa\uff0c\u56e0\u6b64\u5bf9\u5176\u8fdb\u884c\u4e86\u8c03\u6574\u3002\u5e76\u4e14\u901a\u8fc7\u5f15\u53f7\u62ec\u8d77\u7684\u6587\u672c\u548c\u53c2\u6570\u6587\u672c\u4e5f\u9075\u5faa\u8fd9\u4e00\u89c4\u5219\uff0c\u5728\u4e24\u4fa7\u6dfb\u52a0\u7a7a\u683c\u4ee5\u5f3a\u8c03\u5176\u5185\u5bb9\u3002</li> <li>\u539f\u59cb\u7ffb\u8bd1\u4e2d\u5b58\u5728\u4e2d\u6587\u7684\u5168\u89d2\u6807\u70b9\u7b26\u53f7\u548c\u82f1\u6587\u7684\u534a\u89d2\u6807\u70b9\u7b26\u53f7\u6df7\u7528\uff0c\u540c\u65f6\u5b58\u5728\u4f7f\u7528\u4e0d\u6b63\u786e\uff0c\u56e0\u6b64\u5bf9\u5176\u8fdb\u884c\u8c03\u6574\u3002\u8003\u8651\u5230\u6587\u672c\u683c\u5f0f\u5316\u65f6\u90e8\u5206\u6761\u76ee\u4f1a\u51fa\u73b0\u786c\u7f16\u7801\u7684\u76f4\u5f15\u53f7 <code>\"</code>\uff0c\u56e0\u6b64\u5c06\u6240\u6709\u683c\u5f0f\u5316\u53c2\u6570\u7684\u53cc\u5f15\u53f7\u7edf\u4e00\u4e3a\u82f1\u6587\u76f4\u53cc\u5f15\u53f7\uff0c\u4ee3\u7801\u7b26\u53f7\u7edf\u4e00\u4e3a\u53cd\u5f15\u53f7\u3002\u9664\u5f15\u53f7\u4ee5\u5916\u7684\u975e\u82f1\u6587\u4e4b\u95f4\u7684\u6807\u70b9\u5168\u90e8\u7edf\u4e00\u4e3a\u5168\u89d2\u6807\u70b9\u7b26\u53f7\u3002</li> <li>\u6ca1\u5fc5\u8981\u5b8c\u6574\u9075\u5faa\u539f\u6587\uff0c\u4ee5\u7b26\u5408\u4e2d\u6587\u7406\u89e3\u4e60\u60ef\u548c\u8bed\u6cd5\u4e3a\u4e3b\u3002</li> <li>\u82e5\u7ffb\u8bd1\u540e\u6587\u672c\u5e76\u4e0d\u662f\u5e38\u89c1\u5199\u6cd5\uff0c\u53ef\u6dfb\u52a0\u62ec\u53f7\u5e76\u6807\u6ce8\u539f\u6587\u3002</li> </ul>"},{"location":"development/localization/#_2","title":"\u7528\u8bcd\u8c03\u6574","text":"\u539f\u8bcd (Word) \u539f\u59cb\u7ffb\u8bd1 (Original) \u8c03\u6574\u7ffb\u8bd1 (Adjusted) \u9519\u8bd1\u7c7b\u578b (Type of Mistranslation) annotation \uff08\u7c7b\u578b\uff09\u6279\u6ce8 \uff08\u7c7b\u578b\uff09\u6ce8\u89e3 \u4e0e\u6587\u6863\u4e0d\u4e00\u81f4/Inconsistent\u00a0with Python docs Any \u4efb\u610f Any \u8bed\u4e49\u9519\u8bef/Wrong meaning Unknown \u672a\u77e5 \u672a\u77e5 \u56fa\u5b9a\u672f\u8bed/Terminology argument \u53c2\u6570 \u53c2\u6570/\u5b9e\u53c2 \u8bed\u4e49\u9519\u8bef/Wrong meaning import \u5bfc\u5165/Import \u5bfc\u5165 \u8bed\u4e49\u9519\u8bef/Wrong meaning parameter \u53c2\u6570 \u53c2\u6570/\u5f62\u53c2 \u8bed\u4e49\u9519\u8bef/Wrong meaning True true/True True \u8bed\u4e49\u9519\u8bef/Wrong meaning assign \u5206\u914d \u8d4b\u503c \u8bcd\u4e49\u9519\u8bef/Wrong meaning comprehension \u7406\u89e3 \u63a8\u5bfc\u5f0f \u8bcd\u4e49\u9519\u8bef/Wrong meaning follow \u9075\u5faa \u5728\u3002.. \u4e4b\u540e \u8bcd\u4e49\u9519\u8bef/Wrong meaning implementation/unimplemented \uff08\u672a\uff09\u5b9e\u65bd/\u5b9e\u884c\uff08\u7684\uff09 \uff08\u672a\uff09\u5b9e\u73b0\uff08\u7684\uff09 \u8bcd\u4e49\u9519\u8bef/Wrong meaning obscure \u906e\u76d6/\u9690\u853d \u8986\u76d6 \u8bcd\u4e49\u9519\u8bef/Wrong meaning"},{"location":"development/upstream/","title":"how we keep up-to-date with upstream","text":"<p>every time pyright releases a new version, we merge its release tag into basedpyright. each basedpyright version is based on a release version of pyright.</p> <p>you can check which pyright version basedpyright is based on by running <code>basedpyright --version</code>:</p> <pre><code>basedpyright 1.14.0\nbased on pyright 1.1.372\n</code></pre> <p>we try to update basedpyright as soon as a new pyright version is released. we typically release on the same day that pyright does.</p>"},{"location":"getting_started/features/","title":"Features","text":""},{"location":"getting_started/features/#pyright-features","title":"Pyright Features","text":""},{"location":"getting_started/features/#speed","title":"Speed","text":"<p>Pyright is a fast type checker meant for large Python source bases. It can run in a \u201cwatch\u201d mode and performs fast incremental updates when files are modified.</p>"},{"location":"getting_started/features/#configurability","title":"Configurability","text":"<p>Pyright supports configuration files that provide granular control over settings. Different \u201cexecution environments\u201d can be associated with subdirectories within a source base. Each environment can specify different module search paths, python language versions, and platform targets.</p>"},{"location":"getting_started/features/#type-checking-features","title":"Type Checking Features","text":"<ul> <li>PEP 484 type hints including generics</li> <li>PEP 487 simpler customization of class creation</li> <li>PEP 526 syntax for variable annotations</li> <li>PEP 544 structural subtyping</li> <li>PEP 561 distributing and packaging type information</li> <li>PEP 563 postponed evaluation of annotations</li> <li>PEP 570 position-only parameters</li> <li>PEP 585 type hinting generics in standard collections</li> <li>PEP 586 literal types</li> <li>PEP 589 typed dictionaries</li> <li>PEP 591 final qualifier</li> <li>PEP 593 flexible variable annotations</li> <li>PEP 604 complementary syntax for unions</li> <li>PEP 612 parameter specification variables</li> <li>PEP 613 explicit type aliases</li> <li>PEP 635 structural pattern matching</li> <li>PEP 646 variadic generics</li> <li>PEP 647 user-defined type guards</li> <li>PEP 655 required typed dictionary items</li> <li>PEP 673 Self type</li> <li>PEP 675 arbitrary literal strings</li> <li>PEP 681 dataclass transform</li> <li>PEP 692 TypedDict for kwargs typing</li> <li>PEP 695 type parameter syntax</li> <li>PEP 696 type defaults for TypeVarLikes</li> <li>PEP 698 override decorator for static typing</li> <li>PEP 702 marking deprecations</li> <li>PEP 705 TypedDict: read-only items</li> <li>PEP 712 (draft) converter parameter on dataclasses.field</li> <li>PEP 728 (draft) TypedDict with typed extra items</li> <li>PEP 742 narrowing types with TypeIs</li> <li>Type inference for function return values, instance variables, class variables, and globals</li> <li>Type guards that understand conditional code flow constructs like if/else statements</li> </ul>"},{"location":"getting_started/features/#language-server-support","title":"Language Server Support","text":"<p>Pyright ships as both a command-line tool and a language server that provides many powerful features that help improve programming efficiency.</p> <ul> <li>Intelligent type completion of keywords, symbols, and import names appears when editing</li> <li>Import statements are automatically inserted when necessary for type completions</li> <li>Signature completion tips help when filling in arguments for a call</li> <li>Hover over symbols to provide type information and doc strings</li> <li>Find Definitions to quickly go to the location of a symbol\u2019s definition</li> <li>Find References to find all references to a symbol within a code base</li> <li>Rename Symbol to rename all references to a symbol within a code base</li> <li>Find Symbols within the current document or within the entire workspace</li> <li>View call hierarchy information \u2014 calls made within a function and places where a function is called</li> <li>Organize Imports command for automatically ordering imports according to PEP8 rules</li> <li>Type stub generation for third-party libraries</li> </ul>"},{"location":"getting_started/features/#built-in-type-stubs","title":"Built-in Type Stubs","text":"<p>Pyright includes a recent copy of the stdlib type stubs from Typeshed. It can be configured to use another (perhaps more recent or modified) copy of the Typeshed type stubs. Of course, it also works with custom type stub files that are part of your project.</p>"},{"location":"getting_started/features/#limitations","title":"Limitations","text":"<p>Pyright provides support for Python 3.0 and newer. There are no plans to support older versions.</p>"},{"location":"getting_started/getting-started/","title":"Getting started","text":""},{"location":"getting_started/getting-started/#getting-started-with-type-checking","title":"Getting Started with Type Checking","text":"<p>A static type checker like Pyright can add incremental value to your source code as more type information is provided.</p> <p>Here is a typical progression:</p>"},{"location":"getting_started/getting-started/#1-initial-type-checking","title":"1. Initial Type Checking","text":"<ul> <li>Install pyright (either the language server or command-line tool).</li> <li>Write a minimal <code>pyrightconfig.json</code> that defines <code>include</code> entries. Place the config file in your project\u2019s top-level directory and commit it to your repo. Alternatively, you can add a pyright section to a <code>pyproject.toml</code> file. For additional details and a sample config file, refer to this documentation.</li> <li>Run pyright over your source base with the default settings. Fix any errors and warnings that it emits. Optionally disable specific diagnostic rules if they are generating too many errors. They can be re-enabled at a later time.</li> </ul>"},{"location":"getting_started/getting-started/#2-types-for-imported-libraries","title":"2. Types For Imported Libraries","text":"<ul> <li>Update dependent libraries to recent versions. Many popular libraries have recently added inlined types, which eliminates the need to install or create type stubs.</li> <li>Enable the <code>reportMissingTypeStubs</code> setting in the config file and add (minimal) type stub files for the imported files. You may wish to create a stubs directory within your code base \u2014 a location for all of your custom type stub files. Configure the \u201cstubPath\u201d\u00a0config entry to refer to this directory.</li> <li>Look for type stubs for the packages you use. Some package authors opt to ship stubs as a separate companion package named that has \u201c-stubs\u201d appended to the name of the original package.</li> <li>In cases where type stubs do not yet exist for a package you are using, consider creating a custom type stub that defines the portion of the interface that your source code consumes. Check in your custom type stub files and configure pyright to run as part of your continuous integration (CI) environment to keep the project \u201ctype clean\u201d.</li> </ul>"},{"location":"getting_started/getting-started/#3-incremental-typing","title":"3. Incremental Typing","text":"<ul> <li>Incrementally add type annotations to your code files. The annotations that provide most value are on function input parameters, instance variables, and return parameters (in that order).</li> <li>Enable stricter type checking options like \"reportUnknownParameterType\", and \"reportUntypedFunctionDecorator\".</li> </ul>"},{"location":"getting_started/getting-started/#4-strict-typing","title":"4. Strict Typing","text":"<ul> <li>On a file-by-file basis, enable all type checking options by adding the comment <code># pyright: strict</code> somewhere in the file.</li> <li>Optionally add entire subdirectories to the <code>strict</code> config entry to indicate that all files within those subdirectories should be strictly typed.</li> </ul>"},{"location":"getting_started/type-concepts/","title":"Type concepts","text":""},{"location":"getting_started/type-concepts/#static-typing-the-basics","title":"Static Typing: The Basics","text":"<p>Getting started with static type checking in Python is easy, but it\u2019s important to understand a few simple concepts. In addition to the documentation below, you may also find the community-maintained Static Typing Documentation to be of use. That site also includes the official Specification for the Python Type System.</p>"},{"location":"getting_started/type-concepts/#type-declarations","title":"Type Declarations","text":"<p>When you add a type annotation to a variable or a parameter in Python, you are declaring that the symbol will be assigned values that are compatible with that type. You can think of type annotations as a powerful way to comment your code. Unlike text-based comments, these comments are readable by both humans and enforceable by type checkers.</p> <p>If a variable or parameter has no type annotation, Pyright will assume that any value can be assigned to it.</p>"},{"location":"getting_started/type-concepts/#type-assignability","title":"Type Assignability","text":"<p>When your code assigns a value to a symbol (in an assignment expression) or a parameter (in a call expression), the type checker first determines the type of the value being assigned. It then determines whether the target has a declared type. If so, it verifies that the type of the value is assignable to the declared type.</p> <p>Let\u2019s look at a few simple examples. In this first example, the declared type of <code>a</code> is <code>float</code>, and it is assigned a value that is an <code>int</code>. This is permitted because <code>int</code> is assignable to <code>float</code>.</p> <pre><code>a: float = 3\n</code></pre> <p>In this example, the declared type of <code>b</code> is <code>int</code>, and it is assigned a value that is a <code>float</code>. This is flagged as an error because <code>float</code> is not assignable to <code>int</code>.</p> <pre><code>b: int = 3.4  # Error\n</code></pre> <p>This example introduces the notion of a Union type, which specifies that a value can be one of several distinct types. A union type can be expressed using the <code>|</code> operator to combine individual types.</p> <pre><code>c: int | float = 3.4\nc = 5\nc = a\nc = b\nc = None  # Error\nc = \"\"  # Error\n</code></pre> <p>This example introduces the Optional type, which is the same as a union with <code>None</code>.</p> <pre><code>d: Optional[int] = 4\nd = b\nd = None\nd = \"\"  # Error\n</code></pre> <p>Those examples are straightforward. Let\u2019s look at one that is less intuitive. In this example, the declared type of <code>f</code> is <code>list[int | None]</code>. A value of type <code>list[int]</code> is being assigned to <code>f</code>. As we saw above, <code>int</code> is assignable to <code>int | None</code>. You might therefore assume that <code>list[int]</code> is assignable to <code>list[int | None]</code>, but this is an incorrect assumption. To understand why, we need to understand generic types and type arguments.</p> <pre><code>e: list[int] = [3, 4]\nf: list[int | None] = e  # Error\n</code></pre>"},{"location":"getting_started/type-concepts/#generic-types","title":"Generic Types","text":"<p>A generic type is a class that is able to handle different types of inputs. For example, the <code>list</code> class is generic because it is able to operate on different types of elements. The type <code>list</code> by itself does not specify what is contained within the list. Its element type must be specified as a type argument using the indexing (square bracket) syntax in Python. For example, <code>list[int]</code> denotes a list that contains only <code>int</code> elements whereas <code>list[int | float]</code> denotes a list that contains a mixture of int and float elements.</p> <p>We noted above that <code>list[int]</code> is not assignable to <code>list[int | None]</code>. Why is this the case? Consider the following example.</p> <pre><code>my_list_1: list[int] = [1, 2, 3]\nmy_list_2: list[int | None] = my_list_1  # Error\nmy_list_2.append(None)\n\nfor elem in my_list_1:\n    print(elem + 1)  # Runtime exception\n</code></pre> <p>The code is appending the value <code>None</code> to the list <code>my_list_2</code>, but <code>my_list_2</code> refers to the same object as <code>my_list_1</code>, which has a declared type of <code>list[int]</code>. The code has violated the type of <code>my_list_1</code> because it no longer contains only <code>int</code> elements. This broken assumption results in a runtime exception. The type checker detects this broken assumption when the code attempts to assign <code>my_list_1</code> to <code>my_list_2</code>.</p> <p><code>list</code> is an example of a mutable container type. It is mutable in that code is allowed to modify its contents \u2014 for example, add or remove items. The type parameters for mutable container types are typically marked as invariant, which means that an exact type match is enforced. This is why the type checker reports an error when attempting to assign a <code>list[int]</code> to a variable of type <code>list[int | None]</code>.</p> <p>Most mutable container types also have immutable counterparts.</p> Mutable Type Immutable Type list Sequence dict Mapping set Container n/a tuple <p>Switching from a mutable container type to a corresponding immutable container type is often an effective way to resolve type errors relating to assignability. Let\u2019s modify the example above by changing the type annotation for <code>my_list_2</code>.</p> <pre><code>my_list_1: list[int] = [1, 2, 3]\nmy_list_2: Sequence[int | None] = my_list_1  # No longer an error\n</code></pre> <p>The type error on the second line has now gone away.</p> <p>For more details about generic types, type parameters, and invariance, refer to PEP 483 \u2014 The Theory of Type Hints.</p>"},{"location":"getting_started/type-concepts/#debugging-types","title":"Debugging Types","text":"<p>When you want to know the type that the type checker has evaluated for an expression, you can use the special <code>reveal_type()</code> function:</p> <pre><code>x = 1\nreveal_type(x)  # Type of \"x\" is \"Literal[1]\"\n</code></pre> <p>This function is always available and does not need to be imported. When you use Pyright within an IDE, you can also simply hover over an identifier to see its evaluated type.</p>"},{"location":"installation/command-line-and-language-server/","title":"Command-line &amp; language server","text":""},{"location":"installation/command-line-and-language-server/#pypi-package-recommended","title":"pypi package (recommended)","text":"<p>unlike pyright, the basedpyright CLI &amp; LSP are available as a pypi package instead of an npm package.</p> <p>this makes it far more convenient for python developers to use, since there's no need to install any additional tools. just install it normally via your package manager of choice:</p> uvpdmpip <p>add it to your project's dev dependencies (recommended):</p> <pre><code>uv add --dev basedpyright\n</code></pre> <p>or just install it:</p> <pre><code>uv pip install basedpyright\n</code></pre> <pre><code>pdm add --dev basedpyright\n</code></pre> <pre><code>pip install basedpyright\n</code></pre>"},{"location":"installation/command-line-and-language-server/#other-installation-methods","title":"other installation methods","text":"<p>the basedpyright CLI &amp; language server is also available outside of pypi:</p> homebrewnixOS <pre><code>brew install basedpyright\n</code></pre> <p>see here</p>"},{"location":"installation/command-line-and-language-server/#usage","title":"usage","text":"<p>once installed, the <code>basedpyright</code> and <code>basedpyright-langserver</code> scripts will be available in your python environment. when running basedpyright via the command line, use the <code>basedpyright</code> command:</p> <pre><code>basedpyright --help\n</code></pre> <p>for instructions on how to use <code>basedpyright-langserver</code>, see the IDE-specific instructions.</p>"},{"location":"installation/ides/","title":"IDEs","text":"<p>Info</p> <p>note that most of these editor plugins require the language server to be installed.</p>"},{"location":"installation/ides/#vscode-vscodium","title":"VSCode / VSCodium","text":""},{"location":"installation/ides/#vscode","title":"VSCode","text":"<p>install the extension from the vscode extension marketplace</p> using basedpyright with pylance (not recommended) <p>unless you depend on any pylance-exclusive features that haven't yet been re-implemented in basedpyright, it's recommended to disable/uninstall the pylance extension.</p> <p>if you do want to continue using pylance, all of the options and commands in basedpyright have been renamed to avoid any conflicts with the pylance extension, and the restriction that prevents both extensions from being enabled at the same time has been removed.</p> <p>if basedpyright detects that pylance is installed, you will see a popup prompting you to choose whether to uninstall pylance or fix your settings to allow both extensions to work without overlapping functionality:</p> <p></p> <p>clicking \"Fix settings &amp; keep both extensions\" will set the following settings for you automatically:</p> .vscode/settings.json<pre><code>{\n    // disable pylance's type checking and only use its language server\n    \"python.analysis.typeCheckingMode\": \"off\",\n\n    // disable basedpyright's language server and only use its type checking\n    \"basedpyright.disableLanguageServices\": true\n}\n</code></pre>"},{"location":"installation/ides/#vscodium","title":"VSCodium","text":"<p>install the extension from the open VSX registry</p>"},{"location":"installation/ides/#usage","title":"usage","text":"<p>the basedpyright extension will automatically look for the pypi package in your python environment.</p> <p>if you're adding basedpyright as a development dependency in your project, we recommend adding it to the recommended extensions list in your workspace to prompt others working on your repo to install it:</p> .vscode/extensions.json<pre><code>{\n    \"recommendations\": [\"detachhead.basedpyright\"]\n}\n</code></pre>"},{"location":"installation/ides/#neovim","title":"Neovim","text":"<p>You need to install the LSP client addapter plugin, nvim-lspconfig, for setting up the LSP for the editor. These configurations are for launching the LSP server, as well as for being able to give launching parameters at the same time.</p> <p>To install the necessary sever command, for the LSP server itself, use the pypi package installation method (as mentioned previously in this section). Or if already using Mason.nvim, follow their instructions for installing their packages. The latter approach allows you to have the version of BasedPyright maintained and upgraded by Mason project.</p>"},{"location":"installation/ides/#setting-up-neovim","title":"Setting-up Neovim","text":"<p>BasedPyright is available through the <code>nvim-lspconfig</code> adapter for native Neovim's LSP support.</p> <p>After having both, the client-side plugin and the LSP server command installed, simply add this settings to your Neovim's settings:</p> <pre><code>local lspconfig = require(\"lspconfig\")\nlspconfig.basedpyright.setup{}\n</code></pre> <p>Further info for this LSP server options for <code>nvim-lspconfig</code> are available on their docs, linked above.</p>"},{"location":"installation/ides/#vim","title":"Vim","text":"<p>Vim users can install coc-basedpyright, the BasedPyright extension for coc.nvim.</p>"},{"location":"installation/ides/#sublime-text","title":"Sublime Text","text":"<p>Sublime text users can install both LSP and LSP-basedpyright via Package Control.</p>"},{"location":"installation/ides/#emacs","title":"Emacs","text":"<p>Emacs users have 3 options:</p>"},{"location":"installation/ides/#lsp-bridge","title":"lsp-bridge","text":"<p>basedpyright is the default language server for python in lsp-bridge, so no additional configuration is required.</p>"},{"location":"installation/ides/#eglot","title":"eglot","text":"<p>add the following to your emacs config:</p> <pre><code>(add-to-list 'eglot-server-programs\n             '((python-mode python-ts-mode)\n               \"basedpyright-langserver\" \"--stdio\"))\n</code></pre>"},{"location":"installation/ides/#lsp-mode","title":"lsp-mode","text":"<p>with lsp-pyright (any commit after: <code>0c0d72a</code>, update the package if you encounter errors), add the following to your emacs config:</p> <pre><code>(setq lsp-pyright-langserver-command \"basedpyright\")\n</code></pre>"},{"location":"installation/ides/#pycharm","title":"PyCharm","text":"<p>install the Pyright plugin</p> <p>configure it to use basedpyright by specifying the path to the <code>basedpyright-langserver</code> executable and set \"Running mode\" to \"LSP4IJ\":</p> <p></p>"},{"location":"installation/ides/#helix","title":"Helix","text":"<p>Install the LSP server itself, using the pypi package installation method (as mentioned previously in this section). Then add the following to your languages file:</p> <pre><code>[[language]]\nname = \"python\"\nlanguage-servers = [ \"basedpyright\" ]\n</code></pre> <p>You can verify the active configuration by running <code>hx --health python</code></p>"},{"location":"installation/pre-commit%20hook/","title":"pre-commit hook","text":".pre-commit-config.yaml<pre><code>repos:\n    - repo: https://github.com/DetachHead/basedpyright-pre-commit-mirror\n      rev: v1.13.0 # or whatever the latest version is at the time\n      hooks:\n          - id: basedpyright\n</code></pre> <p>Warning</p> <p>pre-commit is not recommended. for more information, see here</p>"},{"location":"usage/builtins/","title":"Builtins","text":""},{"location":"usage/builtins/#extending-builtins","title":"Extending Builtins","text":"<p>The Python interpreter implicitly adds a set of symbols that are available within every module even though they are not explicitly imported. These so-called \u201cbuilt in\u201d symbols include commonly-used types and functions such as \u201clist\u201d, \u201cdict\u201d, \u201cint\u201d, \u201cfloat\u201d, \u201cmin\u201d, and \u201clen\u201d.</p> <p>Pyright gains knowledge of which types are included in \u201cbuiltins\u201d scope through the type stub file <code>builtins.pyi</code>. This stub file comes from the typeshed github repo and is bundled with pyright, along with type stubs that describe other stdlib modules.</p> <p>Some Python environments are customized to include additional builtins symbols. If you are using such an environment, you may want to tell Pyright about these additional symbols that are available at runtime. To do so, you can add a local type stub file called <code>__builtins__.pyi</code>. This file can be placed at the root of your project directory or at the root of the subdirectory specified in the <code>stubPath</code> setting (which is named <code>typings</code> by default).</p>"},{"location":"usage/commands/","title":"VS Code Commands","text":"<p>basedyright offers the following commands, which can be invoked from VS Code\u2019s \u201cCommand Palette\u201d, which can be accessed from the View menu or by pressing Cmd-Shift-P.</p>"},{"location":"usage/commands/#organize-imports","title":"Organize Imports","text":"<p>This command reorders all imports found in the global (module-level) scope of the source file. As recommended in PEP8, imports are grouped into three groups, each separated by an empty line. The first group includes all built-in modules, the second group includes all third-party modules, and the third group includes all local modules.</p> <p>Within each group, imports are sorted alphabetically. And within each \u201cfrom X import Y\u201d statement, the imported symbols are sorted alphabetically. Pyright also rewraps any imports that don't fit within a single line, switching to multi-line formatting.</p> <p>Note</p> <p>we recommend using ruff to organize your imports instead, because pyright does not provide a way to validate that imports are sorted via the CLI.</p>"},{"location":"usage/commands/#restart-server","title":"Restart Server","text":"<p>This command forces the type checker to discard all of its cached type information and restart analysis. It is useful in cases where new type stubs or libraries have been installed.</p>"},{"location":"usage/commands/#write-new-errors-to-baseline","title":"Write new errors to baseline","text":"<p>writes any new errors to the baseline file. the language server will automatically update it on-save if errors are removed from a file and no new errors were added. for more information about when to use this command, see here.</p>"},{"location":"usage/import-resolution/","title":"Import resolution","text":""},{"location":"usage/import-resolution/#import-resolution","title":"Import Resolution","text":""},{"location":"usage/import-resolution/#resolution-order","title":"Resolution Order","text":"<p>If the import is relative (the module name starts with one or more dots), it resolves the import relative to the path of the importing source file.</p> <p>For absolute (non-relative) imports, Pyright employs the following resolution order:</p> <ol> <li> <p>Try to resolve using the stubPath as defined in the <code>stubPath</code> config entry or the <code>basedpyright.analysis.stubPath</code> setting.</p> </li> <li> <p>Try to resolve using code within the workspace.</p> <ul> <li> <p>Try to resolve relative to the root directory of the execution environment. If no execution environments are specified in the config file, use the root of the workspace. For more information about execution environments, refer to the configuration documentation.</p> </li> <li> <p>Try to resolve using any of the extra paths defined for the execution environment in the config file. If no execution environment applies, use the <code>basedpyright.analysis.extraPaths</code> setting. Extra paths are searched in the order in which they are provided in the config file or setting.</p> </li> <li> <p>If no execution environment is configured, try to resolve using the local directory <code>src</code>. It is common for Python projects to place local source files within a directory of this name.</p> </li> </ul> </li> <li> <p>Try to resolve using stubs or inlined types found within installed packages. Pyright uses the configured Python environment to determine whether a package has been installed. For more details about how to configure your Python environment for Pyright, see below. If a Python environment is configured, Pyright looks in the <code>lib/site-packages</code>, <code>Lib/site-packages</code>, or <code>python*/site-packages</code> subdirectory. If no site-packages directory can be found, Pyright attempts to run the configured Python interpreter and ask it for its search paths. If no Python environment is configured, Pyright will use the default Python interpreter by invoking <code>python</code>.</p> <ul> <li>For a given package, try to resolve first using a stub package. Stub packages, as defined in PEP 561, are named the same as the original package but with \u201c-stubs\u201d appended.</li> <li>Try to resolve using an inline stub, a \u201c.pyi\u201d file that ships within the package.</li> <li>If the package contains a \u201cpy.typed\u201d file as described in PEP 561, use inlined type annotations provided in \u201c.py\u201d files within the package.</li> <li>If the <code>basedpyright.analysis.useLibraryCodeForTypes</code> setting is set to true, try to resolve using the library implementation (\u201c.py\u201d file). Some \u201c.py\u201d files may contain partial or complete type annotations. Pyright will use type annotations that are provided and do its best to infer any missing type information.</li> </ul> </li> <li> <p>Try to resolve using a stdlib typeshed stub. If the <code>typeshedPath</code> is configured, use this instead of the typeshed stubs that are packaged with Pyright. This allows for the use of a newer or a patched version of the typeshed stdlib stubs.</p> </li> <li> <p>Try to resolve using a third-party typeshed stub. If the <code>typeshedPath</code> is configured, use this instead of the typeshed stubs that are packaged with Pyright. This allows for the use of a newer or a patched version of the typeshed third-party stubs.</p> </li> <li> <p>For an absolute import, if all of the above attempts fail, attempt to import a module from the same directory as the importing file and parent directories that are also children of the root workspace. This accommodates cases where it is assumed that a Python script will be executed from one of these subdirectories rather than from the root directory.</p> </li> </ol>"},{"location":"usage/import-resolution/#configuring-your-python-environment","title":"Configuring Your Python Environment","text":"<p>Pyright does not require a Python environment to be configured if all imports can be resolved using local files and type stubs. If a Python environment is configured, it will attempt to use the packages installed in the <code>site-packages</code> subdirectory during import resolution.</p> <p>Pyright uses the following mechanisms (in priority order) to determine which Python environment to use:</p> <ol> <li> <p>If a <code>venv</code> name is specified along with a <code>python.venvPath</code> setting (or a <code>--venvpath</code> command-line argument), it appends the venv name to the specified venv path. This mechanism is not recommended for most users because it is less robust than the next two options because it relies on pyright\u2019s internal logic to determine the import resolution paths based on the virtual environment directories and files. The other two mechanisms (2 and 3 below) use the configured python interpreter to determine the import resolution paths (the value of <code>sys.path</code>).</p> </li> <li> <p>Use the <code>python.pythonPath</code> setting. This setting is defined by the VS Code Python extension and can be configured using the Python extension\u2019s environment picker interface. More recent versions of the Python extension no longer store the selected Python environment in the <code>python.pythonPath</code> setting and instead use a storage mechanism that is private to the extension. Pyright is able to access this through an API exposed by the Python extension.</p> </li> <li> <p>As a fallback, use the default Python environment (i.e. the one that is invoked when typing <code>python</code> in the shell).</p> </li> </ol>"},{"location":"usage/import-resolution/#editable-installs","title":"Editable installs","text":"<p>If you want to use static analysis tools with an editable install, you should configure the editable install to use <code>.pth</code> files that contain file paths rather than executable lines (prefixed with <code>import</code>) that install import hooks. See your package manager\u2019s documentation for details on how to do this. We have provided some basic information for common package managers below.</p> <p>Import hooks can provide an editable installation that is a more accurate representation of your real installation. However, because resolving module locations using an import hook requires executing Python code, they are not usable by Pyright and other static analysis tools. Therefore, if your editable install is configured to use import hooks, Pyright will be unable to find the corresponding source files.</p>"},{"location":"usage/import-resolution/#pip-setuptools","title":"pip / setuptools","text":"<p><code>pip</code> (<code>setuptools</code>) supports two ways to avoid import hooks: - compat mode - strict mode</p>"},{"location":"usage/import-resolution/#hatch-hatchling","title":"Hatch / Hatchling","text":"<p>Hatchling uses path-based <code>.pth</code> files by default. It will only use import hooks if you set <code>dev-mode-exact</code> to <code>true</code>.</p>"},{"location":"usage/import-resolution/#pdm","title":"PDM","text":"<p>PDM uses path-based <code>.pth</code> files by default. It will only use import hooks if you set <code>editable-backend</code> to <code>\"editables\"</code>.</p>"},{"location":"usage/import-resolution/#debugging-import-resolution-problems","title":"Debugging Import Resolution Problems","text":"<p>The import resolution mechanisms in Python are complicated, and Pyright offers many configuration options. If you are encountering problems with import resolution, Pyright provides additional logging that may help you identify the cause. To enable verbose logging, pass <code>--verbose</code> as a command-line argument or add the following entry to the config file <code>\"verboseOutput\": true</code>. If you are using the Pyright VS Code extension, the additional logging will appear in the Output tab (select \u201cPyright\u201d from the menu). Please include this verbose logging when reporting import resolution bugs.</p>"},{"location":"usage/import-statements/","title":"Import statements","text":""},{"location":"usage/import-statements/#import-statements","title":"Import Statements","text":""},{"location":"usage/import-statements/#loader-side-effects","title":"Loader Side Effects","text":"<p>An import statement instructs the Python import loader to perform several operations. For example, the statement <code>from a.b import Foo as Bar</code> causes the following steps to be performed at runtime: 1. Load and execute module <code>a</code> if it hasn\u2019t previously been loaded. Cache a reference to a. 2. Load and execute submodule <code>b</code> if it hasn\u2019t previously been loaded. 3. Store a reference to submodule <code>b</code> to the variable <code>b</code> within module <code>a</code>\u2019s namespace. 4. Look up attribute <code>Foo</code> within module <code>b</code>. 5. Assign the value of attribute <code>Foo</code> to a local variable called <code>Bar</code>.</p> <p>If another source file were to subsequently execute the statement <code>import a</code>, it would observe <code>b</code> in the namespace of <code>a</code> as a side effect of step 3 in the the earlier import operation. Relying on such side effects leads to fragile code because a change in execution ordering or a modification to one module can break code in another module. Reliance on such side effects is therefore considered a bug by Pyright, which intentionally does not attempt to model such side effects.</p>"},{"location":"usage/import-statements/#implicit-module-loads","title":"Implicit Module Loads","text":"<p>Pyright models two loader side effects that are considered safe and are commonly used in Python code.</p> <ol> <li> <p>If an import statement targets a multi-part module name and does not use an alias, all modules within the multi-part module name are assumed to be loaded. For example, the statement <code>import a.b.c</code> is treated as though it is three back-to-back import statements: <code>import a</code>, <code>import a.b</code> and <code>import a.b.c</code>. This allows for subsequent use of all symbols in <code>a</code>, <code>a.b</code>, and <code>a.b.c</code>. If an alias is used (e.g. <code>import a.b.c as abc</code>), this is assumed to load only module <code>c</code>. A subsequent <code>import a</code> would not provide access to <code>a.b</code> or <code>a.b.c</code>.</p> </li> <li> <p>If an <code>__init__.py</code> file includes an import statement of the form <code>from .a import b</code>, the local variable <code>a</code> is assigned a reference to submodule <code>a</code>. This statement form is treated as though it is two back-to-back import statements: <code>from . import a</code> followed by <code>from .a import b</code>.</p> </li> </ol>"},{"location":"usage/import-statements/#unsupported-loader-side-effects","title":"Unsupported Loader Side Effects","text":"<p>All other module loader side effects are intentionally not modeled by Pyright and should not be relied upon in code. Examples include:</p> <ul> <li> <p>If one module contains the statement <code>import a.b</code> and a second module includes <code>import a</code>, the second module should not rely on the fact that <code>a.b</code> is now accessible as a side effect of the first module\u2019s import.</p> </li> <li> <p>If a module contains the statement <code>import a.b</code> in the global scope and a function that includes the statement <code>import a</code> or <code>import a.c</code>, the function should not assume that it can access <code>a.b</code>. This assumption might or might not be safe depending on execution order.</p> </li> <li> <p>If a module contains the statements <code>import a.b as foo</code> and <code>import a</code>, code within that module should not assume that it can access <code>a.b</code>. Such an assumption might be safe depending on the relative order of the statements and the order in which they are executed, but it leads to fragile code.</p> </li> </ul>"},{"location":"usage/mypy-comparison/","title":"Mypy comparison","text":""},{"location":"usage/mypy-comparison/#differences-between-pyright-and-mypy","title":"Differences Between Pyright and Mypy","text":""},{"location":"usage/mypy-comparison/#what-is-mypy","title":"What is Mypy?","text":"<p>Mypy is the \u201cOG\u201d in the world of Python type checkers. It was started by Jukka Lehtosalo in 2012 with contributions from Guido van Rossum, Ivan Levkivskyi, and many others over the years. For a detailed history, refer to this documentation. The code for mypy can be found in this github project.</p>"},{"location":"usage/mypy-comparison/#why-does-pyrights-behavior-differ-from-mypys","title":"Why Does Pyright\u2019s Behavior Differ from Mypy\u2019s?","text":"<p>Mypy served as a reference implementation of PEP 484, which defines standard behaviors for Python static typing. Although PEP 484 spells out many type checking behaviors, it intentionally leaves many other behaviors undefined. This approach has allowed different type checkers to innovate and differentiate.</p> <p>Pyright generally adheres to the official Python typing specification, which incorporates and builds upon PEP 484 and other typing-related PEPs. The typing spec is accompanied by an ever-expanding suite of conformance tests. For the latest conformance test results for pyright, mypy and other type checkers, refer to this page.</p> <p>For behaviors that are not explicitly spelled out in the typing spec, pyright generally tries to adhere to mypy\u2019s behavior unless there is a compelling justification for deviating. This document discusses these differences and provides the reasoning behind each design choice.</p>"},{"location":"usage/mypy-comparison/#design-goals","title":"Design Goals","text":"<p>Pyright was designed with performance in mind. It is not unusual for pyright to be 3x to 5x faster than mypy when type checking large code bases. Some of its design decisions were motivated by this goal.</p> <p>Pyright was also designed to be used as the foundation for a Python language server. Language servers provide interactive programming features such as completion suggestions, function signature help, type information on hover, semantic-aware search, semantic-aware renaming, semantic token coloring, refactoring tools, etc. For a good user experience, these features require highly responsive type evaluation performance during interactive code modification. They also require type evaluation to work on code that is incomplete and contains syntax errors.</p> <p>To achieve these design goals, pyright is implemented as a \u201clazy\u201d or \u201cjust-in-time\u201d type evaluator. Rather than analyzing all code in a module from top to bottom, it is able to evaluate the type of an arbitrary identifier anywhere within a module. If the type of that identifier depends on the types of other expressions or symbols, pyright recursively evaluates those in turn until it has enough information to determine the type of the target identifier. By comparison, mypy uses a more traditional multi-pass architecture where semantic analysis is performed multiple times on a module from the top to the bottom until all types converge.</p> <p>Pyright implements its own parser, which recovers gracefully from syntax errors and continues parsing the remainder of the source file. By comparison, mypy uses the parser built in to the Python interpreter, and it does not support recovery after a syntax error. This also means that when you run mypy on an older version of Python, it cannot support newer language features that require grammar changes.</p>"},{"location":"usage/mypy-comparison/#type-checking-unannotated-code","title":"Type Checking Unannotated Code","text":"<p>By default, pyright performs type checking for all code regardless of whether it contains type annotations. This is important for language server features. It is also important for catching bugs in code that is unannotated.</p> <p>By default, mypy skips all functions or methods that do not have type annotations. This is a common source of confusion for mypy users who are surprised when type violations in unannotated functions go unreported. If the option <code>--check-untyped-defs</code> is enabled, mypy performs type checking for all functions and methods.</p>"},{"location":"usage/mypy-comparison/#inferred-return-types","title":"Inferred Return Types","text":"<p>If a function or method lacks a return type annotation, pyright infers the return type from <code>return</code> and <code>yield</code> statements within the function\u2019s body (including the implied <code>return None</code> at the end of the function body). This is important for supporting completion suggestions. It also improves type checking coverage and eliminates the need for developers to needlessly supply return type annotations for trivial return types.</p> <p>By comparison, mypy never infers return types and assumes that functions without a return type annotation have a return type of <code>Any</code>. This was an intentional design decision by mypy developers and is explained in this thread.</p>"},{"location":"usage/mypy-comparison/#unions-vs-joins","title":"Unions vs Joins","text":"<p>When merging two types during code flow analysis or widening types during constraint solving, pyright always uses a union operation. Mypy typically (but not always) uses a \u201cjoin\u201d operation, which merges types by finding a common supertype. The use of joins discards valuable type information and leads to many false positive errors that are well documented within the mypy issue tracker.</p> <pre><code>def func1(val: object):\n    if isinstance(val, str):\n        pass\n    elif isinstance(val, int):\n        pass\n    else:\n        return\n    reveal_type(val) # mypy: object, pyright: str | int\n\ndef func2(condition: bool, val1: str, val2: int):\n    x = val1 if condition else val2\n    reveal_type(x) # mypy: object, pyright: str | int\n\n    y = val1 or val2\n    # In this case, mypy uses a union instead of a join\n    reveal_type(y) # mypy: str | int, pyright: str | int\n</code></pre>"},{"location":"usage/mypy-comparison/#variable-type-declarations","title":"Variable Type Declarations","text":"<p>Pyright treats variable type annotations as type declarations. If a variable is not annotated, pyright allows any value to be assigned to that variable, and its type is inferred to be the union of all assigned types.</p> <p>Mypy\u2019s behavior for variables depends on whether the <code>--allow-redefinition</code> is specified. If redefinitions are not allowed, then mypy typically treats the first assignment (the one with the smallest line number) as though it is an implicit type declaration.</p> <pre><code>def func1(condition: bool):\n    if condition:\n        x = 3 # Mypy treats this as an implicit type declaration\n    else:\n        x = \"\" # Mypy treats this as an error because `x` is implicitly declared as `int`\n\ndef func2(condition: bool):\n    x = None # Mypy provides some exceptions; this is not considered an implicit type declaration\n\n    if condition:\n        x = \"\" # This is not considered an error\n\ndef func3(condition: bool):\n    x = [] # Mypy doesn't treat this as a declaration\n\n    if condition:\n        x = [1, 2, 3] # The type of `x` is declared as `list[int]`\n</code></pre> <p>Pyright\u2019s behavior is more consistent, is conceptually simpler and more natural for Python developers, leads to fewer false positives, and eliminates the need for many otherwise-necessary variable type annotations.</p>"},{"location":"usage/mypy-comparison/#class-and-instance-variable-inference","title":"Class and Instance Variable Inference","text":"<p>Pyright handles instance and class variables consistently with local variables. If a type annotation is provided for an instance or class variable (either within the class or one of its base classes), pyright treats this as a type declaration and enforces it accordingly. If a class implementation does not provide a type annotation for an instance or class variable and its base classes likewise do not provide a type annotation, the variable\u2019s type is inferred from all assignments within the class implementation.</p> <pre><code>class A:\n    def method1(self) -&gt; None:\n        self.x = 1\n\n    def method2(self) -&gt; None:\n        self.x = \"\" # Mypy treats this as an error because `x` is implicitly declared as `int`\n\na = A()\nreveal_type(a.x) # pyright: int | str\n\na.x = \"\" # Pyright allows this because the type of `x` is `int | str`\na.x = 3.0 # Pyright treats this as an error because the type of `x` is `int | str`\n</code></pre>"},{"location":"usage/mypy-comparison/#class-and-instance-variable-enforcement","title":"Class and Instance Variable Enforcement","text":"<p>Pyright distinguishes between \u201cpure class variables\u201d, \u201cregular class variables\u201d, and \u201cpure instance variable\u201d. For a detailed explanation, refer to this documentation.</p> <p>Mypy does not distinguish between class variables and instance variables in all cases. This is a known issue.</p> <pre><code>class A:\n    x: int = 0 # Regular class variable\n    y: ClassVar[int] = 0 # Pure class variable\n\n    def __init__(self):\n        self.z = 0 # Pure instance variable\n\nprint(A.x)\nprint(A.y)\nprint(A.z) # pyright: error, mypy: no error\n</code></pre>"},{"location":"usage/mypy-comparison/#assignment-based-type-narrowing","title":"Assignment-based Type Narrowing","text":"<p>Pyright applies type narrowing for variable assignments. This is done regardless of whether the assignment statement includes a variable type annotation. Mypy skips assignment-based type narrowing when the target variable includes a type annotation. The consensus of the typing community is that mypy\u2019s behavior here is inconsistent, and there are plans to eliminate this inconsistency.</p> <pre><code>v1: Sequence[int]\nv1 = [1, 2, 3]\nreveal_type(v1) # mypy and pyright both reveal `list[int]`\n\nv2: Sequence[int] = [1, 2, 3]\nreveal_type(v2) # mypy reveals `Sequence[int]` rather than `list[int]`\n</code></pre>"},{"location":"usage/mypy-comparison/#type-guards","title":"Type Guards","text":"<p>Pyright supports several built-in type guards that mypy does not currently support. For a full list of type guard expression forms supported by pyright, refer to this documentation.</p> <p>The following expression forms are not currently supported by mypy as type guards: * <code>x == L</code> and <code>x != L</code> (where L is an expression with a literal type) * <code>x in y</code> or <code>x not in y</code> (where y is instance of list, set, frozenset, deque, tuple, dict, defaultdict, or OrderedDict) * <code>bool(x)</code> (where x is any expression that is statically verifiable to be truthy or falsey in all cases)</p>"},{"location":"usage/mypy-comparison/#aliased-conditional-expressions","title":"Aliased Conditional Expressions","text":"<p>Pyright supports the aliasing of conditional expressions used for type guards. Mypy does not currently support this, but it is a frequently-requested feature.</p>"},{"location":"usage/mypy-comparison/#narrowing-any","title":"Narrowing Any","text":"<p>Pyright never narrows <code>Any</code> when performing type narrowing for assignments. Mypy is inconsistent about when it applies type narrowing to <code>Any</code> type arguments.</p> <pre><code>b: list[Any]\n\nb = [1, 2, 3]\nreveal_type(b) # pyright: list[Any], mypy: list[Any]\n\nc = [1, 2, 3]\nb = c\nreveal_type(b) # pyright: list[Any], mypy: list[int]\n</code></pre>"},{"location":"usage/mypy-comparison/#inference-of-list-set-and-dict-expressions","title":"Inference of List, Set, and Dict Expressions","text":"<p>Pyright\u2019s inference rules for list, set and dict expressions differ from mypy\u2019s when values with heterogeneous types are used. Mypy uses a join operator to combine the types. Pyright uses either an <code>Unknown</code> or a union depending on configuration settings. A join operator often produces a type that is not what was intended, and this leads to false positive errors.</p> <pre><code>x = [1, 3.4, \"\"]\nreveal_type(x) # mypy: list[object], pyright: list[Unknown] or list[int | float | str]\n</code></pre> <p>For these mutable container types, pyright does not retain literal types when inferring the container type. Mypy is inconsistent, sometimes retaining literal types and sometimes not.</p> <pre><code>def func(one: Literal[1]):\n    reveal_type(one) # Literal[1]\n    reveal_type([one]) # pyright: list[int], mypy: list[Literal[1]]\n\n    reveal_type(1) # Literal[1]\n    reveal_type([1]) # pyright: list[int], mypy: list[int]\n</code></pre>"},{"location":"usage/mypy-comparison/#inference-of-tuple-expressions","title":"Inference of Tuple Expressions","text":"<p>Pyright\u2019s inference rules for tuple expressions differ from mypy\u2019s when tuple entries contain literals. Pyright retains these literal types, but mypy widens the types to their non-literal type. Pyright retains the literal types in this case because tuples are immutable, and more precise (narrower) types are almost always beneficial in this situation.</p> <pre><code>x = (1, \"stop\")\nreveal_type(x[1]) # pyright: Literal[\"stop\"], mypy: str\n\ny: Literal[\"stop\", \"go\"] = x[1] # mypy: type error\n</code></pre>"},{"location":"usage/mypy-comparison/#assignment-based-narrowing-for-literals","title":"Assignment-Based Narrowing for Literals","text":"<p>When assigning a literal value to a variable, pyright narrows the type to reflect the literal. Mypy does not. Pyright retains the literal types in this case because more precise (narrower) types are typically beneficial and have little or no downside.</p> <pre><code>x: str | None\nx = 'a'\nreveal_type(x) # pyright: Literal['a'], mypy: str\n</code></pre> <p>Pyright also supports \u201cliteral math\u201d for simple operations involving literals.</p> <pre><code>def func1(a: Literal[1, 2], b: Literal[2, 3]):\n    c = a + b\n    reveal_type(c) # Literal[3, 4, 5]\n\ndef func2():\n    c = \"hi\" + \" there\"\n    reveal_type(c) # Literal['hi there']\n</code></pre>"},{"location":"usage/mypy-comparison/#type-narrowing-for-asymmetric-descriptors","title":"Type Narrowing for Asymmetric Descriptors","text":"<p>When pyright evaluates a write to a class variable that contains a descriptor object (including properties), it normally applies assignment-based type narrowing. However, when the descriptor is asymmetric \u2014\u00a0that is, its \u201cgetter\u201d type is different from its \u201csetter\u201d type, pyright refrains from applying assignment-based type narrowing. For a full discussion of this, refer to this issue. Mypy has not yet implemented the agreed-upon behavior, so its type narrowing behavior may differ from pyright\u2019s in this case.</p>"},{"location":"usage/mypy-comparison/#parameter-type-inference","title":"Parameter Type Inference","text":"<p>Mypy infers the type of <code>self</code> and <code>cls</code> parameters in methods but otherwise does not infer any parameter types.</p> <p>Pyright implements several parameter type inference techniques that improve type checking and language service features in the absence of explicit parameter type annotations. For details, refer to this documentation.</p>"},{"location":"usage/mypy-comparison/#constructor-calls","title":"Constructor Calls","text":"<p>When pyright evaluates a call to a constructor, it attempts to follow the runtime behavior as closely as possible. At runtime, when a constructor is called, it invokes the <code>__call__</code> method of the metaclass. Most classes use <code>type</code> as their metaclass. (Even when a different metaclasses is used, it typically does not override <code>type.__call__</code>.) The <code>type.__call__</code> method calls the <code>__new__</code> method for the class and passes all of the arguments (both positional and keyword) that were passed to the constructor call. If the <code>__new__</code> method returns an instance of the class (or a child class), <code>type.__call__</code> then calls the <code>__init__</code> method on the class. Pyright follows this same flow for evaluating the type of a constructor call. If a custom metaclass is present, pyright evaluates its <code>__call__</code> method to determine whether it returns an instance of the class. If not, it assumes that the metaclass has custom behavior that overrides <code>type.__call__</code>. Likewise, if a class provides a <code>__new__</code> method that returns a type other than the class being constructed (or a child class thereof), it assumes that <code>__init__</code> will not be called.</p> <p>By comparison, mypy first evaluates the <code>__init__</code> method if present, and it ignores the annotated return type of the <code>__new__</code> method.</p>"},{"location":"usage/mypy-comparison/#none-return-type","title":"<code>None</code> Return Type","text":"<p>If the return type of a function is declared as <code>None</code>, an attempt to call that function and consume the returned value is flagged as an error by mypy. The justification is that this is a common source of bugs.</p> <p>Pyright does not special-case <code>None</code> in this manner because there are legitimate use cases, and in our experience, this class of bug is rare.</p>"},{"location":"usage/mypy-comparison/#constraint-solver-behaviors","title":"Constraint Solver Behaviors","text":"<p>When evaluating a call expression that invokes a generic class constructor or a generic function, a type checker performs a process called \u201cconstraint solving\u201d to solve the type variables found within the target function signature. The solved type variables are then applied to the return type of that function to determine the final type of the call expression. This process is called \u201cconstraint solving\u201d because it takes into account various constraints that are specified for each type variable. These constraints include variance rules and type variable bounds.</p> <p>Many aspects of constraint solving are unspecified in PEP 484. This includes behaviors around literals, whether to use unions or joins to widen types, and how to handle cases where multiple types could satisfy all type constraints.</p>"},{"location":"usage/mypy-comparison/#constraint-solver-literals","title":"Constraint Solver: Literals","text":"<p>Pyright\u2019s constraint solver retains literal types only when they are required to satisfy constraints. In other cases, it widens the type to a non-literal type. Mypy is inconsistent in its handling of literal types.</p> <pre><code>T = TypeVar(\"T\")\ndef identity(x: T) -&gt; T:\n    return x\n\ndef func(one: Literal[1]):\n    reveal_type(one) # Literal[1]\n    v1 = identity(one)\n    reveal_type(v1) # pyright: int, mypy: Literal[1]\n\n    reveal_type(1) # Literal[1]\n    v2 = identity(1)\n    reveal_type(v2) # pyright: int, mypy: int\n</code></pre>"},{"location":"usage/mypy-comparison/#constraint-solver-type-widening","title":"Constraint Solver: Type Widening","text":"<p>As mentioned previously, pyright always uses unions rather than joins. Mypy typically uses joins. This applies to type widening during the constraint solving process.</p> <pre><code>T = TypeVar(\"T\")\ndef func(val1: T, val2: T) -&gt; T:\n    ...\n\nreveal_type(func(\"\", 1)) # mypy: object, pyright: str | int\n</code></pre>"},{"location":"usage/mypy-comparison/#constraint-solver-ambiguous-solution-scoring","title":"Constraint Solver: Ambiguous Solution Scoring","text":"<p>In cases where more than one solution is possible for a type variable, both pyright and mypy employ various heuristics to pick the \u201cbest\u201d solution. These heuristics are complex and difficult to document in their fullness. Pyright\u2019s general strategy is to return the \u201csimplest\u201d type that meets the constraints.</p> <p>Consider the expression <code>make_list(x)</code> in the example below. The type constraints for <code>T</code> could be satisfied with either <code>int</code> or <code>list[int]</code>, but it\u2019s much more likely that the developer intended the former (simpler) solution. Pyright calculates all possible solutions and \u201cscores\u201d them according to complexity, then picks the type with the best score. In rare cases, there can be two results with the same score, in which chase pyright arbitrarily picks one as the winner.</p> <p>Mypy produces errors with this sample.</p> <pre><code>T = TypeVar(\"T\")\n\ndef make_list(x: T | Iterable[T]) -&gt; list[T]:\n    return list(x) if isinstance(x, Iterable) else [x]\n\ndef func2(x: list[int], y: list[str] | int):\n    v1 = make_list(x)\n    reveal_type(v1) # pyright: \"list[int]\" (\"list[list[T]]\" is also a valid answer)\n\n    v2 = make_list(y)\n    reveal_type(v2) # pyright: \"list[int | str]\" (\"list[list[str] | int]\" is also a valid answer)\n</code></pre>"},{"location":"usage/mypy-comparison/#value-constrained-type-variables","title":"Value-Constrained Type Variables","text":"<p>When mypy analyzes a class or function that has in-scope value-constrained TypeVars, it analyzes the class or function multiple times, once for each constraint. This can produce multiple errors.</p> <pre><code>T = TypeVar(\"T\", list[Any], set[Any])\n\ndef func(a: AnyStr, b: T):\n    reveal_type(a) # Mypy reveals 2 different types (\"str\" and \"bytes\"), pyright reveals \"AnyStr\"\n    return a + b # Mypy reports 4 errors\n</code></pre> <p>Pyright cannot use the same multi-pass technique as mypy in this case. It needs to produce a single type for any given identifier to support language server features. Pyright instead uses a mechanism called conditional types. This approach allows pyright to handle some value-constrained TypeVar use cases that mypy cannot, but there are conversely other use cases that mypy can handle and pyright cannot.</p>"},{"location":"usage/mypy-comparison/#unknown-type-and-strict-mode","title":"\u201cUnknown\u201d Type and Strict Mode","text":"<p>Pyright differentiates between explicit and implicit forms of <code>Any</code>. The implicit form is referred to as <code>Unknown</code>. For example, if a parameter is annotated as <code>list[Any]</code>, that is a use of an explicit <code>Any</code>, but if a parameter is annotated as <code>list</code>, that is an implicit <code>Any</code>, so pyright refers to this type as <code>list[Unknown]</code>. Pyright implements several checks that are enabled in \u201cstrict\u201d type-checking modes that report the use of an <code>Unknown</code> type. Such uses can mask type errors.</p> <p>Mypy does not track the difference between explicit and implicit <code>Any</code> types, but it supports various checks that report the use of values whose type is <code>Any</code>: <code>--warn-return-any</code> and <code>--disallow-any-*</code>. For details, refer to this documentation.</p> <p>Pyright\u2019s approach gives developers more control. It provides a way to be explicit about <code>Any</code> where that is the intent. When an <code>Any</code> is implicitly produced due to an missing type argument or some other condition that produces an <code>Any</code> within the type checker logic, the developer is alerted to that condition.</p>"},{"location":"usage/mypy-comparison/#overload-resolution","title":"Overload Resolution","text":"<p>Overload resolution rules are under-specified in PEP 484. Pyright and mypy apply similar rules, but there are inevitably cases where different results will be produced. For full documentation of pyright\u2019s overload behaviors, refer to this documentation.</p> <p>One known difference is in the handling of ambiguous overloads due to <code>Any</code> argument types where one return type is the supertype of all other return types. In this case, pyright evaluates the resulting return type as the supertype, but mypy evaluates the return type as <code>Any</code>. Pyright\u2019s behavior here tries to preserve as much type information as possible, which is important for completion suggestions.</p> <pre><code>@overload\ndef func1(x: int) -&gt; int: ...\n\n@overload\ndef func1(x: str) -&gt; float: ...\n\ndef func2(val: Any):\n    reveal_type(func1(val)) # mypy: Any, pyright: float\n</code></pre>"},{"location":"usage/mypy-comparison/#import-statements","title":"Import Statements","text":"<p>Pyright intentionally does not model implicit side effects of the Python import loading mechanism. In general, such side effects cannot be modeled statically because they depend on execution order. Dependency on such side effects leads to fragile code, so pyright treats these as errors. For more details, refer to this documentation.</p> <p>Mypy models side effects of the import loader that are potentially unsafe.</p> <pre><code>import http\n\ndef func():\n    import http.cookies\n\n# The next line raises an exception at runtime\nx = http.cookies  # mypy allows, pyright flags as error\n</code></pre>"},{"location":"usage/mypy-comparison/#ellipsis-in-function-body","title":"Ellipsis in Function Body","text":"<p>If Pyright encounters a function body whose implementation is <code>...</code>, it does not enforce the return type annotation. The <code>...</code> semantically means \u201cthis is a code placeholder\u201d \u2014\u00a0a convention established in type stubs, protocol definitions, and elsewhere.</p> <p>Mypy treats <code>...</code> function bodies as though they are executable and enforces the return type annotation. This was a recent change in mypy \u2014\u00a0made long after Pyright established a different behavior. Prior to mypy\u2019s recent change, it did not enforce return types for function bodies consisting of either <code>...</code> or <code>pass</code>. Now it enforces both.</p>"},{"location":"usage/mypy-comparison/#circular-references","title":"Circular References","text":"<p>Because mypy is a multi-pass analyzer, it is able to deal with certain forms of circular references that pyright cannot handle. Here are several examples of circularities that mypy resolves without errors but pyright does not.</p> <ol> <li>A class declaration that references a metaclass whose declaration depends on the class.</li> </ol> <pre><code>T = TypeVar(\"T\")\nclass MetaA(type, Generic[T]): ...\nclass A(metaclass=MetaA[\"A\"]): ...\n</code></pre> <ol> <li>A class declaration that uses a TypeVar whose bound or constraint depends on the class.</li> </ol> <pre><code>T = TypeVar(\"T\", bound=\"A\")\nclass A(Generic[T]): ...\n</code></pre> <ol> <li>A class that is decorated with a class decorator that uses the class in the decorator\u2019s own signature.</li> </ol> <pre><code>def my_decorator(x: Callable[..., \"A\"]) -&gt; Callable[..., \"A\"]:\n    return x\n\n@my_decorator\nclass A: ...\n</code></pre>"},{"location":"usage/mypy-comparison/#class-decorator-evaluation","title":"Class Decorator Evaluation","text":"<p>Pyright honors class decorators. Mypy largely ignores them. See this issue for details.</p>"},{"location":"usage/mypy-comparison/#support-for-type-comments","title":"Support for Type Comments","text":"<p>Versions of Python prior to 3.0 did not have a dedicated syntax for supplying type annotations. Annotations therefore needed to be supplied using \u201ctype comments\u201d of the form <code># type: &lt;annotation&gt;</code>. Python 3.6 added the ability to supply type annotations for variables. </p> <p>Mypy has full support for type comments. Pyright supports type comments only in locations where there is a way to provide an annotation using modern syntax. Pyright was written to assume Python 3.5 and newer, so support for older versions was not a priority.</p> <pre><code># The following type comment is supported by\n# mypy but is rejected by pyright.\nx, y = (3, 4) # type: (float, float)\n\n# Using Python syntax from Python 3.6, this\n# would be annotated as follows:\nx: float\ny: float\nx, y = (3, 4)\n</code></pre>"},{"location":"usage/mypy-comparison/#plugins","title":"Plugins","text":"<p>Mypy supports a plug-in mechanism, whereas pyright does not. Mypy plugins allow developers to extend mypy\u2019s capabilities to accommodate libraries that rely on behaviors that cannot be described using the standard type checking mechanisms.</p> <p>Pyright maintainers have made the decision not to support plug-ins because of their many downsides: discoverability, maintainability, cost of development for the plug-in author, cost of maintenance for the plug-in object model and API, security, performance (especially latency \u2014\u00a0which is critical for language servers), and robustness. Instead, we have taken the approach of working with the typing community and library authors to extend the type system so it can accommodate more use cases. An example of this is PEP 681, which introduced <code>dataclass_transform</code>.</p>"},{"location":"usage/type-concepts-advanced/","title":"Type concepts advanced","text":""},{"location":"usage/type-concepts-advanced/#static-typing-advanced-topics","title":"Static Typing: Advanced Topics","text":""},{"location":"usage/type-concepts-advanced/#type-narrowing","title":"Type Narrowing","text":"<p>Pyright uses a technique called \u201ctype narrowing\u201d to track the type of an expression based on code flow. Consider the following code:</p> <pre><code>val_str: str = \"hi\"\nval_int: int = 3\n\ndef func(val: float | str | complex, test: bool):\n    reveal_type(val) # int | str | complex\n\n    val = val_int # Type is narrowed to int\n    reveal_type(val) # int\n\n    if test:\n        val = val_str # Type is narrowed to str\n        reveal_type(val) # str\n\n    reveal_type(val) # int | str\n\n    if isinstance(val, int):\n        reveal_type(val) # int\n        print(val)\n    else:\n        reveal_type(val) # str\n        print(val)\n</code></pre> <p>At the start of this function, the type checker knows nothing about <code>val</code> other than that its declared type is <code>float | str | complex</code>. Then it is assigned a value that has a known type of <code>int</code>. This is a legal assignment because <code>int</code> is considered a subclass of <code>float</code>. At the point in the code immediately after the assignment, the type checker knows that the type of <code>val</code> is an <code>int</code>. This is a \u201cnarrower\u201d (more specific) type than <code>float | str | complex</code>. Type narrowing is applied whenever a symbol is assigned a new value.</p> <p>Another assignment occurs several lines further down, this time within a conditional block. The symbol <code>val</code> is assigned a value known to be of type <code>str</code>, so the narrowed type of <code>val</code> is now <code>str</code>. Once the code flow of the conditional block merges with the main body of the function, the narrowed type of <code>val</code> becomes <code>int | str</code> because the type checker cannot statically predict whether the conditional block will be executed at runtime.</p> <p>Another way that types can be narrowed is through the use of conditional code flow statements like <code>if</code>, <code>while</code>, and <code>assert</code>. Type narrowing applies to the block of code that is \u201cguarded\u201d by that condition, so type narrowing in this context is sometimes referred to as a \u201ctype guard\u201d. For example, if you see the conditional statement <code>if x is None:</code>, the code within that <code>if</code> statement can assume that <code>x</code> contains <code>None</code>. Within the code sample above, we see an example of a type guard involving a call to <code>isinstance</code>. The type checker knows that <code>isinstance(val, int)</code> will return True only in the case where <code>val</code> contains a value of type <code>int</code>, not type <code>str</code>. So the code within the <code>if</code> block can assume that <code>val</code> contains a value of type <code>int</code>, and the code within the <code>else</code> block can assume that <code>val</code> contains a value of type <code>str</code>. This demonstrates how a type (in this case <code>int | str</code>) can be narrowed in both a positive (<code>if</code>) and negative (<code>else</code>) test.</p> <p>The following expression forms support type narrowing:</p> <ul> <li><code>&lt;ident&gt;</code> (where <code>&lt;ident&gt;</code> is an identifier)</li> <li><code>&lt;expr&gt;.&lt;member&gt;</code> (member access expression where <code>&lt;expr&gt;</code> is a supported expression form)</li> <li><code>&lt;expr&gt;[&lt;int&gt;]</code> (subscript expression where <code>&lt;int&gt;</code> is a non-negative integer)</li> <li><code>&lt;expr&gt;[&lt;str&gt;]</code> (subscript expression where <code>&lt;str&gt;</code> is a string literal)</li> </ul> <p>Examples of expressions that support type narrowing:</p> <ul> <li><code>my_var</code></li> <li><code>employee.name</code></li> <li><code>a.foo.next</code></li> <li><code>args[3]</code></li> <li><code>kwargs[\"bar\"]</code></li> <li><code>a.b.c[3][\"x\"].d</code></li> </ul>"},{"location":"usage/type-concepts-advanced/#type-guards","title":"Type Guards","text":"<p>In addition to assignment-based type narrowing, Pyright supports the following type guards.</p> <ul> <li><code>x is None</code> and <code>x is not None</code></li> <li><code>x == None</code> and <code>x != None</code></li> <li><code>x is ...</code> and <code>x is not ...</code> (where <code>...</code> is an ellipsis token)</li> <li><code>x == ...</code> and <code>x != ...</code> (where <code>...</code> is an ellipsis token)</li> <li><code>type(x) is T</code> and <code>type(x) is not T</code></li> <li><code>type(x) == T</code> and <code>type(x) != T</code></li> <li><code>x is E</code> and <code>x is not E</code> (where E is a literal enum or bool)</li> <li><code>x is C</code> and <code>x is not C</code> (where C is a class)</li> <li><code>x == L</code> and <code>x != L</code> (where L is an expression that evaluates to a literal type)</li> <li><code>x.y is None</code> and <code>x.y is not None</code> (where x is a type that is distinguished by a field with a None)</li> <li><code>x.y is E</code> and <code>x.y is not E</code> (where E is a literal enum or bool and x is a type that is distinguished by a field with a literal type)</li> <li><code>x.y == LN</code> and <code>x.y != LN</code> (where LN is a literal expression or <code>None</code> and x is a type that is distinguished by a field or property with a literal type)</li> <li><code>x[K] == V</code>, <code>x[K] != V</code>, <code>x[K] is V</code>, and <code>x[K] is not V</code> (where K and V are literal expressions and x is a type that is distinguished by a TypedDict field with a literal type)</li> <li><code>x[I] == V</code> and <code>x[I] != V</code> (where I and V are literal expressions and x is a known-length tuple that is distinguished by the index indicated by I)</li> <li><code>x[I] is B</code> and <code>x[I] is not B</code> (where I is a literal expression, B is a <code>bool</code> or enum literal, and x is a known-length tuple that is distinguished by the index indicated by I)</li> <li><code>x[I] is None</code> and <code>x[I] is not None</code> (where I is a literal expression and x is a known-length tuple that is distinguished by the index indicated by I)</li> <li><code>len(x) == L</code>, <code>len(x) != L</code>, <code>len(x) &lt; L</code>, etc. (where x is tuple and L is an expression that evaluates to an int literal type)</li> <li><code>x in y</code> or <code>x not in y</code> (where y is instance of list, set, frozenset, deque, tuple, dict, defaultdict, or OrderedDict)</li> <li><code>S in D</code> and <code>S not in D</code> (where S is a string literal and D is a TypedDict)</li> <li><code>isinstance(x, T)</code> (where T is a type or a tuple of types)</li> <li><code>issubclass(x, T)</code> (where T is a type or a tuple of types)</li> <li><code>f(x)</code> (where f is a user-defined type guard as defined in PEP 647 or PEP 742)</li> <li><code>bool(x)</code> (where x is any expression that is statically verifiable to be truthy or falsey in all cases)</li> <li><code>x</code> (where x is any expression that is statically verifiable to be truthy or falsey in all cases)</li> </ul> <p>Expressions supported for type guards include simple names, member access chains (e.g. <code>a.b.c.d</code>), the unary <code>not</code> operator, the binary <code>and</code> and <code>or</code> operators, subscripts that are integer literals (e.g. <code>a[2]</code> or <code>a[-1]</code>), and call expressions. Other operators (such as arithmetic operators or other subscripts) are not supported.</p> <p>Some type guards are able to narrow in both the positive and negative cases. Positive cases are used in <code>if</code> statements, and negative cases are used in <code>else</code> statements. (Positive and negative cases are flipped if the type guard expression is preceded by a <code>not</code> operator.) In some cases, the type can be narrowed only in the positive or negative case but not both. Consider the following examples:</p> <pre><code>class Foo: pass\nclass Bar: pass\n\ndef func1(val: Foo | Bar):\n    if isinstance(val, Bar):\n        reveal_type(val) # Bar\n    else:\n        reveal_type(val) # Foo\n\ndef func2(val: float | None):\n    if val:\n        reveal_type(val) # float\n    else:\n        reveal_type(val) # float | None\n</code></pre> <p>In the example of <code>func1</code>, the type was narrowed in both the positive and negative cases. In the example of <code>func2</code>, the type was narrowed only the positive case because the type of <code>val</code> might be either <code>float</code> (specifically, a value of 0.0) or <code>None</code> in the negative case.</p>"},{"location":"usage/type-concepts-advanced/#aliased-conditional-expression","title":"Aliased Conditional Expression","text":"<p>Pyright also supports a type guard expression <code>c</code>, where <code>c</code> is an identifier that refers to a local variable that is assigned one of the above supported type guard expression forms. These are called \u201caliased conditional expressions\u201d. Examples include <code>c = a is not None</code> and <code>c = isinstance(a, str)</code>. When \u201cc\u201d is used within a conditional check, it can be used to narrow the type of expression <code>a</code>.</p> <p>This pattern is supported only in cases where <code>c</code> is a local variable within a module or function scope and is assigned a value only once. It is also limited to cases where expression <code>a</code> is a simple identifier (as opposed to a member access expression or subscript expression), is local to the function or module scope, and is assigned only once within the scope. Unary <code>not</code> operators are allowed for expression <code>a</code>, but binary <code>and</code> and <code>or</code> are not.</p> <pre><code>def func1(x: str | None):\n    is_str = x is not None\n\n    if is_str:\n        reveal_type(x) # str\n    else:\n        reveal_type(x) # None\n</code></pre> <pre><code>def func2(val: str | bytes):\n    is_str = not isinstance(val, bytes)\n\n    if not is_str:\n        reveal_type(val) # bytes\n    else:\n        reveal_type(val) # str\n</code></pre> <pre><code>def func3(x: list[str | None]) -&gt; str:\n    is_str = x[0] is not None\n\n    if is_str:\n        # This technique doesn't work for subscript expressions,\n        # so x[0] is not narrowed in this case.\n        reveal_type(x[0]) # str | None\n</code></pre> <pre><code>def func4(x: str | None):\n    is_str = x is not None\n\n    if is_str:\n        # This technique doesn't work in cases where the target\n        # expression is assigned elsewhere. Here `x` is assigned\n        # elsewhere in the function, so its type is not narrowed\n        # in this case.\n        reveal_type(x) # str | None\n\n    x = \"\"\n</code></pre>"},{"location":"usage/type-concepts-advanced/#narrowing-for-implied-else","title":"Narrowing for Implied Else","text":"<p>When an \u201cif\u201d or \u201celif\u201d clause is used without a corresponding \u201celse\u201d, Pyright will generally assume that the code can \u201cfall through\u201d without executing the \u201cif\u201d or \u201celif\u201d block. However, there are cases where the analyzer can determine that a fall-through is not possible because the \u201cif\u201d or \u201celif\u201d is guaranteed to be executed based on type analysis.</p> <pre><code>def func1(x: int):\n    if x == 1 or x == 2:\n        y = True\n\n    print(y) # Error: \"y\" is possibly unbound\n\ndef func2(x: Literal[1, 2]):\n    if x == 1 or x == 2:\n        y = True\n\n    print(y) # No error\n</code></pre> <p>This can be especially useful when exhausting all members in an enum or types in a union.</p> <pre><code>from enum import Enum\n\nclass Color(Enum):\n    RED = 1\n    BLUE = 2\n    GREEN = 3\n\ndef func3(color: Color) -&gt; str:\n    if color == Color.RED or color == Color.BLUE:\n        return \"yes\"\n    elif color == Color.GREEN:\n        return \"no\"\n\ndef func4(value: str | int) -&gt; str:\n    if isinstance(value, str):\n        return \"received a str\"\n    elif isinstance(value, int):\n        return \"received an int\"\n</code></pre> <p>If you later added another color to the <code>Color</code> enumeration above (e.g. <code>YELLOW = 4</code>), Pyright would detect that <code>func3</code> no longer exhausts all members of the enumeration and possibly returns <code>None</code>, which violates the declared return type. Likewise, if you modify the type of the <code>value</code> parameter in <code>func4</code> to expand the union, a similar error will be produced.</p> <p>This \u201cnarrowing for implied else\u201d technique works for all narrowing expressions listed above with the exception of simple falsey/truthy statements and type guards. It is also limited to simple names and doesn\u2019t work with member access or index expressions, and it requires that the name has a declared type (an explicit type annotation). These limitations are imposed because this functionality would otherwise have significant impact on analysis performance.</p>"},{"location":"usage/type-concepts-advanced/#narrowing-any","title":"Narrowing Any","text":"<p>In general, the type <code>Any</code> is not narrowed. The only exceptions to this rule are the built-in <code>isinstance</code> and <code>issubclass</code> type guards, class pattern matching in \u201cmatch\u201d statements, and user-defined type guards. In all other cases, <code>Any</code> is left as is, even for assignments.</p> <pre><code>a: Any = 3\nreveal_type(a) # Any\n\na = \"hi\"\nreveal_type(a) # Any\n</code></pre> <p>The same applies to <code>Any</code> when it is used as a type argument.</p> <pre><code>b: Iterable[Any] = [1, 2, 3]\nreveal_type(b) # list[Any]\n\nc: Iterable[str] = [\"\"]\nb = c\nreveal_type(b) # list[Any]\n</code></pre>"},{"location":"usage/type-concepts-advanced/#narrowing-for-captured-variables","title":"Narrowing for Captured Variables","text":"<p>If a variable\u2019s type is narrowed in an outer scope and the variable is subsequently captured by an inner-scoped function or lambda, Pyright retains the narrowed type if it can determine that the value of the captured variable is not modified on any code path after the inner-scope function or lambda is defined and is not modified in another scope via a <code>nonlocal</code> or <code>global</code> binding.</p> <pre><code>def func(val: int | None):\n    if val is not None:\n\n        def inner_1() -&gt; None:\n            reveal_type(val)  # int\n            print(val + 1)\n\n        inner_2 = lambda: reveal_type(val) + 1  # int\n\n        inner_1()\n        inner_2()\n</code></pre>"},{"location":"usage/type-concepts-advanced/#value-constrained-type-variables","title":"Value-Constrained Type Variables","text":"<p>When a TypeVar is defined, it can be constrained to two or more types (values).</p> <pre><code># Example of unconstrained type variable\n_T = TypeVar(\"_T\")\n\n# Example of value-constrained type variables\n_StrOrFloat = TypeVar(\"_StrOrFloat\", str, float)\n</code></pre> <p>When a value-constrained TypeVar appears more than once within a function signature, the type provided for all instances of the TypeVar must be consistent.</p> <pre><code>def add(a: _StrOrFloat, b: _StrOrFloat) -&gt; _StrOrFloat:\n    return a + b\n\n# The arguments for `a` and `b` are both `str`\nv1 = add(\"hi\", \"there\")\nreveal_type(v1) # str\n\n# The arguments for `a` and `b` are both `float`\nv2 = add(1.3, 2.4)\nreveal_type(v2) # float\n\n# The arguments for `a` and `b` are inconsistent types\nv3 = add(1.3, \"hi\") # Error\n</code></pre>"},{"location":"usage/type-concepts-advanced/#conditional-types-and-type-variables","title":"Conditional Types and Type Variables","text":"<p>When checking the implementation of a function that uses type variables in its signature, the type checker must verify that type consistency is guaranteed. Consider the following example, where the input parameter and return type are both annotated with a type variable. The type checker must verify that if a caller passes an argument of type <code>str</code>, then all code paths must return a <code>str</code>. Likewise, if a caller passes an argument of type <code>float</code>, all code paths must return a <code>float</code>.</p> <pre><code>def add_one(value: _StrOrFloat) -&gt; _StrOrFloat:\n    if isinstance(value, str):\n        sum = value + \"1\"\n    else:\n        sum = value + 1\n\n    reveal_type(sum)  # str* | float*\n    return sum\n</code></pre> <p>The type of variable <code>sum</code> is reported with a star (<code>*</code>). This indicates that internally the type checker is tracking the type as a \u201cconditional\u201d type. In this particular example, it indicates that <code>sum</code> is a <code>str</code> type if the parameter <code>value</code> is a <code>str</code> but is a <code>float</code> if <code>value</code> is a <code>float</code>. By tracking these conditional types, the type checker can verify that the return type is consistent with the return type <code>_StrOrFloat</code>. Conditional types are a form of intersection type, and they are considered subtypes of both the concrete type and the type variable.</p>"},{"location":"usage/type-concepts-advanced/#inferred-type-of-self-and-cls-parameters","title":"Inferred Type of \u201cself\u201d and \u201ccls\u201d Parameters","text":"<p>When a type annotation for a method\u2019s <code>self</code> or <code>cls</code> parameter is omitted, pyright will infer its type based on the class that contains the method. The inferred type is internally represented as a type variable that is bound to the class.</p> <p>The type of <code>self</code> is represented as <code>Self@ClassName</code> where <code>ClassName</code> is the class that contains the method. Likewise, the <code>cls</code> parameter in a class method will have the type <code>Type[Self@ClassName]</code>.</p> <pre><code>class Parent:\n    def method1(self):\n        reveal_type(self)  # Self@Parent\n        return self\n\n    @classmethod\n    def method2(cls):\n        reveal_type(cls)  # Type[Self@Parent]\n        return cls\n\nclass Child(Parent):\n     ...\n\nreveal_type(Child().method1())  # Child\nreveal_type(Child.method2())  # Type[Child]\n</code></pre>"},{"location":"usage/type-concepts-advanced/#overloads","title":"Overloads","text":"<p>Some functions or methods can return one of several different types. In cases where the return type depends on the types of the input arguments, it is useful to specify this using a series of <code>@overload</code> signatures. When Pyright evaluates a call expression, it determines which overload signature best matches the supplied arguments.</p> <p>PEP 484 introduced the <code>@overload</code> decorator and described how it can be used, but the PEP did not specify precisely how a type checker should choose the \u201cbest\u201d overload. Pyright uses the following rules.</p> <ol> <li> <p>Pyright first filters the list of overloads based on simple \u201carity\u201d (number of arguments) and keyword argument matching. For example, if one overload requires two positional arguments but only one positional argument is supplied by the caller, that overload is eliminated from consideration. Likewise, if the call includes a keyword argument but no corresponding parameter is included in the overload, it is eliminated from consideration.</p> </li> <li> <p>Pyright next considers the types of the arguments and compares them to the declared types of the corresponding parameters. If the types do not match for a given overload, that overload is eliminated from consideration. Bidirectional type inference is used to determine the types of the argument expressions.</p> </li> <li> <p>If only one overload remains, it is the \u201cwinner\u201d.</p> </li> <li> <p>If more than one overload remains, the \u201cwinner\u201d is chosen based on the order in which the overloads are declared. In general, the first remaining overload is the \u201cwinner\u201d. There are two exceptions to this rule.     Exception 1: When an <code>*args</code> (unpacked) argument matches a <code>*args</code> parameter in one of the overload signatures, this overrides the normal order-based rule.     Exception 2: When two or more overloads match because an argument evaluates to <code>Any</code> or <code>Unknown</code>, the matching overload is ambiguous. In this case, pyright examines the return types of the remaining overloads and eliminates types that are duplicates or are subsumed by (i.e. proper subtypes of) other types in the list. If only one type remains after this coalescing step, that type is used. If more than one type remains after this coalescing step, the type of the call expression evaluates to <code>Unknown</code>. For example, if two overloads are matched due to an argument that evaluates to <code>Any</code>, and those two overloads have return types of <code>str</code> and <code>LiteralString</code>, pyright will coalesce this to just <code>str</code> because <code>LiteralString</code> is a proper subtype of <code>str</code>. If the two overloads have return types of <code>str</code> and <code>bytes</code>, the call expression will evaluate to <code>Unknown</code> because <code>str</code> and <code>bytes</code> have no overlap.</p> </li> <li> <p>If no overloads remain, Pyright considers whether any of the arguments are union types. If so, these union types are expanded into their constituent subtypes, and the entire process of overload matching is repeated with the expanded argument types. If two or more overloads match, the union of their respective return types form the final return type for the call expression. This \"union expansion\" can result in a combinatoric explosion if many arguments evaluate to union types. For example, if four arguments are present, and they all evaluate to unions that expand to ten subtypes, this could result in 10^4 combinations. Pyright expands unions for arguments left to right and halts expansion when the number of signatures exceeds 64.</p> </li> <li> <p>If no overloads remain and all unions have been expanded, a diagnostic is generated indicating that the supplied arguments are incompatible with all overload signatures.</p> </li> </ol>"},{"location":"usage/type-concepts-advanced/#class-and-instance-variables","title":"Class and Instance Variables","text":"<p>Most object-oriented languages clearly differentiate between class variables and instance variables. Python is a bit looser in that it allows an object to overwrite a class variable with an instance variable of the same name.</p> <pre><code>class A:\n    my_var = 0\n\n    def my_method(self):\n        self.my_var = \"hi!\"\n\na = A()\nprint(A.my_var) # Class variable value of 0\nprint(a.my_var) # Class variable value of 0\n\nA.my_var = 1\nprint(A.my_var) # Updated class variable value of 1\nprint(a.my_var) # Updated class variable value of 1\n\na.my_method() # Writes to the instance variable my_var\nprint(A.my_var) # Class variable value of 1\nprint(a.my_var) # Instance variable value of \"hi!\"\n\nA.my_var = 2\nprint(A.my_var) # Updated class variable value of 2\nprint(a.my_var) # Instance variable value of \"hi!\"\n</code></pre> <p>Pyright differentiates between three types of variables: pure class variables, regular class variables, and pure instance variables.</p>"},{"location":"usage/type-concepts-advanced/#pure-class-variables","title":"Pure Class Variables","text":"<p>If a class variable is declared with a <code>ClassVar</code> annotation as described in PEP 526, it is considered a \u201cpure class variable\u201d and cannot be overwritten by an instance variable of the same name.</p> <pre><code>from typing import ClassVar\n\nclass A:\n    x: ClassVar[int] = 0\n\n    def instance_method(self):\n        self.x = 1  # Type error: Cannot overwrite class variable\n\n    @classmethod\n    def class_method(cls):\n        cls.x = 1\n\na = A()\nprint(A.x)\nprint(a.x)\n\nA.x = 1\na.x = 2  # Type error: Cannot overwrite class variable\n</code></pre>"},{"location":"usage/type-concepts-advanced/#regular-class-variables","title":"Regular Class Variables","text":"<p>If a class variable is declared without a <code>ClassVar</code> annotation, it can be overwritten by an instance variable of the same name. The declared type of the instance variable is assumed to be the same as the declared type of the class variable.</p> <p>Regular class variables can also be declared within a class method using a <code>cls</code> member access expression, but declaring regular class variables within the class body is more common and generally preferred for readability.</p> <pre><code>class A:\n    x: int = 0\n    y: int\n\n    def instance_method(self):\n        self.x = 1\n        self.y = 2\n\n    @classmethod\n    def class_method(cls):\n        cls.z: int = 3\n\nA.y = 0\nA.z = 0\nprint(f\"{A.x}, {A.y}, {A.z}\")  # 0, 0, 0\n\nA.class_method()\nprint(f\"{A.x}, {A.y}, {A.z}\")  # 0, 0, 3\n\na = A()\nprint(f\"{a.x}, {a.y}, {a.z}\")  # 0, 0, 3\na.instance_method()\nprint(f\"{a.x}, {a.y}, {a.z}\")  # 1, 2, 3\n\na.x = \"hi!\"  # Error: Incompatible type\n</code></pre>"},{"location":"usage/type-concepts-advanced/#pure-instance-variables","title":"Pure Instance Variables","text":"<p>If a variable is not declared within the class body but is instead declared within a class method using a <code>self</code> member access expression, it is considered a \u201cpure instance variable\u201d. Such variables cannot be accessed through a class reference.</p> <pre><code>class A:\n    def __init__(self):\n        self.x: int = 0\n        self.y: int\n\nprint(A.x)  # Error: 'x' is not a class variable\n\na = A()\nprint(a.x)\n\na.x = 1\na.y = 2\nprint(f\"{a.x}, {a.y}\")  # 1, 2\n\nprint(a.z)  # Error: 'z' is not an known member\n</code></pre>"},{"location":"usage/type-concepts-advanced/#inheritance-of-class-and-instance-variables","title":"Inheritance of Class and Instance Variables","text":"<p>Class and instance variables are inherited from parent classes. If a parent class declares the type of a class or instance variable, a derived class must honor that type when assigning to it.</p> <pre><code>class Parent:\n    x: int | str | None\n    y: int\n\nclass Child(Parent):\n    x = \"hi!\"\n    y = None  # Error: Incompatible type\n</code></pre> <p>The derived class can redeclare the type of a class or instance variable. If <code>reportIncompatibleVariableOverride</code> is enabled, the redeclared type must be the same as the type declared by the parent class. If the variable is immutable (as in a frozen <code>dataclass</code>), it is considered covariant, and it can be redeclared as a subtype of the type declared by the parent class.</p> <pre><code>class Parent:\n    x: int | str | None\n    y: int\n\nclass Child(Parent):\n    x: int  # Type error: 'x' cannot be redeclared with subtype because variable is mutable and therefore invariant\n    y: str  # Type error: 'y' cannot be redeclared with an incompatible type\n</code></pre> <p>If a parent class declares the type of a class or instance variable and a derived class does not redeclare it but does assign a value to it, the declared type is retained from the parent class. It is not overridden by the inferred type of the assignment in the derived class.</p> <pre><code>class Parent:\n    x: object\n\nclass Child(Parent):\n    x = 3\n\nreveal_type(Parent.x)  # object\nreveal_type(Child.x)  # object\n</code></pre> <p>If neither the parent nor the derived class declare the type of a class or instance variable, the type is inferred within each class.</p> <pre><code>class Parent:\n    x = object()\n\nclass Child(Parent):\n    x = 3\n\nreveal_type(Parent.x)  # object\nreveal_type(Child.x)  # int\n</code></pre>"},{"location":"usage/type-concepts-advanced/#type-variable-scoping","title":"Type Variable Scoping","text":"<p>A type variable must be bound to a valid scope (a class, function, or type alias) before it can be used within that scope.</p> <p>Pyright displays the bound scope for a type variable using an <code>@</code> symbol. For example, <code>T@func</code> means that type variable <code>T</code> is bound to function <code>func</code>.</p> <pre><code>S = TypeVar(\"S\")\nT = TypeVar(\"T\")\n\ndef func(a: T) -&gt; T:\n    b: T = a # T refers to T@func\n    reveal_type(b) # T@func\n\n    c: S # Error: S has no bound scope in this context\n    return b\n</code></pre> <p>When a TypeVar or ParamSpec appears within parameter or return type annotations for a function and it is not already bound to an outer scope, it is normally bound to the function. As an exception to this rule, if the TypeVar or ParamSpec appears only within the return type annotation of the function and only within a single Callable in the return type, it is bound to that Callable rather than the function. This allows a function to return a generic Callable.</p> <pre><code># T is bound to func1 because it appears in a parameter type annotation.\ndef func1(a: T) -&gt; Callable[[T], T]:\n    a: T # OK because T is bound to func1\n\n# T is bound to the return callable rather than func2 because it appears\n# only within a return Callable.\ndef func2() -&gt; Callable[[T], T]:\n    a: T # Error because T has no bound scope in this context\n\n# T is bound to func3 because it appears outside of a Callable.\ndef func3() -&gt; Callable[[T], T] | T:\n    ...\n\n# This scoping logic applies also to type aliases used within a return\n# type annotation. T is bound to the return Callable rather than func4.\nTransform = Callable[[S], S]\ndef func4() -&gt; Transform[T]:\n    ...\n</code></pre>"},{"location":"usage/type-concepts-advanced/#type-annotation-comments","title":"Type Annotation Comments","text":"<p>Versions of Python prior to 3.6 did not support type annotations for variables. Pyright honors type annotations found within a comment at the end of the same line where a variable is assigned.</p> <pre><code>offsets = [] # type: list[int]\n\nself._target = 3 # type: int | str\n</code></pre> <p>Future versions of Python will likely deprecate support for type annotation comments. The \u201creportTypeCommentUsage\u201d diagnostic will report usage of such comments so they can be replaced with inline type annotations.</p>"},{"location":"usage/type-concepts-advanced/#literal-math-inference","title":"Literal Math Inference","text":"<p>When inferring the type of some unary and binary operations that involve operands with literal types, pyright computes the result of operations on the literal values, producing a new literal type in the process. For example:</p> <pre><code>def func(x: Literal[1, 3], y: Literal[4, 7]):\n    z = x + y\n    reveal_type(z) # Literal[5, 8, 7, 10]\n\n    z = x * y\n    reveal_type(z) # Literal[4, 7, 12, 21]\n\n    z = (x | y) ^ 1\n    reveal_type(z) # Literal[4, 6]\n\n    z = x ** y\n    reveal_type(z) # Literal[1, 81, 2187]\n</code></pre> <p>Literal math also works on <code>str</code> literals.</p> <pre><code>reveal_type(\"a\" + \"b\") # Literal[\"ab\"]\n</code></pre> <p>The result of a literal math operation can result in large unions. Pyright limits the number of subtypes in the resulting union to 64. If the union grows beyond that, the corresponding non-literal type is inferred.</p> <pre><code>def func(x: Literal[1, 2, 3, 4, 5]):\n    y = x * x\n    reveal_type(y) # Literal[1, 2, 3, 4, 5, 6, 8, 10, 9, 12, 15, 16, 20, 25]\n    z = y * x\n    reveal_type(z) # int\n</code></pre> <p>Literal math inference is disabled within loops and lambda expressions.</p>"},{"location":"usage/type-concepts-advanced/#static-conditional-evaluation","title":"Static Conditional Evaluation","text":"<p>Pyright performs static evaluation of several conditional expression forms. This includes several forms that are mandated by the Python typing spec.</p> <ul> <li><code>sys.version_info &lt;comparison&gt; &lt;tuple&gt;</code></li> <li><code>sys.version_info[0] &gt;= &lt;number&gt;</code></li> <li><code>sys.platform == &lt;string literal&gt;</code></li> <li><code>os.name == &lt;string literal&gt;</code></li> <li><code>typing.TYPE_CHECKING</code> or <code>typing_extensions.TYPE_CHECKING</code></li> <li><code>True</code> or <code>False</code></li> <li>An identifier defined with the \"defineConstant\" configuration option</li> <li>A <code>not</code> unary operator with any of the above forms</li> <li>An  <code>and</code> or <code>or</code> binary operator with any of the above forms</li> </ul> <p>If one of these conditional expressions evaluates statically to false, pyright does not analyze any of the code within it other than checking for and reporting syntax errors.</p>"},{"location":"usage/type-concepts-advanced/#reachability","title":"Reachability","text":"<p>Pyright performs \u201creachability analysis\u201d to determine whether statements will be executed at runtime.</p> <p>Reachability analysis is based on both non-type and type information. Non-type information includes statements that unconditionally affect code flow such as <code>continue</code>, <code>raise</code> and <code>return</code>. It also includes conditional statements (<code>if</code>, <code>elif</code>, or <code>while</code>) where the conditional expression is one of these supported expression forms. Type analysis is not performed on code determined to be unreachable using non-type information. Therefore, language server features like completion suggestions are not available for this code.</p> <p>Here are some examples of code determined to be unreachable using non-type information.</p> <pre><code>from typing import TYPE_CHECKING\nimport sys\n\nif False:\n    print('unreachable')\n\nif not TYPE_CHECKING:\n    print('unreachable')\n\nif sys.version_info &lt; (3, 0):\n    print('unreachable')\n\nif sys.platform == 'ENIAC':\n    print('unreachable')\n\ndef func1():\n    return\n    print('unreachable')\n\ndef func2():\n    raise NotImplemented\n    print('unreachable')\n</code></pre> <p>Pyright can also detect code that is unreachable based on static type analysis. This analysis is based on the assumption that any provided type annotations are accurate.</p> <p>Here are some examples of code determined to be unreachable using type analysis.</p> <pre><code>from typing import Literal, NoReturn\n\ndef always_raise() -&gt; NoReturn:\n    raise ValueError\n\ndef func1():\n    always_raise()\n    print('unreachable')\n\ndef func2(x: str):\n    if not isinstance(x, str):\n        print('unreachable')\n\ndef func3(x: Literal[1, 2]):\n    if x == 1 or x == 2:\n        return\n\n    print(\"unreachable\")\n</code></pre> <p>Code that is determined to be unreachable is reported through the use of \u201ctagged hints\u201d. These are special diagnostics that tell a language client to display the code in a visually distinctive manner, typically with a grayed-out appearance. Code determined to be unreachable using non-type information is always reported through this mechanism. Code determined to be unreachable using type analysis is reported only if \u201cenableReachabilityAnalysis\u201d is enabled in the configuration.</p>"},{"location":"usage/type-inference/","title":"Type inference","text":""},{"location":"usage/type-inference/#understanding-type-inference","title":"Understanding Type Inference","text":""},{"location":"usage/type-inference/#symbols-and-scopes","title":"Symbols and Scopes","text":"<p>In Python, a symbol is any name that is not a keyword. Symbols can represent classes, functions, methods, variables, parameters, modules, type aliases, type variables, etc.</p> <p>Symbols are defined within scopes. A scope is associated with a block of code and defines which symbols are visible to that code block. Scopes can be \u201cnested\u201d allowing code to see symbols within its immediate scope and all \u201couter\u201d scopes.</p> <p>The following constructs within Python define a scope: 1. The \u201cbuiltins\u201d scope is always present and is always the outermost scope. It is pre-populated by the Python interpreter with symbols like \u201cint\u201d and \u201clist\u201d. 2. The module scope (sometimes called the \u201cglobal\u201d scope) is defined by the current source code file. 3. Each class defines its own scope. Symbols that represent methods, class variables, or instance variables appear within a class scope. 4. Each function and lambda defines its own scope. The function\u2019s parameters are symbols within its scope, as are any variables defined within the function. 5. List comprehensions define their own scope.</p>"},{"location":"usage/type-inference/#type-declarations","title":"Type Declarations","text":"<p>A symbol can be declared with an explicit type. The \u201cdef\u201d and \u201cclass\u201d keywords, for example, declare a symbol as a function or a class. Other symbols in Python can be introduced into a scope with no declared type. Newer versions of Python have introduced syntax for declaring the types of input parameters, return parameters, and variables.</p> <p>When a parameter or variable is annotated with a type, the type checker verifies that all values assigned to that parameter or variable conform to that type.</p> <p>Consider the following example: <pre><code>def func1(p1: float, p2: str, p3, **p4) -&gt; None:\n    var1: int = p1    # This is a type violation\n    var2: str = p2    # This is allowed because the types match\n    var2: int         # This is an error because it redeclares var2\n    var3 = p1         # var3 does not have a declared type\n    return var1       # This is a type violation\n</code></pre></p> Symbol Symbol Category Scope Declared Type func1 Function Module (float, str, Any, dict[str, Any]) -&gt; None p1 Parameter func1 float p2 Parameter func1 str p3 Parameter func1 p4 Parameter func1 var1 Variable func1 int var2 Variable func1 str var3 Variable func1 <p>Note that once a symbol\u2019s type is declared, it cannot be redeclared to a different type.</p>"},{"location":"usage/type-inference/#type-inference","title":"Type Inference","text":"<p>Some languages require every symbol to be explicitly typed. Python allows a symbol to be bound to different values at runtime, so its type can change over time. A symbol\u2019s type doesn\u2019t need to be declared statically.</p> <p>When Pyright encounters a symbol with no type declaration, it attempts to infer the type based on the values assigned to it. As we will see below, type inference cannot always determine the correct (intended) type, so type annotations are still required in some cases. Furthermore, type inference can require significant computation, so it is much less efficient than when type annotations are provided.</p>"},{"location":"usage/type-inference/#unknown-type","title":"\u201cUnknown\u201d Type","text":"<p>If a symbol\u2019s type cannot be inferred, Pyright sets its type to \u201cUnknown\u201d, which is a special form of \u201cAny\u201d. The \u201cUnknown\u201d type allows Pyright to optionally warn when types are not declared and cannot be inferred, thus leaving potential \u201cblind spots\u201d in type checking. </p>"},{"location":"usage/type-inference/#single-assignment-type-inference","title":"Single-Assignment Type Inference","text":"<p>The simplest form of type inference is one that involves a single assignment to a symbol. The inferred type comes from the type of the source expression. Examples include:</p> <pre><code>var1 = 3                        # Inferred type is int\nvar2 = \"hi\"                     # Inferred type is str\nvar3 = list()                   # Inferred type is list[Unknown]\nvar4 = [3, 4]                   # Inferred type is list[int]\nfor var5 in [3, 4]: ...         # Inferred type is int\nvar6 = [p for p in [1, 2, 3]]   # Inferred type is list[int]\n</code></pre>"},{"location":"usage/type-inference/#multi-assignment-type-inference","title":"Multi-Assignment Type Inference","text":"<p>When a symbol is assigned values in multiple places within the code, those values may have different types. The inferred type of the variable is the union of all such types.</p> <pre><code># In this example, symbol var1 has an inferred type of `str | int`.\nclass Foo:\n    def __init__(self):\n        self.var1 = \"\"\n\n    def do_something(self, val: int):\n        self.var1 = val\n\n# In this example, symbol var2 has an inferred type of `Foo | None`.\nif __debug__:\n    var2 = None\nelse:\n    var2 = Foo()\n</code></pre>"},{"location":"usage/type-inference/#ambiguous-type-inference","title":"Ambiguous Type Inference","text":"<p>In some cases, an expression\u2019s type is ambiguous. For example, what is the type of the expression <code>[]</code>? Is it <code>list[None]</code>, <code>list[int]</code>, <code>list[Any]</code>, <code>Sequence[Any]</code>, <code>Iterable[Any]</code>? These ambiguities can lead to unintended type violations. Pyright uses several techniques for reducing these ambiguities based on contextual information. In the absence of contextual information, heuristics are used.</p>"},{"location":"usage/type-inference/#bidirectional-type-inference-expected-types","title":"Bidirectional Type Inference (Expected Types)","text":"<p>One powerful technique Pyright uses to eliminate type inference ambiguities is bidirectional inference. This technique makes use of an \u201cexpected type\u201d.</p> <p>As we saw above, the type of the expression <code>[]</code> is ambiguous, but if this expression is passed as an argument to a function, and the corresponding parameter is annotated with the type <code>list[int]</code>, Pyright can now assume that the type of <code>[]</code> in this context must be <code>list[int]</code>. Ambiguity eliminated!</p> <p>This technique is called \u201cbidirectional inference\u201d because type inference for an assignment normally proceeds by first determining the type of the right-hand side (RHS) of the assignment, which then informs the type of the left-hand side (LHS) of the assignment. With bidirectional inference, if the LHS of an assignment has a declared type, it can influence the inferred type of the RHS.</p> <p>Let\u2019s look at a few examples:</p> <pre><code>var1 = []                       # Type of RHS is ambiguous\nvar2: list[int] = []            # Type of LHS now makes type of RHS unambiguous\nvar3 = [4]                      # Type is assumed to be list[int] \nvar4: list[float] = [4]         # Type of RHS is now list[float]\nvar5 = (3,)                     # Type is assumed to be tuple[Literal[3]]\nvar6: tuple[float, ...] = (3,)  # Type of RHS is now tuple[float, ...]\n</code></pre>"},{"location":"usage/type-inference/#empty-list-and-dictionary-type-inference","title":"Empty List and Dictionary Type Inference","text":"<p>It is common to initialize a local variable or instance variable to an empty list (<code>[]</code>) or empty dictionary (<code>{}</code>) on one code path but initialize it to a non-empty list or dictionary on other code paths. In such cases, Pyright will infer the type based on the non-empty list or dictionary and suppress errors about a \u201cpartially unknown type\u201d.</p> <pre><code>if some_condition:\n    my_list = []\nelse:\n    my_list = [\"a\", \"b\"]\n\nreveal_type(my_list) # list[str]\n</code></pre>"},{"location":"usage/type-inference/#return-type-inference","title":"Return Type Inference","text":"<p>As with variable assignments, function return types can be inferred from the <code>return</code> statements found within that function. The returned type is assumed to be the union of all types returned from all <code>return</code> statements. If a <code>return</code> statement is not followed by an expression, it is assumed to return <code>None</code>. Likewise, if the function does not end in a <code>return</code> statement, and the end of the function is reachable, an implicit <code>return None</code> is assumed.</p> <pre><code># This function has two explicit return statements and one implicit\n# return (at the end). It does not have a declared return type,\n# so Pyright infers its return type based on the return expressions.\n# In this case, the inferred return type is `str | bool | None`.\n\ndef func1(val: int):\n    if val &gt; 3:\n        return \"\"\n    elif val &lt; 1:\n        return True\n</code></pre>"},{"location":"usage/type-inference/#noreturn-return-type","title":"NoReturn return type","text":"<p>If there is no code path that returns from a function (e.g. all code paths raise an exception), Pyright infers a return type of <code>NoReturn</code>. As an exception to this rule, if the function is decorated with <code>@abstractmethod</code>, the return type is not inferred as <code>NoReturn</code> even if there is no return. This accommodates a common practice where an abstract method is implemented with a <code>raise</code> statement that raises an exception of type <code>NotImplementedError</code>.</p> <pre><code>class Foo:\n    # The inferred return type is NoReturn.\n    def method1(self):\n        raise Exception()\n\n    # The inferred return type is Unknown.\n    @abstractmethod\n    def method2(self):\n        raise NotImplementedError()\n</code></pre>"},{"location":"usage/type-inference/#generator-return-types","title":"Generator return types","text":"<p>Pyright can infer the return type for a generator function from the <code>yield</code> statements contained within that function.</p>"},{"location":"usage/type-inference/#call-site-return-type-inference","title":"Call-site Return Type Inference","text":"<p>It is common for input parameters to be unannotated. This can make it difficult for Pyright to infer the correct return type for a function. For example:</p> <pre><code># The return type of this function cannot be fully inferred based\n# on the information provided because the types of parameters\n# a and b are unknown. In this case, the inferred return\n# type is `Unknown | None`.\n\ndef func1(a, b, c):\n    if c:\n        return a\n    elif c &gt; 3:\n        return b\n    else:\n        return None\n</code></pre> <p>In cases where all parameters are unannotated, Pyright uses a technique called call-site return type inference. It performs type inference using the the types of arguments passed to the function in a call expression. If the unannotated function calls other functions, call-site return type inference can be used recursively. Pyright limits this recursion to a small number for practical performance reasons.</p> <pre><code>def func2(p_int: int, p_str: str, p_flt: float):\n    # The type of var1 is inferred to be `int | None` based\n    # on call-site return type inference.\n    var1 = func1(p_int, p_int, p_int)\n\n    # The type of var2 is inferred to be `str | float | None`.\n    var2 = func1(p_str, p_flt, p_int)\n</code></pre>"},{"location":"usage/type-inference/#parameter-type-inference","title":"Parameter Type Inference","text":"<p>Input parameters for functions and methods typically require type annotations. There are several cases where Pyright may be able to infer a parameter\u2019s type if it is unannotated.</p> <p>For instance methods, the first parameter (named <code>self</code> by convention) is inferred to be type <code>Self</code>.</p> <p>For class methods, the first parameter (named <code>cls</code> by convention) is inferred to be type <code>type[Self]</code>.</p> <p>For other unannotated parameters within a method, Pyright looks for a method of the same name implemented in a base class. If the corresponding method in the base class has the same signature (the same number of parameters with the same names), no overloads, and annotated parameter types, the type annotation from this method is \u201cinherited\u201d for the corresponding parameter in the child class method.</p> <pre><code>class Parent:\n    def method1(self, a: int, b: str) -&gt; float:\n        ...\n\n\nclass Child(Parent):\n    def method1(self, a, b):\n        return a\n\nreveal_type(Child.method1)  # (self: Child, a: int, b: str) -&gt; int\n</code></pre> <p>When parameter types are inherited from a base class method, the return type is not inherited. Instead, normal return type inference techniques are used.</p> <p>If the type of an unannotated parameter cannot be inferred using any of the above techniques and the parameter has a default argument expression associated with it, the parameter type is inferred from the default argument type. If the default argument is <code>None</code>, the inferred type is <code>Unknown | None</code>.</p> <pre><code>def func(a, b=0, c=None):\n    pass\n\nreveal_type(func)  # (a: Unknown, b: int, c: Unknown | None) -&gt; None\n</code></pre> <p>This inference technique also applies to lambdas whose input parameters include default arguments.</p> <pre><code>cb = lambda x = \"\": x\nreveal_type(cb)  # (x: str = \"\" -&gt; str)\n</code></pre>"},{"location":"usage/type-inference/#literals","title":"Literals","text":"<p>Python 3.8 introduced support for literal types. This allows a type checker like Pyright to track specific literal values of str, bytes, int, bool, and enum values. As with other types, literal types can be declared.</p> <pre><code># This function is allowed to return only values 1, 2 or 3.\ndef func1() -&gt; Literal[1, 2, 3]:\n    ...\n\n# This function must be passed one of three specific string values.\ndef func2(mode: Literal[\"r\", \"w\", \"rw\"]) -&gt; None:\n    ...\n</code></pre> <p>When Pyright is performing type inference, it generally does not infer literal types. Consider the following example:</p> <pre><code># If Pyright inferred the type of var1 to be list[Literal[4]],\n# any attempt to append a value other than 4 to this list would\n# generate an error. Pyright therefore infers the broader\n# type list[int].\nvar1 = [4]\n</code></pre>"},{"location":"usage/type-inference/#tuple-expressions","title":"Tuple Expressions","text":"<p>When inferring the type of a tuple expression (in the absence of bidirectional inference hints), Pyright assumes that the tuple has a fixed length, and each tuple element is typed as specifically as possible.</p> <pre><code># The inferred type is tuple[Literal[1], Literal[\"a\"], Literal[True]].\nvar1 = (1, \"a\", True)\n\ndef func1(a: int):\n    # The inferred type is tuple[int, int].\n    var2 = (a, a)\n\n    # If you want the type to be tuple[int, ...]\n    # (i.e. a homogeneous tuple of indeterminate length),\n    # use a type annotation.\n    var3: tuple[int, ...] = (a, a)\n</code></pre> <p>Because tuples are typed as specifically as possible, literal types are normally retained. However, as an exception to this inference rule, if the tuple expression is nested within another tuple, set, list or dictionary expression, literal types are not retained. This is done to avoid the inference of complex types (e.g. unions with many subtypes) when evaluating tuple statements with many entries.</p> <pre><code># The inferred type is list[tuple[int, str, bool]].\nvar4 = [(1, \"a\", True), (2, \"b\", False), (3, \"c\", False)]\n</code></pre>"},{"location":"usage/type-inference/#list-expressions","title":"List Expressions","text":"<p>When inferring the type of a list expression (in the absence of bidirectional inference hints), Pyright uses the following heuristics:</p> <ol> <li>If the list is empty (<code>[]</code>), assume <code>list[Unknown]</code> (unless a known list type is assigned to the same variable along another code path).</li> <li>If the list contains at least one element and all elements are the same type T, infer the type <code>list[T]</code>.</li> <li> <p>If the list contains multiple elements that are of different types, the behavior depends on the <code>strictListInference</code> configuration setting. By default this setting is off.</p> <ul> <li>If <code>strictListInference</code> is off, infer <code>list[Unknown]</code>.</li> <li>Otherwise use the union of all element types and infer <code>list[Union[(elements)]]</code>.</li> </ul> </li> </ol> <p>These heuristics can be overridden through the use of bidirectional inference hints (e.g. by providing a declared type for the target of the assignment expression).</p> <pre><code>var1 = []                       # Infer list[Unknown]\n\nvar2 = [1, 2]                   # Infer list[int]\n\n# Type depends on strictListInference config setting\nvar3 = [1, 3.4]                 # Infer list[Unknown] (off)\nvar3 = [1, 3.4]                 # Infer list[int | float] (on)\n\nvar4: list[float] = [1, 3.4]    # Infer list[float]\n</code></pre>"},{"location":"usage/type-inference/#set-expressions","title":"Set Expressions","text":"<p>When inferring the type of a set expression (in the absence of bidirectional inference hints), Pyright uses the following heuristics:</p> <ol> <li>If the set contains at least one element and all elements are the same type T, infer the type <code>set[T]</code>.</li> <li> <p>If the set contains multiple elements that are of different types, the behavior depends on the <code>strictSetInference</code> configuration setting. By default this setting is off.</p> <ul> <li>If <code>strictSetInference</code> is off, infer <code>set[Unknown]</code>.</li> <li>Otherwise use the union of all element types and infer <code>set[Union[(elements)]]</code>.</li> </ul> </li> </ol> <p>These heuristics can be overridden through the use of bidirectional inference hints (e.g. by providing a declared type for the target of the assignment expression).</p> <pre><code>var1 = {1, 2}                   # Infer set[int]\n\n# Type depends on strictSetInference config setting\nvar2 = {1, 3.4}                 # Infer set[Unknown] (off)\nvar2 = {1, 3.4}                 # Infer set[int | float] (on)\n\nvar3: set[float] = {1, 3.4}    # Infer set[float]\n</code></pre>"},{"location":"usage/type-inference/#dictionary-expressions","title":"Dictionary Expressions","text":"<p>When inferring the type of a dictionary expression (in the absence of bidirectional inference hints), Pyright uses the following heuristics:</p> <ol> <li>If the dict is empty (<code>{}</code>), assume <code>dict[Unknown, Unknown]</code>.</li> <li>If the dict contains at least one element and all keys are the same type K and all values are the same type V, infer the type <code>dict[K, V]</code>.</li> <li> <p>If the dict contains multiple elements where the keys or values differ in type, the behavior depends on the <code>strictDictionaryInference</code> configuration setting. By default this setting is off.</p> <ul> <li>If <code>strictDictionaryInference</code> is off, infer <code>dict[Unknown, Unknown]</code>.</li> <li>Otherwise use the union of all key and value types <code>dict[Union[(keys)], Union[(values)]]</code>.</li> </ul> </li> </ol> <pre><code>var1 = {}                       # Infer dict[Unknown, Unknown]\n\nvar2 = {1: \"\"}                  # Infer dict[int, str]\n\n# Type depends on strictDictionaryInference config setting\nvar3 = {\"a\": 3, \"b\": 3.4}       # Infer dict[str, Unknown] (off)\nvar3 = {\"a\": 3, \"b\": 3.4}       # Infer dict[str, int | float] (on)\n\nvar4: dict[str, float] = {\"a\": 3, \"b\": 3.4}\n</code></pre>"},{"location":"usage/type-inference/#lambdas","title":"Lambdas","text":"<p>Lambdas present a particular challenge for a Python type checker because there is no provision in the Python syntax for annotating the types of a lambda\u2019s input parameters. The types of these parameters must therefore be inferred based on context using bidirectional type inference. Absent this context, a lambda\u2019s input parameters (and often its return type) will be unknown.</p> <pre><code># The type of var1 is (a: Unknown, b: Unknown) -&gt; Unknown.\nvar1 = lambda a, b: a + b\n\n# This function takes a comparison function callback.\ndef float_sort(list: list[float], comp: Callable[[float, float], bool]): ...\n\n# In this example, the types of the lambda\u2019s input parameters\n# a and b can be inferred to be float because the float_sort\n# function expects a callback that accepts two floats as\n# inputs.\nfloat_sort([2, 1.3], lambda a, b: False if a &lt; b else True)\n</code></pre>"},{"location":"usage/type-stubs/","title":"Type stubs","text":""},{"location":"usage/type-stubs/#type-stub-files","title":"Type Stub Files","text":"<p>Type stubs are \u201c.pyi\u201d files that specify the public interface for a library. They use a variant of the Python syntax that allows for \u201c...\u201d to be used in place of any implementation details. Type stubs define the public contract for the library.</p>"},{"location":"usage/type-stubs/#importance-of-type-stub-files","title":"Importance of Type Stub Files","text":"<p>Regardless of the search path, Pyright always attempts to resolve an import with a type stub (\u201c.pyi\u201d) file before falling back to a python source (\u201c.py\u201d) file. If a type stub cannot be located for an external import, Pyright will try to use inline type information if the module is part of a package that contains a \u201cpy.typed\u201d file (defined in PEP 561). If the module is part of a package that doesn\u2019t contain a \u201cpy.typed\u201d file, Pyright will treat all of the symbols imported from these modules as having type \u201cUnknown\u201d, and wildcard imports (of the form <code>from foo import *</code>) will not populate the module\u2019s namespace with specific symbol names.</p> <p>Why does Pyright not attempt (by default) to determine types from imported python sources? There are several reasons.</p> <ol> <li>Imported libraries can be quite large, so analyzing them can require significant time and computation.</li> <li>Some libraries are thin shims on top of native (C++) libraries. Little or no type information would be inferable in these cases.</li> <li>Some libraries override Python\u2019s default loader logic. Static analysis is not possible in these cases.</li> <li>Type information inferred from source files is often of low value because many types cannot be inferred correctly. Even if concrete types can be inferred, generic type definitions cannot.</li> <li>Type analysis would expose all symbols from an imported module, even those that are not meant to be exposed by the author. Unlike many other languages, Python offers no way of differentiating between a symbol that is meant to be exported and one that isn\u2019t.</li> </ol> <p>If you\u2019re serious about static type checking for your Python source base, it\u2019s highly recommended that you consume \u201cpy.typed\u201d packages or use type stub files for all external imports. If you are unable to find a type stub for a particular library, the recommended approach is to create a custom type stub file that defines the portion of that module\u2019s interface used by your code. More library maintainers have started to provide inlined types or type stub files.</p>"},{"location":"usage/type-stubs/#generating-type-stubs","title":"Generating Type Stubs","text":"<p>If you use only a few classes, methods or functions within a library, writing a type stub file by hand is feasible. For large libraries, this can become tedious and error-prone. Pyright can generate \u201cdraft\u201d versions of type stub files for you.</p> <p>To generate a type stub file from within VS Code, enable the reportMissingTypeStubs\u201d setting in your pyrightconfig.json file or by adding a comment <code># pyright: reportMissingTypeStubs=true</code> to individual source files. Make sure you have the target library installed in the python environment that pyright is configured to use for import resolution. Optionally specify a \u201cstubPath\u201d in your pyrightconfig.json file. This is where pyright will generate your type stub files. By default, the stubPath is set to \"./typings\".</p>"},{"location":"usage/type-stubs/#generating-type-stubs-in-vs-code","title":"Generating Type Stubs in VS Code","text":"<p>If \u201creportMissingTypeStubs\u201d is enabled, pyright will highlight any imports that have no type stub. Hover over the error message, and you will see a \u201cQuick Fix\u201d link. Clicking on this link will reveal a popup menu item titled \u201cCreate Type Stub For XXX\u201d. The example below shows a missing typestub for the <code>django</code> library.</p> <p></p> <p>Click on the menu item to create the type stub. Depending on the size of the library, it may take pyright tens of seconds to analyze the library and generate type stub files. Once complete, you should see a message in VS Code indicating success or failure.</p> <p></p>"},{"location":"usage/type-stubs/#generating-type-stubs-from-command-line","title":"Generating Type Stubs from Command Line","text":"<p>The command-line version of pyright can also be used to generate type stubs. As with the VS Code version, it must be run within the context of your configured project. Then type <code>pyright --createstub [import-name]</code>.</p> <p>For example: <code>pyright --createstub django</code></p>"},{"location":"usage/type-stubs/#cleaning-up-generated-type-stubs","title":"Cleaning Up Generated Type Stubs","text":"<p>Pyright can give you a head start by creating type stubs, but you will typically need to clean up the first draft, fixing various errors and omissions that pyright was not able to infer from the original library code.</p> <p>A few common situations that need to be cleaned up:</p> <ol> <li> <p>When generating a \u201c.pyi\u201d file, pyright removes any imports that are not referenced. Sometimes libraries import symbols that are meant to be simply re-exported from a module even though they are not referenced internally to that module. In such cases, you will need to manually add back these imports. Pyright does not perform this import culling in <code>__init__.pyi</code> files because this re-export technique is especially common in such files.</p> </li> <li> <p>Some libraries attempt to import modules within a try statement. These constructs don\u2019t work well in type stub files because they cannot be evaluated statically. Pyright omits any try statements when creating \u201c.pyi\u201d files, so you may need to add back in these import statements.</p> </li> <li> <p>Decorator functions are especially problematic for static type analyzers. Unless properly typed, they completely hide the signature of any class or function they are applied to. For this reason, it is highly recommended that you enable the \u201creportUntypedFunctionDecorator\u201d and \u201creportUntypedClassDecorator\u201d switches in pyrightconfig.json. Most decorators simply return the same function they are passed. Those can easily be annotated with a TypeVar like this:</p> </li> </ol> <pre><code>from typing import Any, Callable, TypeVar\n\n_FuncT = TypeVar('_FuncT', bound=Callable[..., Any])\n\ndef my_decorator(*args, **kw) -&gt; Callable[[_FuncT], _FuncT]: ...\n</code></pre>"},{"location":"usage/typed-libraries/","title":"Typed libraries","text":""},{"location":"usage/typed-libraries/#typing-guidance-for-python-libraries","title":"Typing Guidance for Python Libraries","text":"<p>Much of Python\u2019s popularity can be attributed to the rich collection of Python libraries available to developers. Authors of these libraries play an important role in improving the experience for Python developers. This document provides some recommendations and guidance for Python library authors.</p> <p>These recommendations are intended to provide the following benefits:</p> <ol> <li>Consumers of libraries should have a great coding experience with fast and accurate completion suggestions, class and function documentation, signature help (including parameter default values), hover text, and auto-imports. This should happen by default without needing to download extra packages and without any special configuration. These features should be consistent across the Python ecosystem regardless of a developer\u2019s choice of editor, IDE, notebook environment, etc.</li> <li>Consumers of libraries should be able to rely on complete and accurate type information so static type checkers can detect and report type inconsistencies and other violations of the interface contract.</li> <li>Library authors should be able to specify a well-defined interface contract that is enforced by tools. This allows a library implementation to evolve and improve without breaking consumers of the library.</li> <li>Library authors should have the benefits of static type checking to produce high-quality, bug-free implementations.</li> </ol>"},{"location":"usage/typed-libraries/#inlined-type-annotations-and-type-stubs","title":"Inlined Type Annotations and Type Stubs","text":"<p>PEP 561 documents several ways type information can be delivered for a library: inlined type annotations, type stub files included in the package, a separate companion type stub package, and type stubs in the typeshed repository. Some of these options fall short on delivering the benefits above. We therefore provide the following more specific guidance to library authors.</p> <p>All libraries should include inlined type annotations for the functions, classes, methods, and constants that comprise the public interface for the library.</p> <p>Inlined type annotations should be included directly within the source code that ships with the package. Of the options listed in PEP 561, inlined type annotations offer the most benefits. They typically require the least effort to add and maintain, they are always consistent with the implementation, and docstrings and default parameter values are readily available, allowing language servers to enhance the development experience.</p> <p>There are cases where inlined type annotations are not possible \u2014 most notably when a library\u2019s exposed functionality is implemented in a language other than Python. Libraries that expose symbols implemented in languages other than Python should include stub (\u201c.pyi\u201d) files that describe the types for those symbols. These stubs should also contain docstrings and default parameter values.</p> <p>In many existing type stubs (such as those found in typeshed), default parameter values are replaced with with \u201c...\u201d and all docstrings are removed. We recommend that default values and docstrings remain within the type stub file so language servers can display this information to developers.</p>"},{"location":"usage/typed-libraries/#library-interface","title":"Library Interface","text":"<p>PEP 561 indicates that a \u201cpy.typed\u201d marker file must be included in the package if the author wishes to support type checking of their code.</p> <p>If a \u201cpy.typed\u201d module is present, a type checker will treat all modules within that package (i.e. all files that end in \u201c.py\u201d or \u201c.pyi\u201d) as importable unless the module is marked private. There are two ways to mark a module private: (1) the module's filename begins with an underscore; (2) the module is inside a sub-package marked private. For example:</p> <ul> <li>foo._bar (_bar is private)</li> <li>foo._bar.baz (_bar and baz are private)</li> <li>foo._bar.baz.bop (_bar, baz, and bop are private)</li> </ul> <p>Each module exposes a set of symbols. Some of these symbols are considered \u201cprivate\u201d \u2014 implementation details that are not part of the library\u2019s interface. Type checkers like pyright use the following rules to determine which symbols are visible outside of the package.</p> <ul> <li>Symbols whose names begin with an underscore (but are not dunder names) are considered private.</li> <li>Imported symbols are considered private by default. If they use the \u201cimport A as A\u201d (a redundant module alias), \u201cfrom X import A as A\u201d (a redundant symbol alias), or \u201cfrom . import A\u201d forms, symbol \u201cA\u201d is not private unless the name begins with an underscore. If a file <code>__init__.py</code> uses the form \u201cfrom .A import X\u201d, symbol \u201cA\u201d is not private unless the name begins with an underscore (but \u201cX\u201d is still private). If a wildcard import (of the form \u201cfrom X import *\u201d) is used, all symbols referenced by the wildcard are not private.</li> <li>A module can expose an <code>__all__</code> symbol at the module level that provides a list of names that are considered part of the interface. The <code>__all__</code> symbol indicates which symbols are included in a wildcard import. All symbols included in the <code>__all__</code> list are considered public even if the other rules above would otherwise indicate that they were private. For example, this allows symbols whose names begin with an underscore to be included in the interface.</li> <li>Local variables within a function (including nested functions) are always considered private.</li> </ul> <p>The following idioms are supported for defining the values contained within <code>__all__</code>. These restrictions allow type checkers to statically determine the value of <code>__all__</code>.</p> <ul> <li><code>__all__ = ('a', 'b')</code></li> <li><code>__all__ = ['a', 'b']</code></li> <li><code>__all__ += ['a', 'b']</code></li> <li><code>__all__ += submodule.__all__</code></li> <li><code>__all__.extend(['a', 'b'])</code></li> <li><code>__all__.extend(submodule.__all__)</code></li> <li><code>__all__.append('a')</code></li> <li><code>__all__.remove('a')</code></li> </ul>"},{"location":"usage/typed-libraries/#type-completeness","title":"Type Completeness","text":"<p>A \u201cpy.typed\u201d library is said to be \u201ctype complete\u201d if all of the symbols that comprise its interface have type annotations that refer to types that are fully known. Private symbols are exempt.</p> <p>A \u201cknown type\u201d is defined as follows:</p> <p>Classes:</p> <ul> <li>All class variables, instance variables, and methods that are \u201cvisible\u201d (not overridden) are annotated and refer to known types</li> <li>If a class is a subclass of a generic class, type arguments are provided for each generic type parameter, and these type arguments are known types</li> </ul> <p>Functions and Methods:</p> <ul> <li>All input parameters have type annotations that refer to known types</li> <li>The return parameter is annotated and refers to a known type</li> <li>The result of applying one or more decorators results in a known type</li> </ul> <p>Type Aliases:</p> <ul> <li>All of the types referenced by the type alias are known</li> </ul> <p>Variables:</p> <ul> <li>All variables have type annotations that refer to known types</li> </ul> <p>Type annotations can be omitted in a few specific cases where the type is obvious from the context:</p> <ul> <li>Constants that are assigned simple literal values (e.g. <code>RED = '#F00'</code> or <code>MAX_TIMEOUT = 50</code> or <code>room_temperature: Final = 20</code>). A constant is a symbol that is assigned only once and is either annotated with <code>Final</code> or is named in all-caps. A constant that is not assigned a simple literal value requires explicit annotations, preferably with a <code>Final</code> annotation (e.g. <code>WOODWINDS: Final[list[str]] = ['Oboe', 'Bassoon']</code>).</li> <li>Enum values within an Enum class do not require annotations because they take on the type of the Enum class.</li> <li>Type aliases do not require annotations. A type alias is a symbol that is defined at a module level with a single assignment where the assigned value is an instantiable type, as opposed to a class instance (e.g. <code>Foo = Callable[[Literal[\"a\", \"b\"]], int | str]</code> or <code>Bar = MyGenericClass[int] | None</code>).</li> <li>The \u201cself\u201d parameter in an instance method and the \u201ccls\u201d parameter in a class method do not require an explicit annotation.</li> <li>The return type for an <code>__init__</code> method does not need to be specified, since it is always <code>None</code>.</li> <li>The following module-level symbols do not require type annotations: <code>__all__</code>,<code>__author__</code>, <code>__copyright__</code>, <code>__email__</code>, <code>__license__</code>, <code>__title__</code>, <code>__uri__</code>, <code>__version__</code>.</li> <li>The following class-level symbols do not require type annotations: <code>__class__</code>, <code>__dict__</code>, <code>__doc__</code>, <code>__module__</code>, <code>__slots__</code>.</li> <li>A variable is assigned in only one location using a simple assignment expression and the right-hand side of the assignment is a literal value (e.g. <code>1</code>, <code>3.14</code>, <code>\"hi\"</code>, or <code>MyEnum.Value</code>) or an identifier that has a known type that doesn't depend on type narrowing logic.</li> </ul>"},{"location":"usage/typed-libraries/#ambiguous-types","title":"Ambiguous Types","text":"<p>When a symbol is missing a type annotation, a type checker may be able to infer its type based on contextual information. However, type inference rules are not standardized and differ between type checkers. A symbol is said to have an \u201cambiguous type\u201d if its type may be inferred differently between different Python type checkers. This can lead to a bad experience for consumers of the library.</p> <p>Ambiguous types can be avoided by providing explicit type annotations.</p>"},{"location":"usage/typed-libraries/#examples-of-known-ambiguous-and-unknown-types","title":"Examples of known, ambiguous and unknown types","text":"<pre><code># Variable with known type (unambiguous because it uses a literal assignment)\na = 3\n\n# Variable with ambiguous type\na = [3, 4, 5]\n\n# Variable with known (declared) type\na: list[int] = [3, 4, 5]\n\n# Type alias with partially unknown type (because type\n# arguments are missing for list and dict)\nDictOrList = list | dict\n\n# Type alias with known type\nDictOrList = list[Any] | dict[str, Any]\n\n# Generic type alias with known type\n_T = TypeVar(\"_T\")\nDictOrList = list[_T] | dict[str, _T]\n\n# Function with known type\ndef func(a: int | None, b: dict[str, float] = {}) -&gt; None:\n    pass\n\n# Function with partially unknown type (because type annotations\n# are missing for input parameters and return type)\ndef func(a, b):\n    pass\n\n# Function with partially unknown type (because of missing\n# type args on dict)\ndef func(a: int, b: dict) -&gt; None:\n    pass\n\n# Function with partially unknown type (because return type\n# annotation is missing)\ndef func(a: int, b: dict[str, float]):\n    pass\n\n# Decorator with partially unknown type (because type annotations\n# are missing for input parameters and return type)\ndef my_decorator(func):\n    return func\n\n# Function with partially unknown type (because type is obscured\n# by untyped decorator)\n@my_decorator\ndef func(a: int) -&gt; str:\n    pass\n\n\n# Class with known type\nclass MyClass:\n    height: float = 2.0\n\n    def __init__(self, name: str, age: int):\n        self.age: int = age\n\n    @property\n    def name(self) -&gt; str:\n        ...\n\n# Class with partially unknown type\nclass MyClass:\n    # Missing type annotation for class variable\n    height = None\n\n    # Missing input parameter annotations\n    def __init__(self, name, age):\n        # Missing type annotation for instance variable\n        self.age = age\n\n    # Missing return type annotation\n    @property\n    def name(self):\n        ...\n\n# Class with partially unknown type\nclass BaseClass1:\n    # Missing type annotation\n    height: = 2.0\n\n    # Missing type annotation\n    def get_stuff(self):\n        ...\n\n# Class with known type (because it overrides all symbols\n# exposed by BaseClass that have incomplete types)\nclass DerivedClass1(BaseClass1):\n    height: float\n\n    def get_stuff(self) -&gt; str:\n        ...\n\n# Class with known type\nclass BaseClass2:\n    height: float = 2.0\n\n# Class with ambiguous type\nclass DerivedClass2(BaseClass2):\n    # Missing type annotation, could be inferred as float or int\n    height = 1\n\n# Class with partially unknown type because base class\n# (dict) is generic, and type arguments are not specified.\nclass DictSubclass(dict):\n    pass\n</code></pre>"},{"location":"usage/typed-libraries/#verifying-type-completeness","title":"Verifying Type Completeness","text":"<p>Pyright provides a feature that allows library authors to verify type completeness for a \u201cpy.typed\u201d package. To use this feature, create a clean Python environment and install your package along with all of the other dependent packages. Run the CLI version of pyright with the <code>--verifytypes</code> option.</p> <p><code>pyright --verifytypes &lt;lib&gt;</code></p> <p>Pyright will analyze the library, identify all symbols that comprise the interface to the library and emit errors for any symbols whose types are ambiguous or unknown. It also produces a \u201ctype completeness score\u201d which is the percentage of symbols with known types.</p> <p>To see additional details (including a full list of symbols in the library), append the <code>--verbose</code> option.</p> <p>The <code>--verifytypes</code> option can be combined with <code>--outputjson</code> to emit the results in a form that can be consumed by other tools.</p> <p>The <code>--verifytypes</code> feature can be integrated into a continuous integration (CI) system to verify that a library remains \u201ctype complete\u201d.</p> <p>If the <code>--verifytypes</code> option is combined with <code>--ignoreexternal</code>, any incomplete types that are imported from other external packages are ignored. This allows library authors to focus on adding type annotations for the code that is directly under their control.</p>"},{"location":"usage/typed-libraries/#improving-type-completeness","title":"Improving Type Completeness","text":"<p>Here are some tips for increasing the type completeness score for your library:</p> <ul> <li>If your package includes tests or sample code, consider removing them from the distribution. If there is good reason to include them, consider placing them in a directory that begins with an underscore so they are not considered part of your library\u2019s interface.</li> <li>If your package includes submodules that are meant to be implementation details, rename those files to begin with an underscore.</li> <li>If a symbol is not intended to be part of the library\u2019s interface and is considered an implementation detail, rename it such that it begins with an underscore. It will then be considered private and excluded from the type completeness check.</li> <li>If your package exposes types from other libraries, work with the maintainers of these other libraries to achieve type completeness.</li> </ul>"},{"location":"usage/typed-libraries/#best-practices-for-inlined-types","title":"Best Practices for Inlined Types","text":""},{"location":"usage/typed-libraries/#wide-vs-narrow-types","title":"Wide vs. Narrow Types","text":"<p>In type theory, when comparing two types that are related to each other, the \u201cwider\u201d type is the one that is more general, and the \u201cnarrower\u201d type is more specific. For example, <code>Sequence[str]</code> is a wider type than <code>list[str]</code> because all <code>list</code> objects are also <code>Sequence</code> objects, but the converse is not true. A subclass is narrower than a class it derives from. A union of types is wider than the individual types that comprise the union.</p> <p>In general, a function input parameter should be annotated with the widest possible type supported by the implementation. For example, if the implementation requires the caller to provide an iterable collection of strings, the parameter should be annotated as <code>Iterable[str]</code>, not as <code>list[str]</code>. The latter type is narrower than necessary, so if a user attempts to pass a tuple of strings (which is supported by the implementation), a type checker will complain about a type incompatibility.</p> <p>As a specific application of the \u201cuse the widest type possible\u201d rule, libraries should generally use immutable forms of container types instead of mutable forms (unless the function needs to modify the container). Use <code>Sequence</code> rather than <code>list</code>, <code>Mapping</code> rather than <code>dict</code>, etc. Immutable containers allow for more flexibility because their type parameters are covariant rather than invariant. A parameter that is typed as <code>Sequence[str | int]</code> can accept a <code>list[str | int]</code>, <code>list[int]</code>, <code>Sequence[str]</code>, and a <code>Sequence[int]</code>. But a parameter typed as <code>list[str | int]</code> is much more restrictive and accepts only a <code>list[str | int]</code>.</p>"},{"location":"usage/typed-libraries/#overloads","title":"Overloads","text":"<p>If a function or method can return multiple different types and those types can be determined based on the presence or types of certain parameters, use the <code>@overload</code> mechanism defined in PEP 484. When overloads are used within a \u201c.py\u201d file, they must appear prior to the function implementation, which should not have an <code>@overload</code> decorator. </p>"},{"location":"usage/typed-libraries/#keyword-only-parameters","title":"Keyword-only Parameters","text":"<p>If a function or method is intended to take parameters that are specified only by name, use the keyword-only separator (\"*\").</p> <pre><code>def create_user(age: int, *, dob: date | None = None):\n    ...\n</code></pre>"},{"location":"usage/typed-libraries/#positional-only-parameters","title":"Positional-only Parameters","text":"<p>If a function or method is intended to take parameters that are specified only by position, use the positional-only separator (\"/\") as documented in PEP 570. If your library needs to run on versions of Python prior to 3.8, you can alternatively name the positional-only parameters with an identifier that begins with a double underscore.</p> <pre><code>def compare_values(value1: T, value2: T, /) -&gt; bool:\n    ...\n\ndef compare_values(__value1: T, __value2: T) -&gt; bool:\n    ...\n</code></pre>"},{"location":"usage/typed-libraries/#annotating-decorators","title":"Annotating Decorators","text":"<p>Decorators modify the behavior of a class or a function. Providing annotations for decorators is straightforward if the decorator retains the original signature of the decorated function.</p> <pre><code>_F = TypeVar(\"_F\", bound=Callable[..., Any])\n\ndef simple_decorator(_func: _F) -&gt; _F:\n    \"\"\"\n     Simple decorators are invoked without parentheses like this:\n       @simple_decorator\n       def my_function(): ...\n     \"\"\"\n   ...\n\ndef complex_decorator(*, mode: str) -&gt; Callable[[_F], _F]:\n    \"\"\"\n     Complex decorators are invoked with arguments like this:\n       @complex_decorator(mode=\"easy\")\n       def my_function(): ...\n     \"\"\"\n   ...\n</code></pre> <p>Decorators that mutate the signature of the decorated function present challenges for type annotations. The <code>ParamSpec</code> and <code>Concatenate</code> mechanisms described in PEP 612 provide some help here, but these are available only in Python 3.10 and newer. More complex signature mutations may require type annotations that erase the original signature, thus blinding type checkers and other tools that provide signature assistance. As such, library authors are discouraged from creating decorators that mutate function signatures in this manner.</p>"},{"location":"usage/typed-libraries/#generic-classes-and-functions","title":"Generic Classes and Functions","text":"<p>Classes and functions that can operate in a generic manner on various types should declare themselves as generic using the mechanisms described in PEP 484. This includes the use of <code>TypeVar</code> symbols. Typically, a <code>TypeVar</code> should be private to the file that declares it, and should therefore begin with an underscore.</p>"},{"location":"usage/typed-libraries/#type-aliases","title":"Type Aliases","text":"<p>Type aliases are symbols that refer to other types. Generic type aliases (those that refer to unspecialized generic classes) are supported by most type checkers. Pyright also provides support for recursive type aliases.</p> <p>PEP 613 provides a way to explicitly designate a symbol as a type alias using the new TypeAlias annotation.</p> <pre><code># Simple type alias\nFamilyPet = Cat | Dog | GoldFish\n\n# Generic type alias\nListOrTuple = list[_T] | tuple[_T, ...]\n\n# Recursive type alias\nTreeNode = LeafNode | list[\"TreeNode\"]\n\n# Explicit type alias using PEP 613 syntax\nStrOrInt: TypeAlias = str | int\n</code></pre>"},{"location":"usage/typed-libraries/#abstract-classes-and-methods","title":"Abstract Classes and Methods","text":"<p>Classes that must be subclassed should derive from <code>ABC</code>, and methods or properties that must be overridden should be decorated with the <code>@abstractmethod</code> decorator. This allows type checkers to validate that the required methods have been overridden and provide developers with useful error messages when they are not. It is customary to implement an abstract method by raising a <code>NotImplementedError</code> exception or subclass thereof.</p> <pre><code>from abc import ABC, abstractmethod\n\nclass Hashable(ABC):\n   @property\n   @abstractmethod\n   def hash_value(self) -&gt; int:\n      \"\"\"Subclasses must override\"\"\"\n      raise NotImplementedError()\n\n   @abstractmethod\n   def print(self) -&gt; str:\n      \"\"\"Subclasses must override\"\"\"\n      raise NotImplementedError()\n</code></pre>"},{"location":"usage/typed-libraries/#final-classes-and-methods","title":"Final Classes and Methods","text":"<p>Classes that are not intended to be subclassed should be decorated as <code>@final</code> as described in PEP 591. The same decorator can also be used to specify methods that cannot be overridden by subclasses.</p>"},{"location":"usage/typed-libraries/#literals","title":"Literals","text":"<p>Type annotations should make use of the Literal type where appropriate, as described in PEP 586. Literals allow for more type specificity than their non-literal counterparts.</p>"},{"location":"usage/typed-libraries/#constants","title":"Constants","text":"<p>Constant values (those that are read-only) can be specified using the Final annotation as described in PEP 591.</p> <p>Type checkers will also typically treat variables that are named using all upper-case characters as constants.</p> <p>In both cases, it is OK to omit the declared type of a constant if it is assigned a literal str, int, float, bool or None value. In such cases, the type inference rules are clear and unambiguous, and adding a literal type annotation would be redundant.</p> <pre><code># All-caps constant with inferred type\nCOLOR_FORMAT_RGB = \"rgb\"\n\n# All-caps constant with explicit type\nCOLOR_FORMAT_RGB: Literal[\"rgb\"] = \"rgb\"\nLATEST_VERSION: tuple[int, int] = (4, 5)\n\n# Final variable with inferred type\nColorFormatRgb: Final = \"rgb\"\n\n# Final variable with explicit type\nColorFormatRgb: Final[Literal[\"rgb\"]] = \"rgb\"\nLATEST_VERSION: Final[tuple[int, int]] = (4, 5)\n</code></pre>"},{"location":"usage/typed-libraries/#typed-dictionaries-data-classes-and-named-tuples","title":"Typed Dictionaries, Data Classes, and Named Tuples","text":"<p>If a library runs only on newer versions of Python, it can use some of the new type-friendly classes.</p> <p>NamedTuple (described in PEP 484) is preferred over namedtuple.</p> <p>Data classes (described in PEP 557) are preferred over untyped dictionaries.</p> <p>TypedDict (described in PEP 589) is preferred over untyped dictionaries.</p>"},{"location":"usage/typed-libraries/#compatibility-with-older-python-versions","title":"Compatibility with Older Python Versions","text":"<p>Each new version of Python from 3.5 onward has introduced new typing constructs. This presents a challenge for library authors who want to maintain runtime compatibility with older versions of Python. This section documents several techniques that can be used to add types while maintaining backward compatibility.</p>"},{"location":"usage/typed-libraries/#quoted-annotations","title":"Quoted Annotations","text":"<p>Type annotations for variables, parameters, and return types can be placed in quotes. The Python interpreter will then ignore them, whereas a type checker will interpret them as type annotations.</p> <pre><code># Older versions of Python do not support subscripting\n# for the OrderedDict type, so the annotation must be\n# enclosed in quotes.\ndef get_config(self) -&gt; \"OrderedDict[str, str]\":\n   return self._config\n</code></pre>"},{"location":"usage/typed-libraries/#type-comment-annotations","title":"Type Comment Annotations","text":"<p>Python 3.0 introduced syntax for parameter and return type annotations, as specified in PEP 484. Python 3.6 introduced support for variable type annotations, as specified in PEP 526.</p> <p>If you need to support older versions of Python, type annotations can still be provided as \u201ctype comments\u201d. These comments take the form <code># type: &lt;annotation&gt;</code>.</p> <pre><code>class Foo:\n   # Variable type comments go at the end of the line\n   # where the variable is assigned.\n   timeout = None # type: int | None\n\n   # Function type comments can be specified on the\n   # line after the function signature.\n   def send_message(self, name, length):\n      # type: (str, int) -&gt; None\n      ...\n\n   # Function type comments can also specify the type\n   # of each parameter on its own line.\n   def receive_message(\n      self,\n      name, # type: str\n      length # type: int\n   ):\n      # type: () -&gt; Message\n      ...\n</code></pre>"},{"location":"usage/typed-libraries/#typing_extensions","title":"typing_extensions","text":"<p>New type features that require runtime support are typically included in the stdlib <code>typing</code> module. Where possible, these new features are back-ported to a runtime library called <code>typing_extensions</code> that works with older Python runtimes.</p>"},{"location":"usage/typed-libraries/#type_checking","title":"TYPE_CHECKING","text":"<p>The <code>typing</code> module exposes a variable called <code>TYPE_CHECKING</code> which has a value of False within the Python runtime but a value of True when the type checker is performing its analysis. This allows type checking statements to be conditionalized.</p> <p>Care should be taken when using <code>TYPE_CHECKING</code> because behavioral changes between type checking and runtime could mask problems that the type checker would otherwise catch.</p>"},{"location":"usage/typed-libraries/#non-standard-type-behaviors","title":"Non-Standard Type Behaviors","text":"<p>Type annotations provide a way to annotate typical type behaviors, but some classes implement specialized, non-standard behaviors that cannot be described using standard type annotations. For now, such types need to be annotated as Any, which is unfortunate because the benefits of static typing are lost.</p>"},{"location":"usage/typed-libraries/#docstrings","title":"Docstrings","text":"<p>It is recommended that docstrings be provided for all classes, functions, and methods in the interface. They should be formatted according to PEP 257.</p> <p>There is currently no single agreed-upon standard for function and method docstrings, but several common variants have emerged. We recommend using one of these variants.</p>"}]}