{
    "CodeAction": {
        "createTypeStub": "创建类型存根文件",
        "createTypeStubFor": "为 \"{moduleName}\" 创建类型存根文件",
        "executingCommand": "正在执行命令",
        "filesToAnalyzeCount": "正在分析 {count} 个文件",
        "filesToAnalyzeOne": "正在分析 1 个文件",
        "findingReferences": "正在查找引用",
        "organizeImports": "整理导入项",
        "renameShadowedFile": "将 \"{oldFile}\" 重命名为 \"{newFile}\""
    },
    "Completion": {
        "autoImportDetail": "自动导入",
        "indexValueDetail": "索引值"
    },
    "Diagnostic": {
        "abstractMethodInvocation": "不能调用未实现的抽象方法 \"{method}\"",
        "annotatedMetadataInconsistent": "`Annotated` 元数据类型 \"{metadataType}\" 与 \"{type}\" 类型不兼容",
        "annotatedParamCountMismatch": "参数注解数量不匹配: 应有 {expected} 个，但只有 {received} 个",
        "annotatedTypeArgMissing": "`Annotated` 中应有一个类型参数以及至少一个注解",
        "annotationBytesString": "类型表达式中不能使用字节串字面量（`b\"...\"`）",
        "annotationFormatString": "类型表达式中不能使用 f-string",
        "annotationNotSupported": "此语句不支持作为类型注解使用",
        "annotationRawString": "类型表达式中不能使用原始字符串字面量（`r\"...\"`）",
        "annotationSpansStrings": "类型表达式不能跨越多个字符串字面量",
        "annotationStringEscape": "类型表达式不能包含转义字符",
        "argAssignment": "\"{argType}\" 类型的实参无法赋值给 \"{paramType}\" 类型的形参",
        "argAssignmentFunction": "\"{argType}\" 类型的实参无法赋值给函数 \"{functionName}\" 中 \"{paramType}\" 类型的形参",
        "argAssignmentParam": "\"{argType}\" 类型的实参无法赋值给 \"{paramType}\" 类型的形参 \"{paramName}\"",
        "argAssignmentParamFunction": "\"{argType}\" 类型的实参无法赋值给函数 \"{functionName}\" 中 \"{paramType}\" 类型的形参 \"{paramName}\"",
        "argMissingForParam": "参数 {name} 缺少传入值",
        "argMissingForParams": "参数 {names} 缺少传入值",
        "argMorePositionalExpectedCount": "还需要传入 {expected} 个位置参数",
        "argMorePositionalExpectedOne": "还需要传入 1 个位置参数",
        "argPositional": "需要传入位置参数",
        "argPositionalExpectedCount": "需要传入 {expected} 个位置参数",
        "argPositionalExpectedOne": "需要传入 1 个位置参数",
        "argTypePartiallyUnknown": "部分参数的类型未知",
        "argTypeAny": "参数类型为 `Any`",
        "argTypeUnknown": "参数类型未知",
        "assertAlwaysTrue": "断言（`assert`）的计算结果始终为 True",
        "assertTypeArgs": "\"assert_type\" 需要传入两个位置参数",
        "assertTypeTypeMismatch": "\"assert_type\" 不匹配：值应为 \"{expected}\" 类型，但传入值的类型为 \"{received}\"",
        "assignmentExprComprehension": "赋值的目标变量名 \"{name}\" 不能与推导式使用的变量重名",
        "assignmentExprContext": "赋值表达式只能在模块、函数或 `lambda` 中使用",
        "assignmentExprInSubscript": "在下标（`value[...]`）中使用海象表达式需要 Python 3.10 或更高版本",
        "assignmentInProtocol": "协议类中声明的实例变量或类变量必须在类中显式声明",
        "assignmentTargetExpr": "表达式不能被赋值",
        "asyncNotInAsyncFunction": "异步函数之外不允许使用 \"async for/with/...\"",
        "awaitIllegal": "使用 `await` 需要 Python 3.5 或更高版本",
        "awaitNotAllowed": "类型注解中不能使用 `await`",
        "awaitNotInAsync": "仅允许在异步函数内使用 `await`",
        "backticksIllegal": "Python 3.x 中不支持使用反引号包围的表达式；请改用 repr(...)",
        "baseClassCircular": "类不能继承自身",
        "baseClassFinal": "基类 \"{type}\" 被 `@final` 装饰，因此不能被子类继承",
        "baseClassIncompatible": "{type} 的基类之间不相互兼容",
        "baseClassInvalid": "类的参数必须是基类",
        "baseClassAny": "`Any` 类型的基类覆盖了子类的类型",
        "baseClassMethodTypeIncompatible": "方法 \"{name}\" 的定义与 \"{classType}\" 类的基类不兼容",
        "baseClassUnknown": "未知类型的基类覆盖了子类的类型",
        "baseClassVariableTypeIncompatible": "变量 \"{name}\" 的定义与 \"{classType}\" 类的基类不兼容",
        "binaryOperationNotAllowed": "类型注解中不允许使用二元运算符",
        "bindTypeMismatch": "无法绑定方法 \"{methodName}\"，因为 \"{type}\" 不能赋值给 \"{paramName}\" 参数",
        "breakOutsideLoop": "`break` 只能在循环中使用",
        "callableExtraArgs": "`Callable` 只能传入两个类型参数",
        "callableFirstArg": "此处应为参数类型列表或 `...`",
        "callableNotInstantiable": "无法实例化 \"{type}\" 类型",
        "callableSecondArg": "返回类型应为 `Callable` 的第二个类型参数",
        "casePatternIsIrrefutable": "只有最后一个 `case` 语句允许使用模式 `_`",
        "classAlreadySpecialized": "原泛型（在定义时）已被特化为 \"{type}\"",
        "classDecoratorTypeAny": "返回 `Any` 类型的类装饰器覆盖了原始类的类型",
        "classDecoratorTypeUnknown": "未标注返回类型的类装饰器会覆盖原始类的类型，因此已忽略此装饰器",
        "classDefinitionCycle": "\"{name}\" 类存在循环定义",
        "classGetItemClsParam": "重写的 `__class_getitem__` 方法应接受 `cls` 参数",
        "classMethodClsParam": "类方法应接受 `cls` 参数",
        "classNotRuntimeSubscriptable": "在 \"{name}\" 类上使用的下标将导致运行时异常，应将整个类型注解写成字符串形式",
        "classPatternBuiltInArgPositional": "当使用类本身进行模式匹配时，随后的括号内部只能接受位置参数形式的子模式",
        "classPatternPositionalArgCount": "\"{type}\" 类的位置模式太多：应为 {expected} 个而非 {received} 个",
        "classPatternTypeAlias": "无法在类模式中使用已特化的类型别名 \"{type}\"",
        "classPropertyDeprecated": "装饰器 `@classmethod` + `@property` 的组合已在 Python 3.11 中弃用，并将在 Python 3.13 中移除",
        "classTypeParametersIllegal": "类的类型参数语法（PEP 695）需要 Python 3.12 或更高版本",
        "classVarFirstArgMissing": "`ClassVar` 内应存在且仅存在一个类型参数",
        "classVarNotAllowed": "此上下文中不允许使用 `ClassVar`",
        "classVarOverridesInstanceVar": "被标记为 `ClassVar` 的 \"{name}\" 覆写了类 \"{className}\" 中的同名实例属性",
        "classVarTooManyArgs": "`ClassVar` 内应存在且仅存在一个类型参数",
        "classVarWithTypeVar": "`ClassVar` 的类型参数中不能包含类型变量（`TypeVar`）",
        "clsSelfParamTypeMismatch": "参数 \"{name}\" 的类型必须是类 \"{classType}\" 或其基类",
        "codeTooComplexToAnalyze": "代码过于复杂导致无法完成分析；请将其重构为多个小规模代码的组合，或减少条件代码路径来降低复杂度",
        "collectionAliasInstantiation": "无法实例化类型 \"{type}\"，请改用 \"{alias}\"",
        "comparisonAlwaysFalse": "条件的计算结果始终为 `False`，因为类型 \"{leftType}\" 和 \"{rightType}\" 之间不存在交集",
        "comparisonAlwaysTrue": "条件的计算结果始终为 `True`，因为类型 \"{leftType}\" 和 \"{rightType}\" 之间不存在交集",
        "comprehensionInDict": "字典推导式中不能混入其他字典项，建议使用形如 \"{**comprehension, key: value}\" 的形式",
        "comprehensionInSet": "集合推导式中不能混入其他集合项，建议使用形如 \"{*comprehension, item}\" 的形式",
        "concatenateContext": "该上下文中不允许使用 `Concatenate`",
        "concatenateParamSpecMissing": "`Concatenate` 的最后一个类型参数必须是 `ParamSpec` 或 `...`",
        "concatenateTypeArgsMissing": "`Concatenate` 中至少需要传入两个类型参数",
        "conditionalOperandInvalid": "类型 {type} 的条件值（源于 `__bool__` 方法）无效",
        "constantRedefinition": "不能重新定义常量 \"{name}\"（全大写名称）",
        "constructorParametersMismatch": "\"{classType}\" 类中方法 `__new__` 与 `__init__` 的签名不匹配",
        "containmentAlwaysFalse": "表达式的计算结果始终为 `False`，因为类型 \"{leftType}\" 和 \"{rightType}\" 之间不存在交集",
        "containmentAlwaysTrue": "表达式的计算结果始终为 `True`，因为类型 \"{leftType}\" 和 \"{rightType}\" 之间不存在交集",
        "continueInFinally": "`continue` 不能在 `finally` 子句中使用",
        "continueOutsideLoop": "`continue` 只能在循环中使用",
        "coroutineInConditionalExpression": "条件表达式中使用未 `await` 的协程作为判断条件，其计算结果始终为 `True`",
        "dataClassBaseClassFrozen": "非冻结（`frozen=False`）的 `dataclass` 不能继承已冻结（`frozen=True`）的 `dataclass`",
        "dataClassBaseClassNotFrozen": "冻结（`frozen=True`）的 `dataclass` 不能继承非冻结（`frozen=False`）的 `dataclass`",
        "dataClassConverterFunction": "\"{argType}\" 类型的参数不是 \"{fieldType}\" 类型的字段 \"{fieldName}\" 的合法转换器",
        "dataClassConverterOverloads": "\"{funcName}\" 的重载不是 \"{fieldType}\" 类型的字段 \"{fieldName}\" 的合法转换器",
        "dataClassFieldInheritedDefault": "\"{fieldName}\" 覆盖了（父类的）同名字段，但未给定默认值",
        "dataClassFieldWithDefault": "没有默认值的字段不能出现在具有默认值的字段之后",
        "dataClassFieldWithPrivateName": "`dataclass` 的字段不能使用私有名称",
        "dataClassFieldWithoutAnnotation": "缺少类型注解的 `dataclass` 字段将导致运行时异常",
        "dataClassPostInitParamCount": "`dataclass` 中声明的 `__post_init__` 方法参数数量不正确；`InitVar` 字段数应为 {expected} 个",
        "dataClassPostInitType": "`dataclass` 中声明的方法 `__post_init__` 方法中 \"{fieldName}\" 字段的参数类型不匹配",
        "dataClassSlotsOverwrite": "类中已定义 `__slots__`",
        "dataClassTransformExpectedBoolLiteral": "需要静态推导结果为 `True` 或 `False` 的表达式",
        "dataClassTransformFieldSpecifier": "需要类或函数的元组而非 \"{type}\" 类型",
        "dataClassTransformPositionalParam": "\"dataclass_transform\" 的所有参数都必须是关键字参数",
        "dataClassTransformUnknownArgument": "\"dataclass_transform\" 不支持 \"{name}\" 参数",
        "dataProtocolInSubclassCheck": "`issubclass` 调用中不允许使用数据协议（包括非方法属性）",
        "declaredReturnTypePartiallyUnknown": "声明的返回类型 \"{returnType}\" 部分未知",
        "declaredReturnTypeUnknown": "声明的返回类型未知",
        "defaultValueContainsCall": "参数默认值表达式中不允许调用函数或使用可变对象",
        "defaultValueNotAllowed": "`*` 或 `**` 的参数不能有默认值",
        "delTargetExpr": "表达式无法删除",
        "deprecatedClass": "\"{name}\" 类已弃用",
        "deprecatedConstructor": "\"{name}\" 类的构造函数已弃用",
        "deprecatedDescriptorDeleter": "\"{name}\" 描述器的 \"__delete__\" 方法已弃用",
        "deprecatedDescriptorGetter": "\"{name}\" 描述器的 \"__get__\" 方法已弃用",
        "deprecatedDescriptorSetter": "\"{name}\" 描述器的 \"__set__\" 方法已弃用",
        "deprecatedFunction": "\"{name}\" 函数已弃用",
        "deprecatedMethod": "\"{className}\" 类中的 \"{name}\" 方法已弃用",
        "deprecatedPropertyDeleter": "\"{name}\" 属性的 `deleter` 已弃用",
        "deprecatedPropertyGetter": "\"{name}\" 属性的 `getter` 已弃用",
        "deprecatedPropertySetter": "\"{name}\" 属性的 `setter` 已弃用",
        "deprecatedType": "此类型自 Python {version} 起已弃用；请改用 \"{replacement}\"",
        "dictExpandIllegalInComprehension": "推导式中不允许展开字典表达式",
        "dictInAnnotation": "类型注解中不允许使用字典表达式",
        "dictKeyValuePairs": "字典项必须包含键值对",
        "dictUnpackIsNotMapping": "字典解包运算符需要 `Mapping` 对象",
        "dunderAllSymbolNotPresent": "\"{name}\" 已在 `__all__` 中声明，但未在模块中定义",
        "duplicateArgsParam": "最多有一个 `*` 参数",
        "duplicateBaseClass": "不允许重复的基类",
        "duplicateCapturePatternTarget": "\"{name}\" 捕获目标不能在同一模式中多次出现",
        "duplicateCatchAll": "最多有一个能够捕获所有异常的 `except` 子句",
        "duplicateEnumMember": "重复的枚举声明 \"{name}\"",
        "duplicateGenericAndProtocolBase": "最多有一个 `Generic[...]` 或 `Protocol[...]` 基类",
        "duplicateImport": "\"{importName}\" 被重复导入",
        "duplicateKeywordOnly": "最多有一个 `*` 分隔出关键字参数",
        "duplicateKwargsParam": "最多有一个可变关键字（`**kwds`）参数",
        "duplicateParam": "\"{name}\" 参数声明重复",
        "duplicatePositionOnly": "函数参数中最多有一个 \"/\"",
        "duplicateStarPattern": "在序列形式的模式匹配中最多有一个 `*` 项",
        "duplicateStarStarPattern": "最多有一个 `**` 项",
        "duplicateUnpack": "仅允许使用一次 `Unpack`",
        "ellipsisAfterUnpacked": "`...` 不能与已解包的 `TypeVarTuple` 或元组一起使用",
        "ellipsisContext": "`...` 不允许在此上下文中使用",
        "ellipsisSecondArg": "`...` 仅允许作为这两个参数中的第二个参数",
        "enumClassOverride": "\"{name}\" 枚举类已使用 `@final` 装饰，因此不能派生子类",
        "enumMemberDelete": "无法删除枚举成员 \"{name}\"",
        "enumMemberSet": "无法给枚举成员 \"{name}\" 赋值",
        "enumMemberTypeAnnotation": "枚举成员不允许使用类型注解",
        "exceptionGroupIncompatible": "异常组语法（`except*`）需要使用 Python 3.11 或更高版本",
        "exceptionGroupTypeIncorrect": "异常组中的异常不能为 `BaseGroupException` 的子类",
        "exceptionTypeIncorrect": "\"{type}\" 不是 `BaseException` 的子类",
        "exceptionTypeNotClass": "\"{type}\" 不是有效的异常（`Exception`）类",
        "exceptionTypeNotInstantiable": "`Exception` \"{type}\" 的构造函数需要一个或多个参数",
        "expectedAfterDecorator": "装饰器下方应存在函数或类声明",
        "expectedArrow": "应有 `->` 符号和随后的返回类型的类型注解",
        "expectedAsAfterException": "`expect Exception` 语句后只能为 `as` ",
        "expectedAssignRightHandExpr": "`=` 右侧应有表达式",
        "expectedBinaryRightHandExpr": "运算符右侧应有表达式",
        "expectedBoolLiteral": "此处应为 `True` 或 `False`",
        "expectedCase": "此处应有 `case` 语句",
        "expectedClassName": "此处应填写类名",
        "expectedCloseBrace": "`{` 未闭合",
        "expectedCloseBracket": "`[` 未闭合",
        "expectedCloseParen": "`(` 未闭合",
        "expectedColon": "此处应有 `:`",
        "expectedComplexNumberLiteral": "模式匹配需要复数字面量",
        "expectedDecoratorExpr": "Python 3.9 之前不支持表达式形式的装饰器",
        "expectedDecoratorName": "此处应有装饰器名称",
        "expectedDecoratorNewline": "装饰器末尾应换行",
        "expectedDelExpr": "`del` 后应有表达式",
        "expectedElse": "此处应为 `else`",
        "expectedEquals": "此处应有 `=`",
        "expectedExceptionClass": "异常类或异常对象无效",
        "expectedExceptionObj": "此处应有异常对象、异常类或 `None`",
        "expectedExpr": "此处应有表达式",
        "expectedFunctionAfterAsync": "`async` 后面应有函数定义",
        "expectedFunctionName": "`def` 后面应有函数名称",
        "expectedIdentifier": "此处应有标识符",
        "expectedImport": "此处应为 `import`",
        "expectedImportAlias": "`as` 后应指定别称",
        "expectedImportSymbols": "`import` 后应有符号名称",
        "expectedIn": "此处应为 `in`",
        "expectedInExpr": "`in` 后应有表达式",
        "expectedIndentedBlock": "此处应有缩进块",
        "expectedMemberName": "`.` 后应有属性名称",
        "expectedModuleName": "此处应有模块名称",
        "expectedNameAfterAs": "`as` 后应有符号名称",
        "expectedNamedParameter": "关键字参数必须跟在 `*` 之后",
        "expectedNewline": "此处应有换行符",
        "expectedNewlineOrSemicolon": "语句必须用换行符或分号分隔",
        "expectedOpenParen": "此处应有 `(`",
        "expectedParamName": "此处应有参数名称",
        "expectedPatternExpr": "此处应有模式匹配表达式",
        "expectedPatternSubjectExpr": "此处应有一个表达式，用于模式匹配的匹配目标",
        "expectedPatternValue": "此处应有 `a.b` 形式的模式值表达式",
        "expectedReturnExpr": "`return` 后应有表达式",
        "expectedSliceIndex": "此处应有索引或切片表达式",
        "expectedTypeNotString": "此处应为类型而非字符串字面量",
        "expectedTypeParameterName": "此处应有类型参数名称",
        "expectedYieldExpr": "`yield` 语句后应跟随一个表达式",
        "finalClassIsAbstract": "\"{type}\" 类被 `@final` 装饰，故必须实现所有抽象符号",
        "finalContext": "不允许在此上下文中使用 `Final`",
        "finalInLoop": "不能在循环中给 `Final` 变量赋值",
        "finalMethodOverride": "\"{name}\" 方法无法覆写在 \"{className}\" 类中定义的被 `@final` 装饰的方法",
        "finalNonMethod": "\"{name}\" 函数不是方法，不能用 `@final` 装饰",
        "finalReassigned": "\"{name}\" 已声明为 `Final`，无法重新赋值",
        "finalRedeclaration": "\"{name}\" 此前已有声明为 `Final`，但在此处被重新声明",
        "finalRedeclarationBySubclass": "无法重新声明 \"{name}\" ，因为父类 \"{className}\" 将其声明为 `Final`",
        "finalTooManyArgs": "`Final` 后应有且仅有一个类型参数",
        "finalUnassigned": "\"{name}\" 声明为 `Final`，但未被赋值",
        "formatStringBrace": "f-string 字面量中不允许使用单个花括号；请使用两个花括号代替",
        "formatStringBytes": "f-string 字面量不能是 `bytes` 类型的",
        "formatStringDebuggingIllegal": "f-string 中使用调试辅助符 `=` 需要 Python 3.8 或更高版本",
        "formatStringEscape": "f-string 的表达式部分中使用转义序列（反斜杠）需要 Python 3.12 或更高版本",
        "formatStringExpectedConversion": "f-string 中 `!` 后缺少对转换操作的描述",
        "formatStringIllegal": "f-string 字面量需要 Python 3.6 或更高版本",
        "formatStringInPattern": "模式匹配使用的模式表达式中不允许使用 f-string",
        "formatStringNestedFormatSpecifier": "f-string 中包含的表达式嵌套太深",
        "formatStringNestedQuote": "在 Python 3.12 之前，嵌套的字符串不能使用与 f-string 相同的引号字符",
        "formatStringUnicode": "f-string 字面量不能为 `Unicode`",
        "formatStringUnterminated": "f-string 中有未终止的表达式；需要 `}`",
        "functionDecoratorTypeAny": "`Any` 类型的函数装饰器覆盖了被装饰函数的类型",
        "functionDecoratorTypeUnknown": "未标返回值类型的函数装饰器会覆盖函数类型，因此已忽略装饰器",
        "functionInConditionalExpression": "条件表达式中含有未调用的函数，其计算结果始终为 `True`",
        "functionTypeParametersIllegal": "函数的类型参数语法（PEP 695）需要 Python 3.12 或更高版本",
        "futureImportLocationNotAllowed": "从 `__future__` 的导入必须位于文件的开头",
        "generatorAsyncReturnType": "异步生成器函数的返回类型必须与 `AsyncGenerator[{yieldType}, Any]` 兼容",
        "generatorNotParenthesized": "不是唯一参数的生成器表达式必须带上圆括号",
        "generatorSyncReturnType": "生成器函数的返回类型必须与 `Generator[{yieldType}, Any, Any]` 兼容",
        "genericBaseClassNotAllowed": "`Generic` 基类不能与类型参数语法一起使用",
        "genericClassAssigned": "无法赋值 `Generic` 类型",
        "genericClassDeleted": "无法删除 `Generic` 类型",
        "genericInstanceVariableAccess": "这是通过类访问泛型实例上的变量，因此无法确定其类型",
        "genericNotAllowed": "`Generic` 在此上下文中无效",
        "genericTypeAliasBoundTypeVar": "类中的泛型类型别名不能使用具有绑定的类型变量 {names}",
        "genericTypeArgMissing": "`Generic` 应至少有一个类型参数",
        "genericTypeArgTypeVar": "`Generic` 的类型参数必须是类型变量",
        "genericTypeArgUnique": "`Generic` 的类型参数必须唯一",
        "globalReassignment": "\"{name}\" 在此前已定义为全局变量，但在此处被重新赋值",
        "globalRedefinition": "\"{name}\" 此前已在全局声明，但在此处亦被重新声明",
        "implicitStringConcat": "不允许隐式的字符串拼接",
        "importCycleDetected": "导入链中检测到循环导入",
        "importDepthExceeded": "导入链深度超过 {depth} 层",
        "importResolveFailure": "无法解析导入 \"{importName}\"",
        "importSourceResolveFailure": "无法从源码解析导入 \"{importName}\"，你是否正确安装了该库？",
        "importSymbolUnknown": "\"{name}\" 是未知的导入符号",
        "incompatibleMethodOverride": "此 \"{name}\" 方法以不兼容的方式覆写了 \"{className}\" 类中的同名方法",
        "inconsistentIndent": "缩进量与此前并不一致",
        "inconsistentTabs": "缩进中混用了制表符和空格",
        "initMethodSelfParamTypeVar": "`__init__` 方法中 `self` 参数的类型注解不能含有类限定作用域的类型变量",
        "initMustReturnNone": "`__init__` 方法的返回类型必须为 `None`",
        "initSubclassCallFailed": "`__init_subclass__` 方法上的关键字参数不正确",
        "initSubclassClsParam": "重写的 `__init_subclass__` 应采用 `cls` 参数",
        "initVarNotAllowed": "此上下文中不允许使用 `InitVar`",
        "instanceMethodSelfParam": "实例方法应接受 `self` 参数",
        "instanceVarOverridesClassVar": "实例变量 \"{name}\" 覆写了 \"{className}\" 类中的同名类变量",
        "instantiateAbstract": "抽象类 \"{type}\" 不可实例化",
        "instantiateProtocol": "协议类 \"{type}\" 不可实例化",
        "internalBindError": "对 \"{file}\" 文件分析符号绑定关系时发生内部错误：{message}",
        "internalParseError": "分析 \"{file}\" 文件时发生内部错误：{message}",
        "internalTypeCheckingError": "对 \"{file}\" 文件进行类型检查时发生内部错误：{message}",
        "invalidIdentifierChar": "标识符中使用了无效字符",
        "invalidStubStatement": "语句在类型存根文件中无意义",
        "invalidTokenChars": "该 `Token` 中的字符 \"{text}\" 无效",
        "isInstanceInvalidType": "`isinstance` 的第二个参数必须是单个类或由多个类构成的元组",
        "isSubclassInvalidType": "`issubclass` 的第二个参数必须是单个类或由多个类构成的元组",
        "keyValueInSet": "集合内不允许存在键值对",
        "keywordArgInTypeArgument": "关键字参数不能在类型参数列表中使用",
        "keywordArgShortcutIllegal": "关键字参数的简写形式需要 Python 3.14 或更高版本",
        "keywordOnlyAfterArgs": "参数声明中，`/` 不允许出现在 `*` 之后",
        "keywordParameterMissing": "`*` 参数之后必须有关键字参数",
        "keywordSubscriptIllegal": "下标中不支持使用关键字参数",
        "lambdaReturnTypeAny": "该 `lambda` 函数的返回类型为 `Any`",
        "lambdaReturnTypePartiallyUnknown": "该 `lambda` 的返回类型 \"{returnType}\" 部分未知",
        "lambdaReturnTypeUnknown": "该 `lambda` 的返回类型未知",
        "listAssignmentMismatch": "无法将 \"{type}\" 类型的表达式赋值给目标列表",
        "listInAnnotation": "类型注解中不允许使用列表表达式",
        "literalEmptyArgs": "`Literal` 后应有一个或多个类型参数",
        "literalNamedUnicodeEscape": "`Literal` 字符串注解中不支持 `Unicode` 名称转义序列（\"\\N{...}\"）",
        "literalNotAllowed": "如果不传入类型参数，则 `Literal` 不能用于此上下文",
        "literalNotCallable": "`Literal` 类型无法实例化",
        "literalUnsupportedType": "`Literal` 的类型参数必须是字面量（`None`、`int`、`bool`、`str` 或 `bytes`）或枚举值",
        "matchIncompatible": "`match` 语句需要 Python 3.10 或更高版本",
        "matchIsNotExhaustive": "`match` 语句中的匹配条件不能处理所有可能的值",
        "maxParseDepthExceeded": "超出最大分析深度；请将表达式拆解为较小的子表达式",
        "memberAccess": "无法访问 \"{type}\" 类的 \"{name}\" 属性",
        "memberDelete": "无法删除 \"{type}\" 类的 \"{name}\" 属性",
        "memberSet": "无法为 \"{type}\" 类的 \"{name}\" 属性赋值",
        "metaclassConflict": "派生类的元类必须是其所有基类的元类的子类",
        "metaclassDuplicate": "只能使用一个元类",
        "metaclassIsGeneric": "元类不能为泛型",
        "methodNotDefined": "未定义 \"{name}\" 方法",
        "methodNotDefinedOnType": "\"{type}\" 类型上未定义 \"{name}\" 方法",
        "methodOrdering": "无法构造一致的方法排序（MRO）",
        "methodOverridden": "\"{name}\" 在不兼容 \"{type}\" 类型的 \"{className}\" 类中覆写了同名的方法",
        "methodReturnsNonObject": "\"{name}\" 方法不返回对象",
        "missingSuperCall": "\"{methodName}\" 方法不调用父类的同名方法",
        "mixingBytesAndStr": "`bytes` 与 `str` 类型的值不能互相拼接",
        "moduleAsType": "模块不能用作类型",
        "moduleNotCallable": "模块不能被调用",
        "moduleUnknownMember": "\"{memberName}\" 不是 \"{moduleName}\" 模块的已知属性",
        "namedExceptAfterCatchAll": "捕获所有异常的 `except` 子句后不能再使用指定了异常的 `except` 子句",
        "namedParamAfterParamSpecArgs": "关键字参数 \"{name}\" 不能出现在 `ParamSpec args` 参数之后的签名中",
        "namedTupleEmptyName": "`NamedTuple` 中的名称不能为空",
        "namedTupleEntryRedeclared": "无法覆写 `NamedTuple` 类 \"{className}\" 的 \"{name}\" 属性",
        "namedTupleFirstArg": "第一个参数应为 `NamedTuple` 的类名",
        "namedTupleMultipleInheritance": "`NamedTuple` 不支持多继承",
        "namedTupleNameKeyword": "字段名称不能是关键字",
        "namedTupleNameType": "应为指定了字段名称和类型的二元元组",
        "namedTupleNameUnique": "`NamedTuple` 中的字段名称之间必须是唯一的",
        "namedTupleNoTypes": "`namedtuple` 不提供元组项的类型；请改用 `NamedTuple`",
        "namedTupleSecondArg": "`NamedTuple` 的第二个参数应为字段列表",
        "newClsParam": "重写的 `__new__` 应接受 `cls` 参数",
        "newTypeAnyOrUnknown": "`NewType` 的第二个参数必须是已知类，而不是 `Any` 或未知类型",
        "newTypeBadName": "`NewType` 的第一个参数必须是字符串字面量",
        "newTypeLiteral": "`NewType` 不能与 `Literal` 类型一起使用",
        "newTypeNameMismatch": "`NewType` 必须赋值给同名变量",
        "newTypeNotAClass": "`NewType` 的第二个参数应为类",
        "newTypeParamCount": "`NewType` 需要两个位置参数",
        "newTypeProtocolClass": "`NewType` 不能与 `Structural Typing`（Python 中指 `Protocol` 或 `TypedDict`）一起使用",
        "noOverload": "\"{name}\" 的重载与提供的参数不匹配",
        "noReturnContainsReturn": "返回类型为 `NoReturn` 的函数不能包含 `return` 语句",
        "noReturnContainsYield": "返回类型为 `NoReturn` 的函数不能包含 `yield` 语句",
        "noReturnReturnsNone": "返回类型为 `NoReturn` 的函数不能返回 `None`",
        "nonDefaultAfterDefault": "未指定默认值的参数不应位于具有默认值的参数后",
        "nonLocalInModule": "不允许在模块层级的代码块中使用 `nonlocal`",
        "nonLocalNoBinding": "找不到非局部 `nonlocal` 变量 \"{name}\" 的绑定",
        "nonLocalReassignment": "\"{name}\" 已在 `nonlocal` 声明之前赋值",
        "nonLocalRedefinition": "\"{name}\" 已声明为 `nonlocal`",
        "noneNotCallable": "无法调用 `None` 类型的对象",
        "noneNotIterable": "不能迭代 `None` 类型的对象",
        "noneNotSubscriptable": "不能取 `None` 类型对象的下标",
        "noneNotUsableWith": "`None` 类型的对象不能与 `with` 一起使用",
        "noneOperator": "`None` 不支持 \"{operator}\" 运算符",
        "noneUnknownMember": "`None` 没有 \"{name}\" 属性",
        "notRequiredArgCount": "`NotRequired` 之后应有且仅有一个类型参数",
        "notRequiredNotInTypedDict": "此上下文中不允许使用 `NotRequired`",
        "objectNotCallable": "\"{type}\" 类型的对象不可调用",
        "obscuredClassDeclaration": "\"{name}\" 类的声明被同名的声明覆盖",
        "obscuredFunctionDeclaration": "\"{name}\" 函数的声明被同名声明覆盖",
        "obscuredMethodDeclaration": "\"{name}\" 方法的声明被同名声明覆盖",
        "obscuredParameterDeclaration": "\"{name}\" 参数的声明被同名声明覆盖",
        "obscuredTypeAliasDeclaration": "\"{name}\" 类型别名的声明被同名声明覆盖",
        "obscuredVariableDeclaration": "\"{name}\" 变量声明被同名声明覆盖",
        "operatorLessOrGreaterDeprecated": "Python 3 不支持 `<>` 运算符；请改用 `!=`",
        "optionalExtraArgs": "`Optional` 后面应有一个类型参数",
        "orPatternIrrefutable": "`_` 模式仅允许作为 `|` 模式中的最后一个子模式",
        "orPatternMissingName": "`|` 模式中的所有子节点必须以相同的名称为目标",
        "overlappingKeywordArgs": "`TypedDict` 与以下关键字参数重复：{names}",
        "overlappingOverload": "永远不会使用 \"{name}\" 的重载 {obscured}，因为其参数已被重载 {obscuredBy} 涵盖",
        "overloadAbstractImplMismatch": "重载必须符合实现的抽象状态",
        "overloadAbstractMismatch": "重载必须全部为抽象重载或全部为非抽象重载",
        "overloadClassMethodInconsistent": "\"{name}\" 的重载使用 `@classmethod` 的方式不一致",
        "overloadFinalInconsistencyImpl": "\"{name}\" 的重载声明与实际实现均应使用 `@final` 装饰",
        "overloadFinalInconsistencyNoImpl": "\"{name}\" 的第 1 个重载应和第 {index} 个重载一同被 `@final` 装饰",
        "overloadImplementationMismatch": "重载实现与第 {index} 个重载的签名不一致",
        "overloadReturnTypeMismatch": "\"{name}\" 的第 {prevIndex} 个重载与第 {newIndex} 个重载重复，且各自返回值的类型不相兼容",
        "overloadStaticMethodInconsistent": "\"{name}\" 的重载使用 `@staticmethod` 的方式不一致",
        "overloadWithoutImplementation": "\"{name}\" 重载缺少实现",
        "overriddenMethodNotFound": "\"{name}\" 方法已经用 `@override` 装饰，但基类中不存在同名方法",
        "overrideDecoratorMissing": "\"{name}\" 方法没有用 `@override` 装饰，但覆写了 \"{className}\" 类中的方法",
        "paramAfterKwargsParam": "`**` 参数后不应再有参数",
        "paramAlreadyAssigned": "\"{name}\" 参数已赋值",
        "paramAnnotationMissing": "\"{name}\" 参数缺少类型注解",
        "paramAssignmentMismatch": "无法将 \"{sourceType}\" 类型的表达式赋值给 \"{paramType}\" 类型的参数",
        "paramNameMissing": "缺少名为 \"{name}\" 的参数",
        "paramSpecArgsKwargsUsage": "`ParamSpec` 的 `args` 和 `kwargs` 属性必须同时出现在函数签名中",
        "paramSpecArgsMissing": "缺少 `ParamSpec` \"{type}\" 的参数",
        "paramSpecArgsUsage": "`ParamSpec` 的 `args` 属性仅在与 `*args` 参数一起使用时有效",
        "paramSpecAssignedName": "必须将 `ParamSpec` 赋值给名为 \"{name}\" 的变量",
        "paramSpecContext": "此上下文中不允许使用 `ParamSpec`",
        "paramSpecDefaultNotTuple": "`ParamSpec` 的默认值应为 `...`、元组表达式或 `ParamSpec`",
        "paramSpecFirstArg": "`ParamSpec` 实例化的第一个参数应为其名称",
        "paramSpecKwargsUsage": "`ParamSpec` 的 `kwargs` 属性仅在与 `**kwargs` 参数一起使用时有效",
        "paramSpecNotUsedByOuterScope": "`ParamSpec` \"{name}\" 在此上下文中没有意义",
        "paramSpecUnknownArg": "`ParamSpec` 不支持传入多个参数",
        "paramSpecUnknownMember": "`ParamSpec` 没有 \"{name}\" 属性",
        "paramSpecUnknownParam": "`ParamSpec` 没有 \"{name}\" 参数",
        "paramTypeAny": "\"{paramName}\" 参数类型为 `Any`",
        "paramTypeCovariant": "参数中的类型变量不能为协变",
        "paramTypePartiallyUnknown": "\"{paramName}\" 参数的类型部分未知",
        "paramTypeUnknown": "\"{paramName}\" 参数的类型未知",
        "parenthesizedContextManagerIllegal": "`with` 语句中使用括号需要 Python 3.9 或更高版本",
        "patternNeverMatches": "主体类型 \"{type}\" 的模式永远不会匹配",
        "positionArgAfterNamedArg": "位置参数不能出现在关键字参数之后",
        "positionOnlyAfterArgs": "`*` 参数后不允许使用仅位置参数分隔符",
        "positionOnlyAfterKeywordOnly": "分隔符 `/` 必须出现在 `*` 分隔符或参数之前",
        "positionOnlyAfterNon": "非仅位置参数后面不允许仅位置参数",
        "positionOnlyFirstParam": "不允许将仅位置参数分隔符 `/` 用作第一个参数",
        "positionOnlyIncompatible": "仅位置参数分隔符需要 Python 3.8 或更高版本",
        "privateImportFromPyTypedModule": "未从模块 \"{module}\" 导出 \"{name}\"",
        "privateUsedOutsideOfClass": "私有符号 \"{name}\" 在声明它的类之外使用",
        "privateUsedOutsideOfModule": "私有符号 \"{name}\" 在声明它的模块之外使用",
        "propertyOverridden": "\"{name}\" 错误地覆写了类 \"{className}\" 中的同名属性",
        "propertyStaticMethod": "属性 `getter`、`setter` 或 `deleter` 不允许使用静态方法",
        "protectedUsedOutsideOfClass": "\"{name}\" 在声明它受到保护的类之外被使用",
        "protocolBaseClass": "协议类 \"{classType}\" 不能派生自非协议类 \"{baseType}\"",
        "protocolBaseClassWithTypeArgs": "协议类不允许使用类型参数语法声明类型参数",
        "protocolIllegal": "使用 \"Protocol\" 需要 Python 3.7 或更高版本",
        "protocolNotAllowed": "\"Protocol\" 不能用于此上下文",
        "protocolTypeArgMustBeTypeParam": "不能向 \"Protocol\" 传入除 `TypeVar`、`TypeVarTuple`、`ParamSpec` 以外的类型参数",
        "protocolUnsafeOverlap": "类与 \"{name}\" 不安全的重叠，并且可能在运行时生成匹配项",
        "protocolVarianceContravariant": "协议类 \"{class}\" 中使用的类型变量 \"{variable}\" 应为逆变（`Contravariant`）形式",
        "protocolVarianceCovariant": "协议类 \"{class}\" 中使用的类型变量 \"{variable}\" 应为协变（`Covariant`）形式",
        "protocolVarianceInvariant": "协议类 \"{class}\" 中使用的类型变量 \"{variable}\" 应为不变（`Invariant`）形式",
        "pyrightCommentInvalidDiagnosticBoolValue": "Pyright 注释指令后面必须跟有 `=` 和一个设作 true 或 false 的值",
        "pyrightCommentInvalidDiagnosticSeverityValue": "Pyright 注释指令后面必须跟有 `=` 和一个设作 true、false、error、warning、information 或 none 的值",
        "pyrightCommentMissingDirective": "该 Pyright 注释的内容必须是诊断级别（basic 或 strict）或诊断规则",
        "pyrightCommentNotOnOwnLine": "Pyright 的文件级注释应独立成行。",
        "pyrightCommentUnknownDiagnosticRule": "Pyright 注释引用了一个未知的诊断规则 \"{rule}\"",
        "pyrightCommentUnknownDiagnosticSeverityValue": "无效的 Pyright 注释值 \"{value}\"；应为 true、false、error、warning、information 或 none",
        "pyrightCommentUnknownDirective": "Pyright 注释没有 \"{directive}\" 指令；应为 `strict` 或 `basic`",
        "readOnlyArgCount": "`ReadOnly` 后应有且仅有一个类型参数",
        "readOnlyNotInTypedDict": "此上下文中不允许使用 `ReadOnly`",
        "recursiveDefinition": "无法确定 \"{name}\" 的类型，因为它引用了其自身",
        "relativeImportNotAllowed": "相对导入不能与 `import .a` 形式一起使用：改用 `from . import a`",
        "requiredArgCount": "`Required` 后应有且仅有一个类型参数",
        "requiredNotInTypedDict": "此上下文中不允许使用 `Required`",
        "returnInAsyncGenerator": "异步生成器的函数体中不允许带返回值的 `return` 语句",
        "returnMissing": "该函数标注了返回类型为 \"{returnType}\"，因此必须在所有代码路径上返回值",
        "returnOutsideFunction": "`return` 语句只能在函数中使用",
        "returnTypeContravariant": "逆变形式的类型变量不能用于返回类型",
        "returnTypeMismatch": "\"{exprType}\" 类型不匹配返回类型 \"{returnType}\"",
        "returnTypePartiallyUnknown": "返回类型 \"{returnType}\" 部分未知",
        "returnTypeUnknown": "返回类型未知",
        "revealLocalsArgs": "`reveal_locals` 调用不应有参数",
        "revealLocalsNone": "此作用域内不存在任何局部变量",
        "returnTypeAny": "返回类型为 `Any`",
        "revealTypeArgs": "`reveal_type` 调用应仅传递一个位置参数",
        "revealTypeExpectedTextArg": "函数 `reveal_type` 的 `expected_text` 参数必须是 `str` 字面量",
        "revealTypeExpectedTextMismatch": "类型字面量不匹配；预期为 \"{expected}\" 但收到 \"{received}\"",
        "revealTypeExpectedTypeMismatch": "类型不匹配；预期为 \"{expected}\" 但收到 \"{received}\"",
        "selfTypeContext": "`Self` 在此上下文中无效",
        "selfTypeMetaclass": "`Self` 不能在元类（即 `type` 的子类）中使用",
        "selfTypeWithTypedSelfOrCls": "已指定 `self` 或 `cls` 参数上类型的函数中不可使用 Self",
        "setterGetterTypeMismatch": "属性的 `setter` 值类型不匹配 `getter` 返回类型",
        "singleOverload": "\"{name}\" 被声明为重载，但未定义其他重载",
        "slotsAttributeError": "未在 `__slots__` 中指定 \"{name}\"",
        "slotsClassVarConflict": "\"{name}\" 与 `__slots__` 中声明的实例属性存在冲突",
        "starPatternInAsPattern": "不能给解包模式表达式起别名",
        "starPatternInOrPattern": "解包模式表达式不能与同其他进行 `|` 操作的模式使用",
        "starStarWildcardNotAllowed": "`**` 不能与通配符 `_` 一起使用",
        "staticClsSelfParam": "静态方法不应采用 `self` 或 `cls` 参数",
        "stdlibModuleOverridden": "\"{path}\" 覆盖了标准库模块 \"{name}\"",
        "stringNonAsciiBytes": "不允许使用含有非 ASCII 字符（以字节为单位）的字符串字面量",
        "stringNotSubscriptable": "不能对着字符串形式的类型注解取下标；建议将整个注解括在引号中",
        "stringUnsupportedEscape": "字符串字面量中有不受支持的转义序列",
        "stringUnterminated": "字符串未终止",
        "stubFileMissing": "找不到 \"{importName}\" 的存根文件",
        "stubUsesGetAttr": "类型存根文件不完整；`__getattr__` 会掩盖模块的类型错误",
        "sublistParamsIncompatible": "Python 3.x 不支持 sublist 参数",
        "superCallArgCount": "`super` 调用不应多于两个参数",
        "superCallFirstArg": "`super` 调用的第一个参数应为类的类型而非 \"{type}\" 类型",
        "superCallSecondArg": "`super` 调用的第二个参数必须是继承自 \"{type}\" 的对象或类",
        "superCallZeroArgForm": "`super` 调用的零参数形式仅在方法中有效",
        "superCallZeroArgFormStaticMethod": "`super` 的无参数调用形式在静态方法中无效",
        "symbolIsPossiblyUnbound": "\"{name}\" 可能未绑定",
        "symbolIsUnbound": "\"{name}\" 未绑定",
        "symbolIsUndefined": "\"{name}\" 未定义",
        "symbolOverridden": "\"{name}\" 覆写了 \"{className}\" 类中的同名符号",
        "ternaryNotAllowed": "类型注解中不允许使用三元表达式",
        "totalOrderingMissingMethod": "类必须定义 `__lt__`、`__le__`、`__gt__` 或 `__ge__` 之一才能使用 `@total_ordering`",
        "trailingCommaInFromImport": "括号外不允许使用尾随逗号",
        "tryWithoutExcept": "`Try` 语句必须至少有一个 `except` 或 `finally` 子句",
        "tupleAssignmentMismatch": "无法将类型为 \"{type}\" 的表达式赋值给目标元组",
        "tupleInAnnotation": "类型注解中不允许使用元组表达式",
        "tupleIndexOutOfRange": "对 \"{type}\" 类型使用的索引值 \"{index}\" 超出了取值范围",
        "typeAliasIllegalExpressionForm": "定义 `TypeAlias` 时使用的表达式形式无效",
        "typeAliasIsRecursiveDirect": "`TypeAlias` \"{name}\" 不能在其定义中引用自身",
        "typeAliasNotInModuleOrClass": "`TypeAlias` 只能在模块或类范围内定义",
        "typeAliasRedeclared": "声明为 `TypeAlias` 的 \"{name}\" 只能赋值一次",
        "typeAliasStatementBadScope": "`type` 语句只能在模块或类范围内使用",
        "typeAliasStatementIllegal": "`type` 语句需要 Python 3.12 或更高版本",
        "typeAliasTypeBaseClass": "`type` 语句中定义的类型别名不能用作基类",
        "typeAliasTypeMustBeAssigned": "必须将 `TypeAliasType` 赋值给与类型别名同名的变量",
        "typeAliasTypeNameArg": "`TypeAliasType` 的第一个参数必须是表示类型别名名称的字符串字面量",
        "typeAliasTypeNameMismatch": "`TypeAlias` 的名称必须与赋值到的变量的名称相匹配",
        "typeAliasTypeParamInvalid": "类型参数列表必须是仅包含 `TypeVar`、`TypeVarTuple` 或 `ParamSpec` 的元组",
        "typeAnnotationCall": "类型表达式中不允许函数调用",
        "typeAnnotationVariable": "类型表达式中不允许使用变量",
        "typeAnnotationWithCallable": "\"type\" 上的类型参数必须传递一个类而非 `Callable` 类型",
        "typeAny": "\"{name}\" 的类型为 `Any`",
        "typeArgListExpected": "应为 `ParamSpec`、`...` 或类型列表",
        "typeArgListNotAllowed": "不允许此类型参数使用列表表达式",
        "typeArgsExpectingNone": "\"{name}\" 类不应有类型参数",
        "typeArgsMismatchOne": "应为一个类型参数而非 {received}",
        "typeArgsMissingForAlias": "\"{name}\" 泛型类型别名应有类型参数",
        "typeArgsMissingForClass": "\"{name}\" 泛型类应有类型参数",
        "typeArgsTooFew": "为 \"{name}\" 提供的类型参数太少：应有 {expected} 个，但只有 {received} 个",
        "typeArgsTooMany": "为 \"{name}\" 提供的类型参数太多：应有 {expected} 个，但有 {received} 个",
        "typeAssignmentMismatch": "\"{sourceType}\" 类型不匹配声明的 \"{destType}\" 类型",
        "typeAssignmentMismatchWildcard": "\"{name}\" 导入符号的类型为 \"{sourceType}\"，与声明的 \"{destType}\" 类型不兼容",
        "typeCallNotAllowed": "`type()` 调用不应用于类型注解",
        "typeCheckOnly": "\"{name}\" 已被 `@type_check_only` 装饰，只能在类型注解中使用",
        "typeCommentDeprecated": "类型注释已弃用；请改用类型注解",
        "typeExpectedClass": "此处应为类而非 \"{type}\"",
        "typeFormArgs": "\"TypeForm\" 仅接受一个位置参数",
        "typeGuardArgCount": "\"TypeGuard\" 或 \"TypeIs\" 后应为单个类型参数",
        "typeGuardParamCount": "用户定义的类型保护器函数和方法必须至少有一个输入参数",
        "typeIsReturnType": "`TypeIs` 的返回类型 \"{returnType}\" 与值参数类型 \"{type}\" 不一致",
        "typeNotAwaitable": "\"{type}\" 不能 `await`",
        "typeNotIntantiable": "\"{type}\" 不能实例化",
        "typeNotIterable": "\"{type}\" 不能迭代",
        "typeNotSpecializable": "\"{type}\" 类型无法特化",
        "typeNotSubscriptable": "\"{type}\" 类型的对象不能取下标",
        "typeNotSupportBinaryOperator": "\"{leftType}\" 与 \"{rightType}\" 类型不支持 \"{operator}\" 运算符",
        "typeNotSupportBinaryOperatorBidirectional": "预期类型为 \"{expectedType}\" 时，\"{leftType}\" 类型和 \"{rightType}\" 类型不支持 \"{operator}\" 运算符",
        "typeNotSupportUnaryOperator": "\"{type}\" 类型不支持 \"{operator}\" 运算符",
        "typeNotSupportUnaryOperatorBidirectional": "预期类型为 \"{expectedType}\" 时，\"{type}\" 类型不支持 \"{operator}\" 运算符",
        "typeNotUsableWith": "\"{type}\" 类型的对象不能与 `with` 一起使用，因为它未实现 \"{method}\"",
        "typeParameterBoundNotAllowed": "绑定或约束不能与可变类型参数或 `ParamSpec` 一起使用",
        "typeParameterConstraintTuple": "类型参数约束必须为含至少两个类型的元组",
        "typeParameterExistingTypeParameter": "\"{name}\" 类型参数已使用",
        "typeParameterNotDeclared": "\"{name}\" 类型参数未包含在 \"{container}\" 的类型参数列表中",
        "typeParametersMissing": "必须指定至少一个类型参数",
        "typePartiallyUnknown": "\"{name}\" 的类型部分未知",
        "typeUnknown": "\"{name}\" 类型未知",
        "typeVarAssignedName": "必须将 `TypeVar` 赋值给名为 \"{name}\" 的变量",
        "typeVarAssignmentMismatch": "无法将 \"{type}\" 类型赋值给类型变量 \"{name}\"",
        "typeVarBoundAndConstrained": "`TypeVar` 不能同时具有绑定和约束",
        "typeVarBoundGeneric": "`TypeVar` 绑定类型不能是泛型",
        "typeVarConstraintGeneric": "`TypeVar` 约束类型不能是泛型",
        "typeVarDefaultBoundMismatch": "`TypeVar` 默认类型必须是绑定类型的子类型",
        "typeVarDefaultConstraintMismatch": "`TypeVar` 默认类型必须是受约束类型之一",
        "typeVarDefaultIllegal": "类型变量默认类型需要 Python 3.13 或更高版本",
        "typeVarDefaultInvalidTypeVar": "\"{name}\" 类型参数的默认类型是指超出范围的一个或多个类型变量",
        "typeVarFirstArg": "`TypeVar` 的第一个参数应为其名称",
        "typeVarInvalidForMemberVariable": "属性的类型不能使用局部方法作用域内的类型变量 \"{name}\"",
        "typeVarNoMember": "`TypeVar` \"{type}\" 没有 \"{name}\" 属性",
        "typeVarNotSubscriptable": "`TypeVar` \"{type}\" 不能取下标",
        "typeVarNotUsedByOuterScope": "\"{name}\" 类型变量在此上下文中没有意义",
        "typeVarPossiblyUnsolvable": "如果调用方没有为 \"{param}\" 形参提供实参，则 \"{name}\" 类型变量可能无法解析",
        "typeVarSingleConstraint": "`TypeVar` 必须有至少两种约束类型",
        "typeVarTupleConstraints": "`TypeVarTuple` 不能有值约束",
        "typeVarTupleContext": "此上下文中不允许使用 `TypeVarTuple`",
        "typeVarTupleDefaultNotUnpacked": "`TypeVarTuple` 默认类型必须是已解包的元组或 `TypeVarTuple`",
        "typeVarTupleMustBeUnpacked": "`TypeVarTuple` 值需要解包操作符",
        "typeVarTupleUnknownParam": "`TypeVarTuple` 没有 \"{name}\" 参数",
        "typeVarUnknownParam": "`TypeVar` 没有 \"{name}\" 参数",
        "typeVarUsedByOuterScope": "`TypeVar` \"{name}\" 已被外部作用域使用",
        "typeVarUsedOnlyOnce": "`TypeVar` \"{name}\" 在泛型函数签名中仅出现了一次",
        "typeVarVariance": "`TypeVar` 不能同时为协变和逆变",
        "typeVarWithDefaultFollowsVariadic": "`TypeVar` \"{typeVarName}\" 具有默认值，不能跟在 `TypeVarTuple` \"{variadicName}\" 之后",
        "typeVarWithoutDefault": "\"{name}\" 不能出现在类型参数列表的 \"{other}\" 后面，因为它没有默认类型",
        "typeVarsNotInGenericOrProtocol": "`Generic[]` 或 `Protocol[]` 必须包括所有类型变量",
        "typedDictAccess": "无法访问 `TypedDict` 中的项",
        "typedDictAssignedName": "必须将 `TypedDict` 赋值给名为 \"{name}\" 的变量",
        "typedDictBadVar": "`TypedDict` 类只能包含类型注解",
        "typedDictBaseClass": "`TypedDict` 类的所有基类也必须是 `TypedDict` 类",
        "typedDictBoolParam": "\"{name}\" 参数的值应为 `True` 或 `False`",
        "typedDictClosedExtras": "\"{name}\" 基类是封闭的 `TypedDict`；额外的项必须为 \"{type}\" 类型",
        "typedDictClosedNoExtras": "\"{name}\" 基类是封闭的 `TypedDict`；不允许使用额外的项",
        "typedDictDelete": "无法删除 `TypedDict` 中的项",
        "typedDictEmptyName": "`TypedDict` 中的名称不能为空",
        "typedDictEntryName": "字典项名称应为字符串字面量",
        "typedDictEntryUnique": "字典项名称必须唯一",
        "typedDictExtraArgs": "不支持额外的 `TypedDict` 参数",
        "typedDictFieldNotRequiredRedefinition": "无法将 `TypedDict` 项 \"{name}\" 重新定义为 `NotRequired`",
        "typedDictFieldReadOnlyRedefinition": "无法将 `TypedDict` 项 \"{name}\" 重新定义为 `ReadOnly`",
        "typedDictFieldRequiredRedefinition": "无法将 `TypedDict` 项 \"{name}\" 重新定义为 `Required`",
        "typedDictFirstArg": "`TypedDict` 的第一个参数应为类名",
        "typedDictInClassPattern": "类模式中不允许使用 TypedDict 类",
        "typedDictInitsubclassParameter": "`TypedDict` 不支持 `__init_subclass__` 的 \"{name}\" 参数",
        "typedDictNotAllowed": "`TypedDict` 不能用于此上下文",
        "typedDictSecondArgDict": "第二个参数应为字典或关键字参数",
        "typedDictSecondArgDictEntry": "此处应为简单字典项",
        "typedDictSet": "无法在 `TypedDict` 中赋值项",
        "unaccessedClass": "\"{name}\" 类未使用",
        "unaccessedFunction": "\"{name}\" 函数未使用",
        "unaccessedImport": "\"{name}\" 导入项未使用",
        "unaccessedSymbol": "\"{name}\" 未使用",
        "unaccessedVariable": "变量 \"{name}\" 未使用",
        "unannotatedFunctionSkipped": "已跳过对未标类型的函数 \"{name}\" 的分析",
        "unaryOperationNotAllowed": "类型注解中不允许使用一元运算符",
        "unexpectedAsyncToken": "`def`、`with` 或 `for` 应在 `async` 之后",
        "unexpectedExprToken": "表达式末尾有错误的 `Token`",
        "unexpectedIndent": "缩进有误",
        "unexpectedUnindent": "缩进退回有误",
        "unhashableDictKey": "字典键必须可以哈希",
        "unhashableSetEntry": "集合项必须可以哈希",
        "uninitializedAbstractVariables": "\"{classType}\" 终点类中没有初始化在抽象基类中定义的变量",
        "uninitializedInstanceVariable": "实例变量 \"{name}\" 未在类体或 `__init__` 方法中初始化",
        "unionForwardReferenceNotAllowed": "`Union` 的 `|` 语法不能与字符串值一起使用；请用引号包围整个表达式",
        "unionSyntaxIllegal": "`Union` 的替代语法需要 Python 3.10 或更高版本",
        "unionTypeArgCount": "`Union` 需要至少两个类型参数",
        "unionUnpackedTuple": "`Union` 不能含有已解包的元组",
        "unionUnpackedTypeVarTuple": "`Union` 不能含有已解包的 `TypeVarTuple`",
        "unnecessaryCast": "已为 \"{type}\" 类型，不需要调用 `cast`",
        "unnecessaryIsInstanceAlways": "\"{testType}\" 始终是 \"{classType}\" 的实例，不需要调用 `isinstance`",
        "unnecessaryIsInstanceNever": "\"{testType}\" 不可能是 \"{classType}\" 的实例，不需要调用 `isinstance`",
        "unnecessaryIsSubclassAlways": "\"{testType}\" 始终是 \"{classType}\" 的子类，不需要调用 `issubclass`",
        "unnecessaryIsSubclassNever": "\"{testType}\" 不可能是 \"{classType}\" 的子类，不需要调用 `issubclass`",
        "unnecessaryPyrightIgnore": "无需 `# pyright: ignore` 注释",
        "unnecessaryPyrightIgnoreRule": "无需 `# pyright: ignore` 规则：\"{name}\"",
        "unnecessaryTypeIgnore": "无需 `# type: ignore` 注释",
        "unpackArgCount": "`Unpack` 后应有且仅有一个类型参数",
        "unpackExpectedTypeVarTuple": "`Unpack` 需要 `TypeVarTuple` 或元组类型参数",
        "unpackExpectedTypedDict": "`Unpack` 需要 `TypedDict` 类型参数",
        "unpackIllegalInComprehension": "推导式中不允许解包操作",
        "unpackInAnnotation": "类型注解中不允许解包操作符",
        "unpackInDict": "字典中不允许解包操作",
        "unpackInSet": "集合内不允许解包操作符",
        "unpackNotAllowed": "此上下文中不允许使用 `Unpack`",
        "unpackOperatorNotAllowed": "此上下文中不允许解包操作",
        "unpackTuplesIllegal": "在 Python 3.8 之前，元组中不允许解包操作",
        "unpackedArgInTypeArgument": "类型参数列表中无法使用已解包的参数",
        "unpackedArgWithVariadicParam": "已解包的参数不能用于 `TypeVarTuple` 参数",
        "unpackedDictArgumentNotMapping": "`**` 后面的参数表达式必须是具有 `str` 键类型的映射",
        "unpackedDictSubscriptIllegal": "下标中不允许使用字典解包操作符",
        "unpackedSubscriptIllegal": "下标中使用解包操作符需要 Python 3.11 或更高版本",
        "unpackedTypeVarTupleExpected": "此处应为已解包的 `TypeVarTuple`；使用 Unpack[{name1}] 或 *{name2}",
        "unpackedTypedDictArgument": "无法将已解包的 `TypedDict` 实参与形参匹配",
        "unreachableCode": "代码不会被执行",
        "unreachableCodeType": "类型分析表明代码不会被执行",
        "unreachableExcept": "`except` 子句不会被执行，因为异常已处理",
        "unsupportedDunderAllOperation": "不支持识别对 `__all__` 执行的复杂操作，因此导出符号列表可能不正确",
        "unusedCallResult": "\"{type}\" 类型调用表达式的结果未使用。如果确有必要，应赋值给变量 `_`",
        "unusedCoroutine": "异步函数调用的结果未使用。请对结果使用 `await` 或将其赋值给变量",
        "unusedExpression": "表达式值未使用",
        "varAnnotationIllegal": "变量的类型注解需要 Python 3.6 或更高版本；使用类型注释可以与以前的版本兼容",
        "variableFinalOverride": "\"{name}\" 变量被标记为 `Final`，覆写了 \"{className}\" 类中同名的非 `Final` 变量",
        "variadicTypeArgsTooMany": "类型参数列表最多可以有一个已解包的 `TypeVarTuple` 或元组",
        "variadicTypeParamTooManyAlias": "类型别名最多可以有一个 `TypeVarTuple` 类型参数，但收到多个（{names}）",
        "variadicTypeParamTooManyClass": "泛型类最多可以有一个 `TypeVarTuple` 类型参数，但收到多个（{names}）",
        "walrusIllegal": "`:=` 运算符需要 Python 3.8 或更高版本",
        "walrusNotAllowed": "此上下文中不允许不带括号使用 `:=` 运算符",
        "wildcardInFunction": "类或函数中不允许使用通配符导入",
        "wildcardLibraryImport": "不允许使用通配符从库中导入",
        "wildcardPatternTypeAny": "通配符模式捕获的类型为 `Any`",
        "wildcardPatternTypePartiallyUnknown": "通配符模式捕获的类型部分未知",
        "wildcardPatternTypeUnknown": "通配符模式捕获的类型未知",
        "yieldFromIllegal": "使用 `yield from` 需要 Python 3.3 或更高版本",
        "yieldFromOutsideAsync": "异步函数中不允许使用 `yield from`",
        "yieldOutsideFunction": "不允许在函数或 `lambda` 之外使用 `yield`",
        "yieldWithinComprehension": "允许在推导式中使用 `yield`",
        "zeroCaseStatementsFound": "`match` 语句必须至少包含一个 `case` 语句",
        "zeroLengthTupleNotAllowed": "此上下文中不允许使用零长度元组",
        "pyrightIgnoreCommentWithoutRule": "`pyright: ignore` 注释必须指定具体规则（例如 `# pyright: ignore[ruleName]`）",
        "typeIgnoreCommentWithoutRule": "`type: ignore` 注释必须指定具体规则（例如 `# type: ignore[ruleName]`）",
        "implicitRelativeImport": "从 \"{importName}\" 导入会进行隐式的相对导入，如果此文件作为模块导入则会出错",
        "invalidCast": "从 \"{fromType}\" 类型到 \"{toType}\" 类型的转换可能有误，这两个类型不完全重叠。如果确有必要，请先将其转换为 `object`。",
        "multipleInheritance": "当前的基类无法进行多继承；因为基类 \"{classes}\" 具有的 `__init__` 或 `__new__` 方法可能不会被执行"
    },
    "DiagnosticAddendum": {
        "annotatedNotAllowed": "特化的 `Annotated` 形式不能用于 `isinstance()` 或 `issubclass()`",
        "argParam": "实参对应于 \"{paramName}\" 形参",
        "argParamFunction": "实参对应于 \"{functionName}\" 函数中的 \"{paramName}\" 形参",
        "argsParamMissing": "\"*{paramName}\" 形参没有相应的实参",
        "argsPositionOnly": "仅位置参数不匹配；应为 {expected} 而非 {received}",
        "argumentType": "参数类型为 \"{type}\"",
        "argumentTypes": "参数类型：({types})",
        "assignToNone": "类型与 `None` 不匹配",
        "asyncHelp": "你指的是 `async with` 吗？",
        "baseClassIncompatible": "\"{baseClass}\" 基类与 \"{type}\" 类型不兼容",
        "baseClassIncompatibleSubclass": "\"{baseClass}\" 基类继承自与 \"{type}\" 类型不兼容的 \"{subclass}\"",
        "baseClassOverriddenType": "\"{baseClass}\" 基类提供了被覆写的 \"{type}\" 类型",
        "baseClassOverridesType": "\"{baseClass}\" 基类覆写了 \"{type}\" 类型",
        "bytesTypePromotions": "将 disableBytesTypePromotions 设置为 false 以启用 \"bytearray\" 和 \"memoryview\" 的类型提升行为",
        "conditionalRequiresBool": "\"{operandType}\" 类型的方法 `__bool__` 返回 \"{boolReturnType}\" 类型而不是 `bool`",
        "dataClassFieldLocation": "字段声明",
        "dataClassFrozen": "\"{name}\" 已冻结",
        "dataProtocolUnsupported": "\"{name}\" 是数据协议",
        "descriptorAccessBindingFailed": "无法绑定 \"{className}\" 描述器类的 \"{name}\" 方法",
        "descriptorAccessCallFailed": "无法调用 \"{className}\" 描述器类的 \"{name}\" 方法",
        "finalMethod": "`Final` 方法",
        "functionParamDefaultMissing": "\"{name}\" 形参缺少默认参数",
        "functionParamName": "参数名称不匹配：\"{destName}\" 与 \"{srcName}\"",
        "functionParamPositionOnly": "仅位置参数不匹配; 参数 \"{name}\" 并非仅位置参数",
        "functionReturnTypeMismatch": "函数返回 \"{sourceType}\" 类型与 \"{destType}\" 类型不兼容",
        "functionTooFewParams": "函数接受的位置参数太少：应传入 {expected} 个，但只接受到 {received} 个",
        "functionTooManyParams": "函数接受的位置参数太多：应传入 {expected} 个，却接受到了 {received} 个",
        "genericClassNotAllowed": "具有类型参数的泛型类型不得用于 `isinstance()` 或 `issubclass()`",
        "incompatibleDeleter": "属性的 `deleter` 方法不兼容",
        "incompatibleGetter": "属性的 `getter` 方法不兼容",
        "incompatibleSetter": "属性的 `setter` 方法不兼容",
        "initMethodLocation": "`__init__` 方法已在 \"{type}\" 类中定义",
        "initMethodSignature": "`__init__` 的签名为 \"{type}\"",
        "initSubclassLocation": "`__init_subclass__` 方法已在 \"{name}\" 类中定义",
        "invariantSuggestionDict": "请考虑从 `dict` 切换到值类型为协变的 `Mapping`",
        "invariantSuggestionList": "请考虑从 `list` 切换到协变的 `Sequence`",
        "invariantSuggestionSet": "请考虑从 `set` 切换到协变的 `Container`",
        "isinstanceClassNotSupported": "不支持对 \"{type}\" 使用 `isinstance()` 或 `issubclass()`",
        "keyNotRequired": "\"{type}\" 中 \"{name}\" 不是必需的键，因此获取其值可能会导致运行时异常",
        "keyReadOnly": "\"{name}\" 是 \"{type}\" 中的只读键",
        "keyRequiredDeleted": "\"{name}\" 是必需的键，无法删除",
        "keyUndefined": "\"{name}\" 不是 \"{type}\" 中定义的键",
        "kwargsParamMissing": "\"**{paramName}\" 形参没有相应的实参",
        "listAssignmentMismatch": "\"{type}\" 类型与目标列表不兼容",
        "literalAssignmentMismatch": "\"{sourceType}\" 与 \"{destType}\" 类型不兼容",
        "matchIsNotExhaustiveHint": "如果不进行完全处理，请添加 `case _: pass`",
        "matchIsNotExhaustiveType": "未处理的类型：\"{type}\"",
        "memberAssignment": "无法将 \"{type}\" 类型的表达式赋值给 \"{classType}\" 类的 \"{name}\" 属性",
        "memberIsAbstract": "未实现 \"{type}.{name}\"",
        "memberIsAbstractMore": "还有 {count} 个...",
        "memberIsClassVarInProtocol": "\"{name}\" 在协议中定义为 `ClassVar`",
        "memberIsInitVar": "\"{name}\" 被标记为 `InitVar`，仅能用于 `__init__` 和 `__post_init__`",
        "memberIsInvariant": "可变成员 \"{name}\" 的类型应为不变（Invariant）",
        "memberIsNotClassVarInClass": "\"{name}\" 必须定义为 `ClassVar` 才能与协议类兼容",
        "memberIsNotClassVarInProtocol": "\"{name}\" 未在协议类中定义为 `ClassVar`",
        "memberIsNotReadOnlyInProtocol": "\"{name}\" 在协议类中并非只读",
        "memberIsReadOnlyInProtocol": "\"{name}\" 在协议类中只读",
        "memberIsWritableInProtocol": "\"{name}\" 在协议类中是可写入的",
        "memberSetClassVar": "无法通过类实例赋值 `ClassVar` 属性 \"{name}\"",
        "memberTypeMismatch": "\"{name}\" 类型不兼容",
        "memberUnknown": "属性 \"{name}\" 未知",
        "metaclassConflict": "元类 \"{metaclass1}\" 与 \"{metaclass2}\" 存在冲突",
        "missingDeleter": "属性缺少 `deleter` 方法",
        "missingGetter": "属性缺少 `getter` 方法",
        "missingSetter": "属性缺少 `setter` 方法",
        "namedParamMissingInDest": "额外的参数 \"{name}\"",
        "namedParamMissingInSource": "缺少关键字参数 \"{name}\"",
        "namedParamTypeMismatch": "\"{sourceType}\" 类型的关键字参数 \"{name}\" 与 \"{destType}\" 类型不兼容",
        "namedTupleNotAllowed": "不能对实例或类检查使用 `NamedTuple`",
        "newMethodLocation": "`__new__` 方法已在类 \"{type}\" 中定义",
        "newMethodSignature": "`__new__` 的签名为 \"{type}\"",
        "newTypeClassNotAllowed": "不能将使用 `NewType` 创建的类用于实例和类检查",
        "noOverloadAssignable": "没有重载函数与 \"{type}\" 类型匹配",
        "noneNotAllowed": "`None` 不能参与 `isinstance()` 或 `issubclass()`",
        "orPatternMissingName": "缺少名称：{name}",
        "overloadIndex": "重载 {index} 是最接近的匹配项",
        "overloadNotAssignable": "\"{name}\" 的一个或多个重载无法分配",
        "overloadSignature": "此处定义了重载签名",
        "overriddenMethod": "被覆写的方法",
        "overriddenSymbol": "被覆写的符号",
        "overrideInvariantMismatch": "覆写的 \"{overrideType}\" 类型与基类型 \"{baseType}\" 不同",
        "overrideIsInvariant": "可变量的类型应为不变（Invariant）",
        "overrideNoOverloadMatches": "没有与基类方法兼容的重载签名覆写",
        "overrideNotClassMethod": "覆写的方法没有一致与基类方法声明为类方法",
        "overrideNotInstanceMethod": "覆写的方法没有一致与基类方法声明为实例方法",
        "overrideNotStaticMethod": "覆写的方法没有一致与基类方法声明为静态方法",
        "overrideOverloadNoMatch": "覆写的方法未完全处理基类方法的所有重载",
        "overrideOverloadOrder": "覆写的重载方法必须与基类方法的顺序相同",
        "overrideParamKeywordNoDefault": "关键字参数 \"{name}\" 不匹配：基类方法参数具有默认参数值，覆写方法的参数不匹配",
        "overrideParamKeywordType": "关键字参数 \"{name}\" 类型不匹配：基类方法参数类型为 \"{baseType}\" ，覆写方法的参数类型为 \"{overrideType}\"",
        "overrideParamName": "第 {index} 个参数名称不匹配：基类方法参数名称为 \"{baseName}\"，覆写方法的参数名称为 \"{overrideName}\"",
        "overrideParamNameExtra": "基类方法中缺少参数 \"{name}\"",
        "overrideParamNameMissing": "覆写方法中缺少参数 \"{name}\"",
        "overrideParamNamePositionOnly": "第 {index} 个参数不匹配：基类方法参数 \"{baseName}\" 是关键字参数，覆写方法参数为仅位置参数",
        "overrideParamNoDefault": "第 {index} 个参数不匹配：基类方法参数与覆写方法参数的默认值不匹配",
        "overrideParamType": "第 {index} 个参数类型不匹配：基类方法参数为 \"{baseType}\" 类型，覆写方法参数为 \"{overrideType}\" 类型",
        "overridePositionalParamCount": "位置参数个数不匹配：基类方法有 {baseCount} 个，但覆写方法有 {overrideCount} 个",
        "overrideReturnType": "返回类型不匹配：基类方法返回 \"{baseType}\" 类型，覆写方法返回 \"{overrideType}\" 类型",
        "overrideType": "基类将类型定义为 \"{type}\"",
        "paramAssignment": "第 {index} 个参数：\"{sourceType}\" 类型与 \"{destType}\" 类型不兼容",
        "paramSpecMissingInOverride": "覆写方法中缺少 `ParamSpec` 参数",
        "paramType": "参数为 \"{paramType}\" 类型",
        "privateImportFromPyTypedSource": "改为从 \"{module}\" 导入",
        "propertyAccessFromProtocolClass": "不能以类变量形式访问协议类中定义的属性",
        "propertyMethodIncompatible": "属性方法 \"{name}\" 不兼容",
        "propertyMethodMissing": "覆写中缺少属性方法 \"{name}\"",
        "propertyMissingDeleter": "属性 \"{name}\" 未定义删除方法",
        "propertyMissingSetter": "属性 \"{name}\" 未定义赋值方法",
        "protocolIncompatible": "\"{sourceType}\" 与协议类 \"{destType}\" 不兼容",
        "protocolMemberMissing": "\"{name}\" 不存在",
        "protocolRequiresRuntimeCheckable": "Protocol 类必须用 `@runtime_checkable` 装饰才能用于 `isinstance()` 和 `issubclass()`",
        "protocolSourceIsNotConcrete": "\"{sourceType}\" 不是具体类类型，无法赋值给 \"{destType}\" 类型",
        "protocolUnsafeOverlap": "\"{name}\" 的属性与协议类具有相同的名称",
        "pyrightCommentIgnoreTip": "使用 `# pyright: ignore[<diagnostic rules>]` 取消单行诊断",
        "readOnlyAttribute": "\"{name}\" 为只读属性",
        "seeClassDeclaration": "查看类声明",
        "seeDeclaration": "查看声明",
        "seeFunctionDeclaration": "查看函数声明",
        "seeMethodDeclaration": "查看方法声明",
        "seeParameterDeclaration": "查看参数声明",
        "seeTypeAliasDeclaration": "查看类型别名声明",
        "seeVariableDeclaration": "查看变量声明",
        "tupleAssignmentMismatch": "\"{type}\" 类型与目标元组不兼容",
        "tupleEntryTypeMismatch": "元组项 {entry} 的类型不正确",
        "tupleSizeIndeterminateSrc": "元组大小不匹配；应为 {expected} 而非不定长度元组",
        "tupleSizeIndeterminateSrcDest": "元组大小不匹配；至少应为 {expected} 而非不定长度元组",
        "tupleSizeMismatch": "元组大小不匹配；应为 {expected} 而非 {received}",
        "tupleSizeMismatchIndeterminateDest": "元组大小不匹配；至少应为 {expected} 而非 {received}",
        "typeAliasInstanceCheck": "使用 `type` 语句创建的类型别名不能用于 `isinstance()` 或 `issubclass()`",
        "typeAssignmentMismatch": "\"{sourceType}\" 类型与 \"{destType}\" 类型不兼容",
        "typeBound": "\"{sourceType}\" 类型与类型变量 \"{destType}\" 的绑定类型 \"{name}\" 不兼容",
        "typeConstrainedTypeVar": "\"{type}\" 类型与限定类型变量 \"{name}\" 不兼容",
        "typeIncompatible": "\"{sourceType}\" 与 \"{destType}\" 不兼容",
        "typeNotClass": "\"{type}\" 不是类",
        "typeNotStringLiteral": "\"{type}\" 不是字符串字面量",
        "typeOfSymbol": "\"{name}\" 为 \"{type}\" 类型",
        "typeParamSpec": "\"{type}\" 类型与 `ParamSpec` \"{name}\" 不兼容",
        "typeUnsupported": "\"{type}\" 类型不受支持",
        "typeVarDefaultOutOfScope": "类型变量 \"{name}\" 不在范围内",
        "typeVarIsContravariant": "类型参数 \"{name}\" 是逆变（`Contravariant`）的，但 \"{sourceType}\" 不是 \"{destType}\" 的超类型",
        "typeVarIsCovariant": "类型参数 \"{name}\" 是协变（`Covariant`）的，但 \"{sourceType}\" 不是 \"{destType}\" 的子类型",
        "typeVarIsInvariant": "类型参数 \"{name}\" 是不变（`Invariant`）的，但 \"{sourceType}\" 与 \"{destType}\" 不同",
        "typeVarNotAllowed": "`TypeVar` 不得用于 `isinstance()` 或 `issubclass()`",
        "typeVarTupleRequiresKnownLength": "`TypeVarTuple` 不能绑定到长度未知的元组",
        "typeVarUnnecessarySuggestion": "请改用 {type}",
        "typeVarUnsolvableRemedy": "提供一个重载，该重载指定未提供参数时的返回类型",
        "typeVarsMissing": "缺少类型变量：{names}",
        "typedDictBaseClass": "类 \"{type}\" 不是 `TypedDict`",
        "typedDictClassNotAllowed": "不允许对实例或类检查使用 `TypedDict` 类",
        "typedDictClosedExtraNotAllowed": "无法添加项 \"{name}\"",
        "typedDictClosedExtraTypeMismatch": "无法添加 \"{type}\" 类型的项 \"{name}\"",
        "typedDictClosedFieldNotRequired": "无法添加项 \"{name}\"，因为它必须是 `NotRequired`",
        "typedDictExtraFieldNotAllowed": "\"{type}\" 中不存在 \"{name}\"",
        "typedDictExtraFieldTypeMismatch": "\"{name}\" 的类型与 \"{type}\" 中的 `extra_items` 类型不兼容",
        "typedDictFieldMissing": "\"{type}\" 中缺少 \"{name}\"",
        "typedDictFieldNotReadOnly": "\"{name}\" 在 \"{type}\" 中不是只读的",
        "typedDictFieldNotRequired": "\"{type}\" 中不需要 \"{name}\"",
        "typedDictFieldRequired": "\"{type}\" 中需要 \"{name}\"",
        "typedDictFieldTypeMismatch": "类型 \"{type}\" 不可赋值给项 \"{name}\"",
        "typedDictFieldUndefined": "\"{name}\" 是类型 \"{type}\" 中的未定义项",
        "typedDictFinalMismatch": "\"{sourceType}\" 与 \"{destType}\" 不兼容，因为 @final 不匹配",
        "typedDictKeyAccess": "使用 [\"{name}\"] 引用 `TypedDict` 中的项",
        "typedDictNotAllowed": "`TypedDict` 不能用于 `isinstance()` 或 `issubclass()`",
        "unhashableType": "\"{type}\" 类型不可哈希",
        "uninitializedAbstractVariable": "实例变量 \"{name}\" 已在抽象基类 \"{classType}\" 中定义，但未初始化",
        "unreachableExcept": "\"{exceptionType}\" 是 \"{parentType}\" 的子类",
        "useDictInstead": "使用 `Dict[T1, T2]` 表示字典类型",
        "useListInstead": "使用 `List[T]` 表示列表类型或 `Union[T1, T2]` 表示示联合类型",
        "useTupleInstead": "使用 `tuple[T1, ..., Tn]` 表示元组类型或使用 `Union[T1, T2]` 表示联合类型",
        "useTypeInstead": "改用 `Type[T]`",
        "varianceMismatchForClass": "类型参数 \"{typeVarName}\" 的差异与基类 \"{className}\" 不兼容",
        "varianceMismatchForTypeAlias": "类型参数 \"{typeVarName}\" 的差异与 \"{typeAliasParam}\" 不兼容",
        "explicitRelativeImportSuggestion": "请改用 \".{importName}\" 作为相对导入",
        "fullPathImportSuggestion": "或指定完整模块路径：\"{importName}\""
    },
    "Service": {
        "longOperation": "枚举工作区源文件需要很长时间。请考虑打开子文件夹。[了解详细信息](https://aka.ms/workspace-too-many-files)"
    }
}
