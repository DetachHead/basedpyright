{
    "CodeAction": {
        "createTypeStub": "创建 Type Stub",
        "createTypeStubFor": "为“{moduleName}”创建 Type Stub",
        "executingCommand": "正在执行命令",
        "filesToAnalyzeCount": "{count} 个要分析的文件",
        "filesToAnalyzeOne": "1 个要分析的文件",
        "findingReferences": "正在查找引用",
        "organizeImports": "整理 Imports",
        "renameShadowedFile": "将“{oldFile}”重命名为“{newFile}”"
    },
    "Completion": {
        "autoImportDetail": "自动导入",
        "indexValueDetail": "索引值"
    },
    "Diagnostic": {
        "abstractMethodInvocation": "不能调用未实现的抽象方法“{method}”",
        "annotatedMetadataInconsistent": "Annotated metadata type \"{metadataType}\" is not compatible with type \"{type}\"",
        "annotatedParamCountMismatch": "参数标注数量不匹配: 应为 {expected} 个，但得到 {received} 个",
        "annotatedTypeArgMissing": "“Annotated”应有一个类型参数和至少一个标注",
        "annotationBytesString": "类型表达式不能使用字节字符串文本",
        "annotationFormatString": "类型表达式中不能使用 f-string",
        "annotationNotSupported": "不支持使用此语句作为类型注解",
        "annotationRawString": "类型表达式不能使用原始字符串文本",
        "annotationSpansStrings": "类型表达式不能跨越多个字符串字面量",
        "annotationStringEscape": "类型表达式不能包含转义字符",
        "argAssignment": "“{argType}”类型的实参无法赋值给“{paramType}”类型的形参",
        "argAssignmentFunction": "“{argType}”类型的实参无法赋值给函数“{functionName}”中“{paramType}”类型的形参",
        "argAssignmentParam": "“{argType}”类型的实参无法赋值给“{paramType}”类型的形参“{paramName}”",
        "argAssignmentParamFunction": "“{argType}”类型的实参无法赋值给函数“{functionName}”中“{paramType}”类型的形参“{paramName}”",
        "argMissingForParam": "{name} 没有传入值",
        "argMissingForParams": "{names} 没有传入值",
        "argMorePositionalExpectedCount": "还需要传入 {expected} 个位置参数",
        "argMorePositionalExpectedOne": "还需要传入 1 个位置参数",
        "argPositional": "需要传入位置参数",
        "argPositionalExpectedCount": "需要传入 {expected} 个位置参数",
        "argPositionalExpectedOne": "需要传入 1 个位置参数",
        "argTypePartiallyUnknown": "部分参数的类型未知（Unknown）",
        "argTypeAny": "参数类型为 Any",
        "argTypeUnknown": "参数类型未知（Unknown）",
        "assertAlwaysTrue": "断言（assert）的计算结果始终为 True",
        "assertTypeArgs": "“assert_type”需要传入两个位置参数",
        "assertTypeTypeMismatch": "“assert_type”不匹配：应是 “{expected}” 类型的值，但传入的值类型是 “{received}”",
        "assignmentExprComprehension": "海象运算符赋值的变量名 “{name}” 不能与推导式使用的变量重名",
        "assignmentExprContext": "海象运算符只能在模块、函数或 lambda 中使用",
        "assignmentExprInSubscript": "在下标（value[...]）中使用海象表达式需要 Python 3.10 或更高版本",
        "assignmentInProtocol": "必须在类中显式声明协议类中声明的实例变量或类变量",
        "assignmentTargetExpr": "表达式不能被赋值",
        "asyncNotInAsyncFunction": "异步函数之外不允许使用“async for/with/...”",
        "awaitIllegal": "使用“await”需要 Python 为 3.5 或更高版本",
        "awaitNotAllowed": "类型注解中不能使用“await”",
        "awaitNotInAsync": "仅允许在异步函数内使用“await”",
        "backticksIllegal": "Python 3.x 中不支持使用反引号包围的表达式；请改用 repr(...)",
        "baseClassCircular": "类不能继承自身",
        "baseClassFinal": "基类“{type}”被 @final 标记，因此不能被子类继承",
        "baseClassIncompatible": "{type} 的基类之间不相互兼容",
        "baseClassInvalid": "类的参数必须是基类",
        "baseClassAny": "Any 类型的基类覆盖了派生类的类型",
        "baseClassMethodTypeIncompatible": "“{classType}”类的基类以不兼容的方式定义方法“{name}”",
        "baseClassUnknown": "未知类型的基类覆盖了派生类的类型",
        "baseClassVariableTypeIncompatible": "“{classType}”类的基类以不兼容的方式定义变量“{name}”",
        "binaryOperationNotAllowed": "类型注解中不允许使用二元运算符",
        "bindTypeMismatch": "无法绑定方法“{methodName}”，因为“{type}”不能赋值给参数“{paramName}”",
        "breakOutsideLoop": "“break”只能在循环中使用",
        "callableExtraArgs": "“Callable”只能传入两个类型参数",
        "callableFirstArg": "此处应为参数类型列表或“...”",
        "callableNotInstantiable": "无法实例化“{type}”类型",
        "callableSecondArg": "返回类型应为“Callable”的第二个类型参数",
        "casePatternIsIrrefutable": "只有最后一个 case 语句允许使用模式“_”",
        "classAlreadySpecialized": "此泛型在定义时已被特化为“{type}”",
        "classDecoratorTypeAny": "返回 Any 类型的类装饰器覆盖了原始类的类型",
        "classDecoratorTypeUnknown": "未标注返回类型的类装饰器会覆盖原始类的类型，因此已忽略此装饰器",
        "classDefinitionCycle": "“{name}”类存在循环定义",
        "classGetItemClsParam": "重写的 __class_getitem__ 方法应使用“cls”参数",
        "classMethodClsParam": "类方法应使用“cls”参数",
        "classNotRuntimeSubscriptable": "在“{name}”类上使用的下标将导致运行时异常，应将这整个类型注解写成字符串形式",
        "classPatternBuiltInArgPositional": "当使用类本身进行模式匹配时，随后的括号内部只能接受位置参数形式的子模式",
        "classPatternPositionalArgCount": "“{type}”类的位置模式太多：应为 {expected}，但收到了 {received}",
        "classPatternTypeAlias": "无法在类模式中使用已特化的类型别名“{type}”",
        "classPropertyDeprecated": "装饰器 @classmethod + @property 的组合已在 Python 3.11 中弃用，并将在 Python 3.13 中删除",
        "classTypeParametersIllegal": "类的类型参数语法 (PEP 695) 需要 Python 3.12 或更高版本",
        "classVarFirstArgMissing": "“ClassVar”内应存在且仅存在一个类型参数",
        "classVarNotAllowed": "此上下文中不允许使用“ClassVar”",
        "classVarOverridesInstanceVar": "被标记为 ClassVar 的“{name}”覆盖了类“{className}”中的同名实例属性",
        "classVarTooManyArgs": "“ClassVar”内应存在且仅存在一个类型参数",
        "classVarWithTypeVar": "“ClassVar”的类型参数中不能包含类型变量 (TypeVar)",
        "clsSelfParamTypeMismatch": "参数“{name}”的类型必须是类“{classType}”或其基类",
        "codeTooComplexToAnalyze": "代码太过复杂以至于无法分析；请将其重构为多个小规模代码的组合，或减少条件代码路径来降低复杂度",
        "collectionAliasInstantiation": "无法实例化类型“{type}”，请改用“{alias}”",
        "comparisonAlwaysFalse": "条件的计算结果始终为 False，因为类型“{leftType}”和“{rightType}”之间不存在交集",
        "comparisonAlwaysTrue": "条件的计算结果始终为 True，因为类型“{leftType}”和“{rightType}”之间不存在交集",
        "comprehensionInDict": "字典推导式中不能混入其他字典项，建议使用形似“{**comprehension, key: value}”的形式",
        "comprehensionInSet": "集合推导式中不能混入其他集合项，建议使用形似“{*comprehension, item}”的形式",
        "concatenateContext": "该上下文中不允许使用“Concatenate”",
        "concatenateParamSpecMissing": "“Concatenate”的最后一个类型参数必须是 ParamSpec 或“...”",
        "concatenateTypeArgsMissing": "“Concatenate”中至少需要传入两个类型参数",
        "conditionalOperandInvalid": "非法的条件操作符类型 {type}",
        "constantRedefinition": "不能重新定义常量 “{name}” （名称全大写）",
        "constructorParametersMismatch": "“{classType}” 类中方法 __new__ 和 __init__ 的签名不匹配",
        "containmentAlwaysFalse": "表达式的计算结果始终为 False，因为类型 “{leftType}” 和 “{rightType}” 之间不存在交集",
        "containmentAlwaysTrue": "表达式的计算结果始终为 True，因为类型 “{leftType}” 和 “{rightType}” 之间不存在交集",
        "continueInFinally": "“continue” 不能在 finally 子句中使用",
        "continueOutsideLoop": "“continue” 只能在循环中使用",
        "coroutineInConditionalExpression": "条件表达式中使用未 await 的协程作为判断条件，其计算结果始终为 True",
        "dataClassBaseClassFrozen": "非冻结 (frozen=False) 的 dataclass 不能继承已冻结 (frozen=True) 的 dataclass",
        "dataClassBaseClassNotFrozen": "冻结 (frozen=True) 的 dataclass 不能继承非冻结 (frozen=False) 的 dataclass",
        "dataClassConverterFunction": "“{argType}”类型的参数不是“{fieldType}”类型的字段“{fieldName}”的合法转换器",
        "dataClassConverterOverloads": "“{funcName}”的重载不是“{fieldType}”类型的字段“{fieldName}”的合法转换器",
        "dataClassFieldInheritedDefault": "“{fieldName}”替代同名字段，但缺少默认值",
        "dataClassFieldWithDefault": "没有默认值的字段不能出现在具有默认值的字段之后",
        "dataClassFieldWithPrivateName": "dataclass 的字段不能使用私有名称",
        "dataClassFieldWithoutAnnotation": "不带类型注解的 dataclass 字段将导致运行时异常",
        "dataClassPostInitParamCount": "dataclass 中声明的方法 __post_init__ 参数数量不正确；InitVar 字段数为 {expected}",
        "dataClassPostInitType": "dataclass 中声明的方法 __post_init__ 方法中“{fieldName}”字段的参数类型不匹配",
        "dataClassSlotsOverwrite": "类中已定义 __slots__",
        "dataClassTransformExpectedBoolLiteral": "需要静态推导结果为 True 或 False 的表达式",
        "dataClassTransformFieldSpecifier": "需要类或函数的元组，但得到类型“{type}”",
        "dataClassTransformPositionalParam": "“dataclass_transform”的所有参数都必须是关键字参数",
        "dataClassTransformUnknownArgument": "“dataclass_transform”不支持参数“{name}”",
        "dataProtocolInSubclassCheck": "issubclass 调用中不允许使用数据协议（包括非方法属性）",
        "declaredReturnTypePartiallyUnknown": "声明的返回类型“{returnType}”部分未知",
        "declaredReturnTypeUnknown": "声明的返回类型未知",
        "defaultValueContainsCall": "参数默认值表达式中不允许调用函数或使用可变对象",
        "defaultValueNotAllowed": "“*”或“**”的参数不能有默认值",
        "delTargetExpr": "无法删除的表达式",
        "deprecatedClass": "“{name}”类已弃用",
        "deprecatedConstructor": "“{name}”类的构造函数已弃用",
        "deprecatedDescriptorDeleter": "“{name}”描述器的“__delete__”方法已弃用",
        "deprecatedDescriptorGetter": "“{name}”描述器的“__get__”方法已弃用",
        "deprecatedDescriptorSetter": "“{name}”描述器的“__set__”方法已弃用",
        "deprecatedFunction": "“{name}”函数已弃用",
        "deprecatedMethod": "“{className}”类中的“{name}”方法已弃用",
        "deprecatedPropertyDeleter": "“{name}”属性的 deleter 已弃用",
        "deprecatedPropertyGetter": "“{name}”属性的 getter 已弃用",
        "deprecatedPropertySetter": "“{name}”属性的 setter 已弃用",
        "deprecatedType": "此类型自 Python {version} 起已弃用；请改用“{replacement}”",
        "dictExpandIllegalInComprehension": "推导式中不允许展开字典表达式",
        "dictInAnnotation": "类型注解中不允许使用字典表达式",
        "dictKeyValuePairs": "字典项必须包含键值对",
        "dictUnpackIsNotMapping": "字典解包运算符需要 Mapping 对象",
        "dunderAllSymbolNotPresent": "“{name}”已在 __all__ 中声明，但未在模块中定义",
        "duplicateArgsParam": "应有且仅有一个“*”参数",
        "duplicateBaseClass": "不允许重复的基类",
        "duplicateCapturePatternTarget": "“{name}”捕获目标不能在同一模式中多次出现",
        "duplicateCatchAll": "应有且仅有一个能够捕获所有错误的 except 子句",
        "duplicateEnumMember": "重复的枚举声明“{name}”",
        "duplicateGenericAndProtocolBase": "应有且仅有一个 Generic[...] 或 Protocol[...] 基类",
        "duplicateImport": "“{importName}”被重复导入",
        "duplicateKeywordOnly": "应有且仅有一个“*”分隔出关键字参数",
        "duplicateKwargsParam": "应有且仅有一个可变关键字 (“**kwds”) 参数",
        "duplicateParam": "“{name}”参数声明重复",
        "duplicatePositionOnly": "函数参数中应有且仅有一个“/”",
        "duplicateStarPattern": "在序列形式的模式匹配中应有且仅有一个“*”项",
        "duplicateStarStarPattern": "应有且仅有一个“**”项",
        "duplicateUnpack": "仅允许使用一次 Unpack",
        "ellipsisAfterUnpacked": "“...”不能与解包了的 TypeVarTuple 或元组一起使用",
        "ellipsisContext": "“...”不允许在此上下文中使用",
        "ellipsisSecondArg": "“...”仅允许作为这两个参数中的第二个参数",
        "enumClassOverride": "“{name}”枚举类使用 @final 装饰，不能派生子类",
        "enumMemberDelete": "无法删除枚举成员“{name}”",
        "enumMemberSet": "无法分配枚举成员“{name}”",
        "enumMemberTypeAnnotation": "枚举成员不允许使用类型注释",
        "exceptionGroupIncompatible": "异常组语法（“except*”）需要使用 Python 3.11 或更高版本",
        "exceptionGroupTypeIncorrect": "Exception type in except* cannot derive from BaseGroupException",
        "exceptionTypeIncorrect": "“{type}”不派生自 BaseException",
        "exceptionTypeNotClass": "“{type}”不是有效的异常（Exception）类",
        "exceptionTypeNotInstantiable": "Exception “{type}”的构造函数需要一个或多个参数",
        "expectedAfterDecorator": "装饰器下方应存在函数或类声明",
        "expectedArrow": "应有“->”符号和随后的返回类型的类型注解",
        "expectedAsAfterException": "expect Exception 语句后只能为“as”",
        "expectedAssignRightHandExpr": "“=”右侧应有表达式",
        "expectedBinaryRightHandExpr": "运算符右侧应有表达式",
        "expectedBoolLiteral": "此处应为 True 或 False",
        "expectedCase": "此处应有“case”语句",
        "expectedClassName": "此处应填写类名",
        "expectedCloseBrace": "“{”未闭合",
        "expectedCloseBracket": "“[”未闭合",
        "expectedCloseParen": "“(”未闭合",
        "expectedColon": "此处应有“:”",
        "expectedComplexNumberLiteral": "模式匹配需要复数字面量",
        "expectedDecoratorExpr": "Python 3.9 之前不支持表达式形式的装饰器",
        "expectedDecoratorName": "此处应有装饰器名称",
        "expectedDecoratorNewline": "装饰器末尾应换行",
        "expectedDelExpr": "“del”后应有表达式",
        "expectedElse": "此处应为“else”",
        "expectedEquals": "此处应为“=”",
        "expectedExceptionClass": "异常类或对象无效",
        "expectedExceptionObj": "此处应有异常对象、异常类或 None",
        "expectedExpr": "此处应有表达式",
        "expectedFunctionAfterAsync": "“async”后面应有函数定义",
        "expectedFunctionName": "“def”后应有函数名称",
        "expectedIdentifier": "此处应有标识符",
        "expectedImport": "此处应为“import”",
        "expectedImportAlias": "“as”后应指定别称",
        "expectedImportSymbols": "“import”后应有符号名称",
        "expectedIn": "此处应为“in”",
        "expectedInExpr": "“in”后应有表达式",
        "expectedIndentedBlock": "此处应有缩进块",
        "expectedMemberName": "“.”后应有成员名称",
        "expectedModuleName": "此处应有模块名称",
        "expectedNameAfterAs": "“as”后应有符号名称",
        "expectedNamedParameter": "关键字参数必须跟在“*”之后",
        "expectedNewline": "此处应有换行符",
        "expectedNewlineOrSemicolon": "语句必须用换行符或分号分隔",
        "expectedOpenParen": "此处应有“(”",
        "expectedParamName": "此处应有参数名称",
        "expectedPatternExpr": "此处应有模式表达式（Pattern Matching）",
        "expectedPatternSubjectExpr": "此处应有一个表达式，用于模式匹配的匹配目标",
        "expectedPatternValue": "此处应有 “a.b” 形式的模式值表达式",
        "expectedReturnExpr": "“return” 后应有表达式",
        "expectedSliceIndex": "此处应有索引或切片表达式",
        "expectedTypeNotString": "此处应为类型而非字符串字面量",
        "expectedTypeParameterName": "此处应有类型参数名称",
        "expectedYieldExpr": "yield 语句后应跟随一个表达式",
        "finalClassIsAbstract": "“{type}” 类被 @final 装饰，故必须实现所有抽象符号",
        "finalContext": "不允许在此上下文中使用 “Final”",
        "finalInLoop": "无法在循环中分配 \"Final\" 变量",
        "finalMethodOverride": "“{name}” 方法无法重写在 “{className}” 类中定义的被 @final 装饰的方法",
        "finalNonMethod": "不能将函数 “{name}” 标记为 @final，因为它不是方法",
        "finalReassigned": "“{name}” 已声明为 Final，无法重新赋值",
        "finalRedeclaration": "“{name}” 此前已有声明为 Final，但在此处被重新声明",
        "finalRedeclarationBySubclass": "无法重新声明 “{name}” ，因为父类 “{className}” 将其声明为 Final",
        "finalTooManyArgs": "“Final” 后应有且仅有一个类型参数",
        "finalUnassigned": "“{name}” 声明为“Final”，但未被赋值",
        "formatStringBrace": "格式化字符串字面量中不允许使用单个花括号；使用两个花括号代替",
        "formatStringBytes": "格式化字符串字面量不能是 bytes 类型的",
        "formatStringDebuggingIllegal": "格式化字符串中使用调试辅助符 “=” 需要 Python 3.8 或更高版本",
        "formatStringEscape": "格式化字符串的表达式部分中使用转义序列（反斜杠）需要 Python 3.12 或更高版本",
        "formatStringExpectedConversion": "格式化字符串中 “!” 后缺少对转换操作的描述",
        "formatStringIllegal": "格式化字符串字面量需要 Python 3.6 或更高版本",
        "formatStringInPattern": "模式匹配使用的模式表达式中不允许使用格式化字符串",
        "formatStringNestedFormatSpecifier": "格式化字符串中包含的表达式嵌套太深",
        "formatStringNestedQuote": "在 Python 3.12 之前，嵌套的字符串不能使用与格式化字符串相同的引号字符",
        "formatStringUnicode": "格式化字符串字面量不能为 Unicode",
        "formatStringUnterminated": "格式化字符串中有未终止的表达式；需要 “}”",
        "functionDecoratorTypeAny": "Any 类型的函数装饰器覆盖了被装饰函数的类型",
        "functionDecoratorTypeUnknown": "未标返回值类型的函数装饰器会覆盖函数类型，因此已忽略装饰器",
        "functionInConditionalExpression": "条件表达式中含有未调用的函数，其计算结果始终为 True",
        "functionTypeParametersIllegal": "函数的类型参数语法 (PEP 695) 需要 Python 3.12 或更高版本",
        "futureImportLocationNotAllowed": "从 __future__ 的导入必须位于文件的开头",
        "generatorAsyncReturnType": "异步生成器函数的返回类型必须与 “AsyncGenerator[{yieldType}, Any]” 兼容",
        "generatorNotParenthesized": "不是唯一参数的生成器表达式必须带上圆括号",
        "generatorSyncReturnType": "生成器函数的返回类型必须与 “Generator[{yieldType}, Any, Any]” 兼容",
        "genericBaseClassNotAllowed": "“Generic” 基类不能与类型参数语法一起使用",
        "genericClassAssigned": "无法赋值 Generic 类型",
        "genericClassDeleted": "无法删除 Generic 类型",
        "genericInstanceVariableAccess": "这是通过类访问泛型实例上的变量，因此无法确定其类型",
        "genericNotAllowed": "“Generic” 在此上下文中无效",
        "genericTypeAliasBoundTypeVar": "类中的泛型类型别名不能使用绑定类型变量 {names}",
        "genericTypeArgMissing": "“Generic” 应至少有一个类型参数",
        "genericTypeArgTypeVar": "“Generic” 的类型参数必须是类型变量",
        "genericTypeArgUnique": "“Generic” 的类型参数必须唯一",
        "globalReassignment": "“{name}” 在此前已定义为全局变量，但在此处被重新赋值",
        "globalRedefinition": "“{name}” 此前已在全局声明，但在此处亦被重新声明",
        "implicitStringConcat": "不允许隐式的字符串拼接",
        "importCycleDetected": "导入链中检测到循环导入",
        "importDepthExceeded": "导入链深度超过 {depth} 层",
        "importResolveFailure": "无法解析导入 “{importName}”",
        "importSourceResolveFailure": "无法从源码解析导入 “{importName}”，你是否正确的安装了该库？",
        "importSymbolUnknown": " “{name}” 是未知的导入符号",
        "incompatibleMethodOverride": "此 “{name}” 方法以不兼容的方式重写了 “{className}” 类中的同名方法",
        "inconsistentIndent": "缩进量与此前并不一致",
        "inconsistentTabs": "缩进中混用了制表符和空格",
        "initMustReturnNone": "“__init__” 方法的返回类型必须为 None",
        "initSubclassCallFailed": "__init_subclass__ 方法上的关键字参数不正确",
        "initSubclassClsParam": "重写的 __init_subclass__ 应采用 “cls” 参数",
        "initVarNotAllowed": "此上下文中不允许使用 “InitVar”",
        "instanceMethodSelfParam": "实例方法应采用 “self” 参数",
        "instanceVarOverridesClassVar": "实例变量 “{name}” 覆盖了 “{className}” 类中的同名类变量",
        "instantiateAbstract": "无法实例化抽象类 “{type}”",
        "instantiateProtocol": "无法实例化协议类 “{type}” ",
        "internalBindError": "对 “{file}” 文件分析符号绑定关系时发生内部错误：{message}",
        "internalParseError": "分析 “{file}” 文件时发生内部错误：{message}",
        "internalTypeCheckingError": "对 “{file}” 文件进行类型检查时发生内部错误：{message}",
        "invalidIdentifierChar": "标识符中使用了无效字符",
        "invalidStubStatement": "语句在 Type Stub 文件中无意义",
        "invalidTokenChars": "该 Token 中的字符 “{text}” 无效",
        "isInstanceInvalidType": "“isinstance” 的第二个参数必须是单个类或由多个类构成的元组",
        "isSubclassInvalidType": "“issubclass” 的第二个参数必须是单个类或由多个类构成的元组",
        "keyValueInSet": "集合内不允许存在键值对",
        "keywordArgInTypeArgument": "关键字参数不能在类型参数列表中使用",
        "keywordArgShortcutIllegal": "关键字参数快捷方式需要 Python 3.14 或更高版本",
        "keywordOnlyAfterArgs": "参数声明中，“*” 后不允许出现 “/”",
        "keywordParameterMissing": "关键字参数必须在 “*” 参数之后",
        "keywordSubscriptIllegal": "与下标相关的方法中不支持使用关键字参数",
        "lambdaReturnTypeAny": "该 lambda 函数的返回类型为 Any",
        "lambdaReturnTypePartiallyUnknown": "该 lambda 的返回类型 “{returnType}” 部分未知",
        "lambdaReturnTypeUnknown": "该 lambda 的返回类型未知",
        "listAssignmentMismatch": "无法将 “{type}” 类型的表达式赋值给目标列表",
        "listInAnnotation": "类型注解中不允许使用列表表达式",
        "literalEmptyArgs": "“Literal” 后应有一个或多个类型参数",
        "literalNamedUnicodeEscape": "“文本”字符串批注不支持已命名的 unicode 转义序列",
        "literalNotAllowed": "如果不传入类型参数，则 “Literal” 不能用于此上下文",
        "literalNotCallable": "Literal 类型无法实例化",
        "literalUnsupportedType": "“Literal” 的类型参数必须是字面量（None、int、bool、str 或 bytes）或枚举值",
        "matchIncompatible": "match 语句需要 Python 3.10 或更高版本",
        "matchIsNotExhaustive": "match 语句中的匹配条件不能处理所有可能的值",
        "maxParseDepthExceeded": "超出最大分析深度；请将表达式拆解为较小的子表达式",
        "memberAccess": "无法访问 “{type}” 类型的 “{name}” 成员",
        "memberDelete": "无法删除 “{type}” 类型的 “{name}” 成员",
        "memberSet": "无法为 “{type}” 类型的 “{name}” 成员赋值",
        "metaclassConflict": "派生类的元类必须是其所有基类的元类的子类",
        "metaclassDuplicate": "只能提供一个元类",
        "metaclassIsGeneric": "元类不能为泛型",
        "methodNotDefined": "未定义 “{name}” 方法",
        "methodNotDefinedOnType": "“{type}” 类型上未定义 “{name}” 方法",
        "methodOrdering": "无法构造一致的方法排序 (MRO)",
        "methodOverridden": "“{name}” 在不兼容 “{type}” 类型的 “{className}” 类中替代同名的方法",
        "methodReturnsNonObject": "“{name}” 方法不返回对象",
        "missingSuperCall": "“{methodName}” 方法不调用父类的同名方法",
        "mixingBytesAndStr": "Bytes 和 str 值无法串联",
        "moduleAsType": "模块不能用作类型",
        "moduleNotCallable": "模块不能调用",
        "moduleUnknownMember": "“{memberName}” 不是 “{moduleName}” 模块的已知成员",
        "namedExceptAfterCatchAll": "全部捕获的 except 子句后不能出现命名的 except 子句",
        "namedParamAfterParamSpecArgs": "关键字参数 “{name}” 不能出现在 ParamSpec args 参数之后的签名中",
        "namedTupleEmptyName": "NamedTuple 中的名称不能为空",
        "namedTupleEntryRedeclared": "无法重写 “{name}”，因为父类 “{className}” 是 NamedTuple",
        "namedTupleFirstArg": "第一个参数应为 NamedTuple 的类名",
        "namedTupleMultipleInheritance": "NamedTuple 不支持多继承",
        "namedTupleNameKeyword": "字段名称不能是关键字",
        "namedTupleNameType": "应为指定了字段名称和类型的二元元组",
        "namedTupleNameUnique": "NamedTuple 中的字段名称之间必须是唯一的",
        "namedTupleNoTypes": "“namedtuple” 不提供元组项的类型；请改用 “NamedTuple”",
        "namedTupleSecondArg": "应为 NamedTuple 的第二个参数传递字段列表",
        "newClsParam": "重写的 __new__ 应接受 “cls” 参数",
        "newTypeAnyOrUnknown": "NewType 的第二个参数必须是已知类，而不是 “Any” 或未知类型",
        "newTypeBadName": "NewType 的第一个参数必须是字符串字面量",
        "newTypeLiteral": "NewType 不能与 Literal 类型一起使用",
        "newTypeNameMismatch": "必须将 NewType 赋值给同名变量",
        "newTypeNotAClass": "NewType 的第二个参数应为类",
        "newTypeParamCount": "NewType 需要两个位置参数",
        "newTypeProtocolClass": "NewType 不能与 Structural Typing（Python 中指 Protocol 或 TypedDict）一起使用",
        "noOverload": "“{name}” 的重载与提供的参数不匹配",
        "noReturnContainsReturn": "返回类型为 “NoReturn” 的函数不能包含 return 语句",
        "noReturnContainsYield": "返回类型为 “NoReturn” 的函数不能包含 yield 语句",
        "noReturnReturnsNone": "返回类型为 “NoReturn” 的函数不能最终返回 “None”",
        "nonDefaultAfterDefault": "未指定默认值的参数不应位于具有默认值的参数后",
        "nonLocalInModule": "不允许在模块层级的代码块中使用 nonlocal",
        "nonLocalNoBinding": "找不到非局部 nonlocal 变量 “{name}” 的绑定",
        "nonLocalReassignment": "“{name}” 已在 nonlocal 声明之前赋值",
        "nonLocalRedefinition": "“{name}” 已声明为 nonlocal",
        "noneNotCallable": "无法调用 “None” 类型的对象",
        "noneNotIterable": "不能迭代 “None” 类型的对象",
        "noneNotSubscriptable": "不能取 “None” 类型对象的下标",
        "noneNotUsableWith": "“None” 类型的对象不能与 “with” 一起使用",
        "noneOperator": "“None” 不支持运算符 “{operator}”",
        "noneUnknownMember": "“{name}” 不是 “None” 的已知成员",
        "notRequiredArgCount": "“NotRequired” 之后应有且仅有一个类型参数",
        "notRequiredNotInTypedDict": "此上下文中不允许使用 “NotRequired”",
        "objectNotCallable": "“{type}” 类型的对象不可调用",
        "obscuredClassDeclaration": "“{name}” 类的声明被同名的声明覆盖",
        "obscuredFunctionDeclaration": "“{name}” 函数的声明被同名声明覆盖",
        "obscuredMethodDeclaration": "“{name}” 方法的声明被同名声明覆盖",
        "obscuredParameterDeclaration": "“{name}” 参数的声明被同名声明覆盖",
        "obscuredTypeAliasDeclaration": "“{name}” 类型别名的声明被同名声明覆盖",
        "obscuredVariableDeclaration": "“{name}” 变量声明被同名声明覆盖",
        "operatorLessOrGreaterDeprecated": "Python 3 不支持 “<>” 运算符；请改用“!=”",
        "optionalExtraArgs": "“Optional” 后面应有一个类型参数",
        "orPatternIrrefutable": "必定匹配模式仅允许作为 “or” 模式中的最后一个子模式",
        "orPatternMissingName": "“or” 模式中的所有子节点必须以相同的名称为目标",
        "overlappingKeywordArgs": "TypedDict 与以下关键字参数重复：{names}",
        "overlappingOverload": "永远不会使用 “{name}” 的重载 {obscured}，因为其参数被重载 {obscuredBy} 涵盖",
        "overloadAbstractImplMismatch": "重载必须与实现的抽象状态匹配",
        "overloadAbstractMismatch": "重载必须全部为抽象重载或非抽象重载",
        "overloadClassMethodInconsistent": "“{name}” 的重载使用 @classmethod 的方式不一致",
        "overloadFinalInconsistencyImpl": "“{name}” 的重载被标记为 @final，但实现却未被标记为 @final",
        "overloadFinalInconsistencyNoImpl": "“{name}” 的第 {index} 个重载被标记为 @final，但第一个重载却未被标记为 @final",
        "overloadImplementationMismatch": "重载实现与第 {index} 个重载的签名不一致",
        "overloadReturnTypeMismatch": "“{name}” 的第 {prevIndex} 个重载与第 {newIndex} 个重载重复，并各自返回了不兼容的类型",
        "overloadStaticMethodInconsistent": "“{name}” 的重载使用 @staticmethod 的方式不一致",
        "overloadWithoutImplementation": "“{name}” 重载缺少实现",
        "overriddenMethodNotFound": "“{name}”方 法已标记为覆写，但基类中不存在同名方法",
        "overrideDecoratorMissing": "“{name}” 方法未标记为覆写，但覆写了“{className}”类中的方法",
        "paramAfterKwargsParam": "“**” 参数后不应再有参数",
        "paramAlreadyAssigned": "“{name}” 参数已赋值",
        "paramAnnotationMissing": "“{name}” 参数缺少类型注解",
        "paramAssignmentMismatch": "无法将 “{sourceType}” 类型的表达式赋值给 “{paramType}” 类型的参数",
        "paramNameMissing": "缺少名为 “{name}” 的参数",
        "paramSpecArgsKwargsUsage": "ParamSpec 的 “args” 和 “kwargs” 成员必须同时出现在函数签名中",
        "paramSpecArgsMissing": "缺少 ParamSpec “{type}” 的参数",
        "paramSpecArgsUsage": "ParamSpec 的 “args” 成员仅在与 *args 参数一起使用时有效",
        "paramSpecAssignedName": "必须将 ParamSpec 赋值给名为 “{name}” 的变量",
        "paramSpecContext": "此上下文中不允许使用 ParamSpec",
        "paramSpecDefaultNotTuple": "ParamSpec 的默认值应为省略号、元组表达式或 ParamSpec",
        "paramSpecFirstArg": "ParamSpec 实例化的第一个参数应为其名称",
        "paramSpecKwargsUsage": "ParamSpec 的 “kwargs” 成员仅在与 **kwargs 参数一起使用时有效",
        "paramSpecNotUsedByOuterScope": "ParamSpec “{name}” 在此上下文中没有意义",
        "paramSpecUnknownArg": "ParamSpec 不支持传入多个参数",
        "paramSpecUnknownMember": "“{name}” 不是 ParamSpec 的已知成员",
        "paramSpecUnknownParam": "“{name}” 是 ParamSpec 的未知参数",
        "paramTypeAny": "“{paramName}” 参数类型为 Any",
        "paramTypeCovariant": "参数中的类型变量不能为协变",
        "paramTypePartiallyUnknown": "“{paramName}” 参数的类型部分未知",
        "paramTypeUnknown": "“{paramName}” 参数的类型未知",
        "parenthesizedContextManagerIllegal": "“with” 语句中使用括号需要 Python 3.9 或更高版本",
        "patternNeverMatches": "主题类型 “{type}” 的模式永远不会匹配",
        "positionArgAfterNamedArg": "位置参数不能出现在关键字参数之后",
        "positionOnlyAfterArgs": "“*” 参数后不允许使用仅位置参数分隔符",
        "positionOnlyAfterKeywordOnly": "分隔符 “/” 必须出现在 “*” 分隔符或参数之前",
        "positionOnlyAfterNon": "非仅位置参数后面不允许仅位置参数",
        "positionOnlyFirstParam": "不允许将仅位置参数分隔符 “/” 用作第一个参数",
        "positionOnlyIncompatible": "仅位置参数分隔符需要 Python 3.8 或更高版本",
        "privateImportFromPyTypedModule": "未从模块 “{module}” 导出 “{name}”",
        "privateUsedOutsideOfClass": "私有符号 “{name}” 在声明它的类之外使用",
        "privateUsedOutsideOfModule": "私有符号 “{name}” 在声明它的模块之外使用",
        "propertyOverridden": "“{name}” 错误地覆写了类 “{className}” 中的同名属性",
        "propertyStaticMethod": "属性 getter、setter 或 deleter 不允许使用静态方法",
        "protectedUsedOutsideOfClass": "“{name}” 在声明它受到保护的类之外被使用",
        "protocolBaseClass": "协议类 “{classType}” 不能派生自非协议类 “{baseType}”",
        "protocolBaseClassWithTypeArgs": "协议类不允许使用类型参数语法声明类型参数",
        "protocolIllegal": "使用 “Protocol” 需要 Python 3.7 或更高版本",
        "protocolNotAllowed": "“Protocol” 不能用于此上下文",
        "protocolTypeArgMustBeTypeParam": "“协议”的类型参数必须是类型参数",
        "protocolUnsafeOverlap": "类与 “{name}” 不安全的重叠，并且可能在运行时生成匹配项",
        "protocolVarianceContravariant": "协议类 “{class}” 中使用的类型变量 “{variable}” 应为逆变形式",
        "protocolVarianceCovariant": "协议类 “{class}” 中使用的类型变量 “{variable}” 应为协变形式",
        "protocolVarianceInvariant": "协议类 “{class}” 中使用的类型变量 “{variable}” 应为不变形式",
        "pyrightCommentInvalidDiagnosticBoolValue": "Pyright 注释指令后面必须跟有 “=” 和一个设作 true 或 false 的值",
        "pyrightCommentInvalidDiagnosticSeverityValue": "Pyright 注释指令后面必须跟有 “=” 和一个设作 true、false、error、warning、information 或 none 的值",
        "pyrightCommentMissingDirective": "该 Pyright 注释的内容必须是诊断级别（basic 或 strict）或诊断规则",
        "pyrightCommentNotOnOwnLine": "Pyright 的文件级注释应独立成行。",
        "pyrightCommentUnknownDiagnosticRule": "Pyright 注释引用了一个未知的诊断规则 “{rule}”",
        "pyrightCommentUnknownDiagnosticSeverityValue": "无效的 Pyright 注释值 “{value}”；应为 true、false、error、warning、information 或 none",
        "pyrightCommentUnknownDirective": "“{directive}”是 Pyright 注释的未知指令；应为“strict”或“basic”",
        "readOnlyArgCount": "“ReadOnly” 后应有且仅有一个类型参数",
        "readOnlyNotInTypedDict": "此上下文中不允许使用 “ReadOnly”",
        "recursiveDefinition": "无法确定 “{name}” 的类型，因为它引用了其自身",
        "relativeImportNotAllowed": "相对导入不能与 “import .a” 形式一起使用：改用 “from . import a”",
        "requiredArgCount": "“Required” 后应有且仅有一个类型参数",
        "requiredNotInTypedDict": "此上下文中不允许使用 “Required”",
        "returnInAsyncGenerator": "异步生成器的函数体中不允许带返回值的 return 语句",
        "returnMissing": "该函数标注了返回类型为 “{returnType}”，因此必须在所有代码路径上返回值",
        "returnOutsideFunction": "“return” 语句只能在函数中使用",
        "returnTypeContravariant": "逆变形式的类型变量不能用于返回类型",
        "returnTypeMismatch": "无法将 “{exprType}” 类型的表达式作为返回传递为类型 “{returnType}”",
        "returnTypePartiallyUnknown": "返回类型 “{returnType}” 部分未知",
        "returnTypeUnknown": "返回类型未知",
        "revealLocalsArgs": "“reveal_locals” 调用应没有参数",
        "revealLocalsNone": "此作用域内不存在任何局部变量",
        "returnTypeAny": "返回类型为 Any",
        "revealTypeArgs": "“reveal_type” 调用应仅传递一个位置参数",
        "revealTypeExpectedTextArg": "函数 “reveal_type” 的 “expected_text” 参数必须是 str 字面量",
        "revealTypeExpectedTextMismatch": "类型字面量不匹配；预期为 “{expected}” 但收到 “{received}”",
        "revealTypeExpectedTypeMismatch": "类型不匹配；预期为 “{expected}” 但收到 “{received}”",
        "selfTypeContext": "“Self” 在此上下文中无效",
        "selfTypeMetaclass": "“Self” 不能在元类 (即 “type” 的子类) 中使用",
        "selfTypeWithTypedSelfOrCls": "已指定 “self” 或 “cls” 参数上类型的函数中不可使用 Self",
        "setterGetterTypeMismatch": "属性的 setter 值类型不匹配 getter 返回类型",
        "singleOverload": "“{name}” 被标记为重载，但未定义其他重载",
        "slotsAttributeError": "未在 __slots__ 中指定 “{name}”",
        "slotsClassVarConflict": "“{name}” 与 __slots__ 中声明的实例属性存在冲突",
        "starPatternInAsPattern": "不能给解包模式表达式起别名",
        "starPatternInOrPattern": "解包模式表达式不能与同其他进行 “或” 操作的模式使用",
        "starStarWildcardNotAllowed": "** 不能与通配符 “_” 一起使用",
        "staticClsSelfParam": "静态方法不应采用 “self” 或 “cls” 参数",
        "stdlibModuleOverridden": "“{path}” 正在替代 stdlib 模块 “{name}”",
        "stringNonAsciiBytes": "不允许使用含有非 ASCII 字符 (以字节为单位) 的字符串字面量",
        "stringNotSubscriptable": "不能对着字符串字面量形式的类型注解取下标；建议将整个注解括在引号中",
        "stringUnsupportedEscape": "字符串文本中不受支持的转义序列",
        "stringUnterminated": "字符串文本未终止",
        "stubFileMissing": "找不到“{importName}”的存根文件",
        "stubUsesGetAttr": "类型存根文件不完整；“__getattr__”会掩盖模块的类型错误",
        "sublistParamsIncompatible": "Python 3.x 不支持 sublist 参数",
        "superCallArgCount": "“super”调用不应多于两个参数",
        "superCallFirstArg": "应将类类型作为“super”调用的第一个参数，但收到“{type}”",
        "superCallSecondArg": "“super”调用的第二个参数必须是派生自“{type}”的对象或类",
        "superCallZeroArgForm": "“Super”调用的零参数形式仅在方法中有效",
        "superCallZeroArgFormStaticMethod": "“super”调用的零参数形式在静态方法中无效",
        "symbolIsPossiblyUnbound": "“{name}”可能未绑定",
        "symbolIsUnbound": "“{name}”未绑定",
        "symbolIsUndefined": "“{name}”未定义",
        "symbolOverridden": "“{name}”覆写了“{className}”类中的同名符号",
        "ternaryNotAllowed": "类型注释中不允许使用三元表达式",
        "totalOrderingMissingMethod": "类必须定义“__lt__”、“__le__”、“__gt__”或“__ge__”之一才能使用total_ordering",
        "trailingCommaInFromImport": "不允许使用尾随逗号，没有括号",
        "tryWithoutExcept": "Try 语句必须至少有一个 except 或 finally 子句",
        "tupleAssignmentMismatch": "无法将类型为“{type}”的表达式赋值给目标元组",
        "tupleInAnnotation": "类型注解中不允许使用元组表达式",
        "tupleIndexOutOfRange": "对 {type} 类型使用的索引值 {index} 超出了取值范围",
        "typeAliasIllegalExpressionForm": "定义类型别名时使用的表达式形式无效",
        "typeAliasIsRecursiveDirect": "类型别名“ {name}” 不能在其定义中引用自身",
        "typeAliasNotInModuleOrClass": "TypeAlias 只能在模块或类范围内定义",
        "typeAliasRedeclared": "声明为 TypeAlias 的 “{name}” 只能赋值一次",
        "typeAliasStatementBadScope": "type 语句只能在模块或类范围内使用",
        "typeAliasStatementIllegal": "类型别名语句需要 Python 3.12 或更高版本",
        "typeAliasTypeBaseClass": "“type” 语句中定义的类型别名不能用作基类",
        "typeAliasTypeMustBeAssigned": "必须将 TypeAliasType 赋值给与类型别名同名的变量",
        "typeAliasTypeNameArg": "TypeAliasType 的第一个参数必须是表示类型别名名称的字符串字面量",
        "typeAliasTypeNameMismatch": "类型别名的名称必须与赋值到的变量的名称相匹配",
        "typeAliasTypeParamInvalid": "类型参数列表必须是仅包含 TypeVar、TypeVarTuple 或 ParamSpec 的元组",
        "typeAnnotationCall": "类型表达式中不允许函数调用",
        "typeAnnotationVariable": "类型表达式中不允许使用变量",
        "typeAnnotationWithCallable": "“type” 上的类型参数必须传递一个类; 不支持可调用对象",
        "typeAny": "“{name}” 的类型为 Any",
        "typeArgListExpected": "应为 ParamSpec、省略号 （Ellipsis, `...`） 或类型列表",
        "typeArgListNotAllowed": "不允许此类型参数使用列表表达式",
        "typeArgsExpectingNone": "“{name}” 类不应有类型参数",
        "typeArgsMismatchOne": "应为一个类型参数，但得到 {received}",
        "typeArgsMissingForAlias": "“{name}” 泛型类型别名应有类型参数",
        "typeArgsMissingForClass": "“{name}” 泛型类应有类型参数",
        "typeArgsTooFew": "为 “{name}” 提供的类型参数太少：应有 {expected} 个，但只有 {received} 个",
        "typeArgsTooMany": "为 “{name}” 提供的类型参数太多：应有 {expected} 个，但有 {received} 个",
        "typeAssignmentMismatch": "“{sourceType}” 类型的表达式无法赋值给已声明的 “{destType}” 类型",
        "typeAssignmentMismatchWildcard": "“{name}”导入符号的类型为“{sourceType}”，无法将其赋值给声明的“{destType}”类型",
        "typeCallNotAllowed": "type() 调用不应用于类型注解",
        "typeCheckOnly": "“{name}”标记为 @type_check_only，只能在类型注释中使用",
        "typeCommentDeprecated": "类型注释已弃用；请改用类型注解",
        "typeExpectedClass": "应为类型表达式，但得到“{type}”",
        "typeFormArgs": "\"TypeForm\" 接受单个位置参数",
        "typeGuardArgCount": "“TypeGuard”或“TypeIs”后应有且仅有一个类型参数",
        "typeGuardParamCount": "用户定义的类型保护器函数和方法必须至少有一个输入参数",
        "typeIsReturnType": "TypeIs 的返回类型“{returnType}”与值参数类型“{type}”不一致",
        "typeNotAwaitable": "“{type}”不能等待",
        "typeNotIntantiable": "“{type}”不能实例化",
        "typeNotIterable": "“{type}”不能迭代",
        "typeNotSpecializable": "“{type}”类型无法特化",
        "typeNotSubscriptable": "“{type}”类型的对象不能取下标",
        "typeNotSupportBinaryOperator": "“{leftType}”和“{rightType}”类型不支持“{operator}”运算符",
        "typeNotSupportBinaryOperatorBidirectional": "预期类型为“{expectedType}”时，类型“{leftType}”和“{rightType}”不支持运算符“{operator}”",
        "typeNotSupportUnaryOperator": "“{type}”类型不支持“{operator}”运算符",
        "typeNotSupportUnaryOperatorBidirectional": "预期类型为“{expectedType}”时，“{type}”类型不支持“{operator}”运算符",
        "typeNotUsableWith": "“{type}”类型的对象不能与“with”一起使用，因为它未实现{method}",
        "typeParameterBoundNotAllowed": "绑定或约束不能与可变类型参数或 ParamSpec 一起使用",
        "typeParameterConstraintTuple": "类型参数约束必须为含至少两个类型的元组",
        "typeParameterExistingTypeParameter": "“{name}”类型参数已使用",
        "typeParameterNotDeclared": "“{name}”类型参数未包含在“{container}”的类型参数列表中",
        "typeParametersMissing": "必须指定至少一个类型参数",
        "typePartiallyUnknown": "“{name}”的类型部分未知",
        "typeUnknown": "“{name}”类型未知",
        "typeVarAssignedName": "必须将 TypeVar 赋值给名为“{name}”的变量",
        "typeVarAssignmentMismatch": "无法将“{type}”类型赋值给类型变量“{name}”",
        "typeVarBoundAndConstrained": "TypeVar 不能同时绑定和约束",
        "typeVarBoundGeneric": "TypeVar 绑定类型不能是泛型",
        "typeVarConstraintGeneric": "TypeVar 约束类型不能是泛型",
        "typeVarDefaultBoundMismatch": "TypeVar 默认类型必须是绑定类型的子类型",
        "typeVarDefaultConstraintMismatch": "TypeVar 默认类型必须是受约束类型之一",
        "typeVarDefaultIllegal": "类型变量默认类型需要 Python 3.13 或更高版本",
        "typeVarDefaultInvalidTypeVar": "“{name}”类型参数的默认类型是指超出范围的一个或多个类型变量",
        "typeVarFirstArg": "TypeVar 的第一个参数应为其名称",
        "typeVarInvalidForMemberVariable": "属性类型不能使用作用域为本地方法的类型变量\"{name}\"",
        "typeVarNoMember": "TypeVar “{type}”没有“{name}”成员",
        "typeVarNotSubscriptable": "TypeVar “{type}”不能取下标",
        "typeVarNotUsedByOuterScope": "“{name}”类型变量在此上下文中没有意义",
        "typeVarPossiblyUnsolvable": "如果调用方没有为“{param}”形参提供实参，则“{name}”类型变量可能无法解析",
        "typeVarSingleConstraint": "TypeVar 必须有至少两种约束类型",
        "typeVarTupleConstraints": "TypeVarTuple 不能有值约束",
        "typeVarTupleContext": "此上下文中不允许使用 TypeVarTuple",
        "typeVarTupleDefaultNotUnpacked": "TypeVarTuple 默认类型必须是已解包的元组或 TypeVarTuple",
        "typeVarTupleMustBeUnpacked": "TypeVarTuple 值需要解包操作符",
        "typeVarTupleUnknownParam": "TypeVarTuple 没有“{name}”参数",
        "typeVarUnknownParam": "TypeVar 没有“{name}”参数",
        "typeVarUsedByOuterScope": "TypeVar “{name}”已被外部作用域使用",
        "typeVarUsedOnlyOnce": "TypeVar “{name}”在泛型函数签名中仅出现了一次",
        "typeVarVariance": "TypeVar 不能同时为协变和逆变",
        "typeVarWithDefaultFollowsVariadic": "TypeVar “{typeVarName}”具有默认值，不能跟在 TypeVarTuple “{variadicName}”之后",
        "typeVarWithoutDefault": "“{name}”不能出现在类型参数列表的“{other}”后面，因为它没有默认类型",
        "typeVarsNotInGenericOrProtocol": "Generic[] 或 Protocol[] 必须包括所有类型变量",
        "typedDictAccess": "无法访问 TypedDict 中的项",
        "typedDictAssignedName": "必须将 TypedDict 赋值给名为“{name}”的变量",
        "typedDictBadVar": "TypedDict 类只能包含类型注解",
        "typedDictBaseClass": "TypedDict 类的所有基类也必须是 TypedDict 类",
        "typedDictBoolParam": "“{name}”参数的值应为 True 或 False",
        "typedDictClosedExtras": "“{name}”基类是已关闭的 TypedDict；额外的项必须为“{type}类型”",
        "typedDictClosedNoExtras": "“{name}”基类是已关闭的 TypedDict；不允许使用额外的项",
        "typedDictDelete": "无法删除 TypedDict 中的项",
        "typedDictEmptyName": "TypedDict 中的名称不能为空",
        "typedDictEntryName": "字典条目名称的预期字符串字面量",
        "typedDictEntryUnique": "字典中的名称必须唯一",
        "typedDictExtraArgs": "不支持额外的 TypedDict 参数",
        "typedDictFieldNotRequiredRedefinition": "无法将 TypedDict 项“{name}”重新定义为 NotRequired",
        "typedDictFieldReadOnlyRedefinition": "无法将 TypedDict 项“{name}”重新定义为 ReadOnly",
        "typedDictFieldRequiredRedefinition": "无法将 TypedDict 项“{name}”重新定义为 Required",
        "typedDictFirstArg": "应将 TypedDict 类名作为第一个参数",
        "typedDictInitsubclassParameter": "TypedDict 不支持 __init_subclass__ 的“{name}”参数",
        "typedDictNotAllowed": "“TypedDict”不能用于此上下文",
        "typedDictSecondArgDict": "第二个参数应为 dict 或关键字参数",
        "typedDictSecondArgDictEntry": "此处应为简单字典项",
        "typedDictSet": "无法在 TypedDict 中赋值项",
        "unaccessedClass": "“{name}”类未使用",
        "unaccessedFunction": "“{name}”函数未使用",
        "unaccessedImport": "“{name}”导入未使用",
        "unaccessedSymbol": "未存取“{name}”",
        "unaccessedVariable": "变量“{name}”未使用",
        "unannotatedFunctionSkipped": "已跳过对未标类型的“{name}”函数的分析",
        "unaryOperationNotAllowed": "类型注释中不允许使用一元运算符",
        "unexpectedAsyncToken": "“def”、“with”或“for”应在“async”之后",
        "unexpectedExprToken": "表达式末尾有错误的形符",
        "unexpectedIndent": "缩进有错误",
        "unexpectedUnindent": "取消缩进有错误",
        "unhashableDictKey": "字典键必须可以哈希",
        "unhashableSetEntry": "集合项必须是可哈希",
        "uninitializedAbstractVariables": "抽象基类中定义的变量未在“{classType}”最终类中初始化",
        "uninitializedInstanceVariable": "未在类体或 __init__ 方法中初始化“{name}”实例变量",
        "unionForwardReferenceNotAllowed": "联合语法不能与字符串操作数一起使用;在整个表达式周围使用引号",
        "unionSyntaxIllegal": "联合的替代语法需要 Python 3.10 或更高版本",
        "unionTypeArgCount": "联合需要至少两个类型参数",
        "unionUnpackedTuple": "联合不能包含未打包的元组",
        "unionUnpackedTypeVarTuple": "联合不能含有已解包的 TypeVarTuple",
        "unnecessaryCast": "已为“{type}”类型，不需要调用“cast”",
        "unnecessaryIsInstanceAlways": "“{testType}”始终是“{classType}”的实例，不需要调用 isinstance",
        "unnecessaryIsSubclassAlways": "“{testType}”始终是“{classType}”的子类，不需要调用 issubclass",
        "unnecessaryPyrightIgnore": "无需“# pyright: ignore”注释",
        "unnecessaryPyrightIgnoreRule": "无需“# pyright: ignore”规则：“{name}”",
        "unnecessaryTypeIgnore": "无需“# type: ignore”注释",
        "unpackArgCount": "“Unpack”后应有且仅有一个类型参数",
        "unpackExpectedTypeVarTuple": "Unpack 需要 TypeVarTuple 或元组类型参数",
        "unpackExpectedTypedDict": "Unpack 需要 TypedDict 类型参数",
        "unpackIllegalInComprehension": "推导式中不允许解包操作",
        "unpackInAnnotation": "类型注解中不允许解包操作符",
        "unpackInDict": "字典中不允许解包操作",
        "unpackInSet": "集合内不允许解包操作符",
        "unpackNotAllowed": "此上下文中不允许使用 Unpack",
        "unpackOperatorNotAllowed": "此上下文中不允许解包操作",
        "unpackTuplesIllegal": "在 Python 3.8 之前，元组中不允许解包操作",
        "unpackedArgInTypeArgument": "类型参数列表中无法使用已解包的参数",
        "unpackedArgWithVariadicParam": "已解包的参数不能用于 TypeVarTuple 参数",
        "unpackedDictArgumentNotMapping": "** 后面的参数表达式必须是具有“str”键类型的映射",
        "unpackedDictSubscriptIllegal": "下标中不允许使用字典解包操作符",
        "unpackedSubscriptIllegal": "下标中使用解包操作符需要 Python 3.11 或更高版本",
        "unpackedTypeVarTupleExpected": "此处应为已解包的 TypeVarTuple；使用 Unpack[{name1}] 或 *{name2}",
        "unpackedTypedDictArgument": "无法将已解包的 TypedDict 实参与形参匹配",
        "unreachableCode": "代码不会被执行",
        "unreachableCodeType": "类型分析指示代码不可访问",
        "unreachableExcept": "except 子句不会被执行，因为已处理异常",
        "unsupportedDunderAllOperation": "不支持对“__all__”执行操作，因此导出的符号列表可能不正确",
        "unusedCallResult": "“{type}”类型调用表达式的结果未使用。如果这是有意为之，则赋值给变量“_”",
        "unusedCoroutine": "异步函数调用的结果未使用。请使用“await”或将结果赋值给变量",
        "unusedExpression": "表达式值未使用",
        "varAnnotationIllegal": "变量的类型注解需要 Python 3.6 或更高版本；使用类型注释可以与以前的版本兼容",
        "variableFinalOverride": "“{name}”变量被标记为 Final，覆写了“{className}”类中同名的非 Final 变量",
        "variadicTypeArgsTooMany": "类型参数列表最多可以有一个已解包的 TypeVarTuple 或元组",
        "variadicTypeParamTooManyAlias": "类型别名最多可以有一个 TypeVarTuple 类型参数，但收到多个（{names}）",
        "variadicTypeParamTooManyClass": "泛型类最多可以有一个 TypeVarTuple 类型参数，但收到多个（{names}）",
        "walrusIllegal": "“:=”运算符需要 Python 3.8 或更高版本",
        "walrusNotAllowed": "此上下文中不允许不带括号使用“:=”运算符",
        "wildcardInFunction": "类或函数中不允许使用通配符导入",
        "wildcardLibraryImport": "不允许使用通配符从库中导入",
        "wildcardPatternTypeAny": "通配符模式捕获的类型为 Any",
        "wildcardPatternTypePartiallyUnknown": "通配符模式捕获的类型部分未知",
        "wildcardPatternTypeUnknown": "通配符模式捕获的类型未知",
        "yieldFromIllegal": "使用“yield from”需要 Python 3.3 或更高版本",
        "yieldFromOutsideAsync": "async 函数中不允许使用 \"yield from\"",
        "yieldOutsideFunction": "不允许在函数或 lambda 之外使用“yield”",
        "yieldWithinComprehension": "不允许在推导式中使用“yield”",
        "zeroCaseStatementsFound": "match 语句必须至少包含一个 case 语句",
        "zeroLengthTupleNotAllowed": "此上下文中不允许使用零长度元组",
        "pyrightIgnoreCommentWithoutRule": "`pyright: ignore` 注释必须指定具体规则（例如 `# pyright: ignore[ruleName]`）",
        "typeIgnoreCommentWithoutRule": "`type: ignore` 注释必须指定具体规则（例如 `# type: ignore[ruleName]`）"
    },
    "DiagnosticAddendum": {
        "annotatedNotAllowed": "特化的“Annotated”形式不能与实例检查和类检查一起使用",
        "argParam": "实参对应于“{paramName}”形参",
        "argParamFunction": "实参对应于“{functionName}”函数中的“{paramName}”形参",
        "argsParamMissing": "“*{paramName}”形参没有相应的实参",
        "argsPositionOnly": "仅位置参数不匹配；应为 {expected}，但收到 {received}",
        "argumentType": "参数为“{type}”类型",
        "argumentTypes": "参数类型：（{types}）",
        "assignToNone": "无法将类型赋值给“None”类型",
        "asyncHelp": "你是说“async with”吗？",
        "baseClassIncompatible": "“{baseClass}”基类与“{type}”类型不兼容",
        "baseClassIncompatibleSubclass": "“{baseClass}”基类派生自与“{type}”类型不兼容的“{subclass}”",
        "baseClassOverriddenType": "“{baseClass}”基类提供被覆盖的“{type}”类型",
        "baseClassOverridesType": "“{baseClass}”基类覆盖了{type}”类型",
        "bytesTypePromotions": "将 disableBytesTypePromotions 设置为 false 以启用“bytearray”和“memoryview”的类型提升行为",
        "conditionalRequiresBool": "“{operandType}”类型的方法 __bool__ 返回“{boolReturnType}”类型而不是“bool”",
        "dataClassFieldLocation": "字段声明",
        "dataClassFrozen": "“{name}”已冻结",
        "dataProtocolUnsupported": "“{name}”是数据协议",
        "descriptorAccessBindingFailed": "无法绑定“{className}”描述器类的“{name}”方法",
        "descriptorAccessCallFailed": "无法调用“{className}”描述器类的“{name}”方法",
        "finalMethod": "Final 方法",
        "functionParamDefaultMissing": "“{name}”形参缺少默认参数",
        "functionParamName": "参数名称不匹配：“{destName}”与“{srcName}”",
        "functionParamPositionOnly": "仅位置参数不匹配; 参数“{name}”并非仅位置参数",
        "functionReturnTypeMismatch": "函数返回“{sourceType}”类型与“{destType}”类型不兼容",
        "functionTooFewParams": "函数接受的位置参数太少：应传入 {expected} 个，但只接受到 {received} 个",
        "functionTooManyParams": "函数接受的位置参数太多：应传入 {expected} 个，却接受到了 {received} 个",
        "genericClassNotAllowed": "不允许对实例检查或类检查使用具有类型参数的泛型类型",
        "incompatibleDeleter": "属性的 deleter 方法不兼容",
        "incompatibleGetter": "属性的 getter 方法不兼容",
        "incompatibleSetter": "属性的 setter 方法不兼容",
        "initMethodLocation": "__init__ 方法已在“{type}”类中定义",
        "initMethodSignature": "__init__ 的签名为“{type}”",
        "initSubclassLocation": "__init_subclass__ 方法已在“{name}”类中定义",
        "invariantSuggestionDict": "请考虑从“dict”切换到值类型为协变的“Mapping”",
        "invariantSuggestionList": "考虑从“list”切换到协变的“Sequence”",
        "invariantSuggestionSet": "请考虑从“set”切换到协变的“Container”",
        "isinstanceClassNotSupported": "实例和类检查不支持“{type}”",
        "keyNotRequired": "“{type}”中“{name}”不是必需的键，因此获取其值可能会导致运行时异常",
        "keyReadOnly": "“{name}”是“{type}”中的只读键",
        "keyRequiredDeleted": "“{name}”是必需的键，无法删除",
        "keyUndefined": "“{name}”不是“{type}”中定义的键",
        "kwargsParamMissing": "“**{paramName}”形参没有相应的实参",
        "listAssignmentMismatch": "“{type}”类型与目标列表不兼容",
        "literalAssignmentMismatch": "无法将“{sourceType}”赋值给类型“{destType}”",
        "matchIsNotExhaustiveHint": "如果不进行完全处理，请添加“case _: pass”",
        "matchIsNotExhaustiveType": "未处理的类型：“{type}”",
        "memberAssignment": "无法将“{type}”类型的表达式赋值给“{classType}”类的“{name}”成员",
        "memberIsAbstract": "未实现“{type}.{name}”",
        "memberIsAbstractMore": "还有 {count} 个...",
        "memberIsClassVarInProtocol": "“{name}”在协议中定义为 ClassVar",
        "memberIsInitVar": "成员“{name}”是仅初始字段",
        "memberIsInvariant": "可变成员“{name}”的类型应为不变（Invariant）",
        "memberIsNotClassVarInClass": "“{name}”必须定义为 ClassVar 才能与协议兼容",
        "memberIsNotClassVarInProtocol": "“{name}”未在协议中定义为 ClassVar",
        "memberIsNotReadOnlyInProtocol": "“{name}”在协议中不是只读的",
        "memberIsReadOnlyInProtocol": "“{name}”在协议中是只读的",
        "memberIsWritableInProtocol": "“{name}”在协议中是可写入的",
        "memberSetClassVar": "无法通过类实例赋值成员“{name}”，因为它是 ClassVar",
        "memberTypeMismatch": "“{name}”是不兼容的类型",
        "memberUnknown": "成员“{name}”未知",
        "metaclassConflict": "元类“{metaclass1}”与“{metaclass2}”存在冲突",
        "missingDeleter": "属性缺少 deleter 方法",
        "missingGetter": "属性缺少 getter 方法",
        "missingSetter": "属性缺少 setter 方法",
        "namedParamMissingInDest": "额外参数“{name}”",
        "namedParamMissingInSource": "缺少关键字参数“{name}”",
        "namedParamTypeMismatch": "类型为“{sourceType}”的关键字参数“{name}”与类型“{destType}”不兼容",
        "namedTupleNotAllowed": "不能对实例或类检查使用 NamedTuple",
        "newMethodLocation": "__new__ 方法已在类“{type}”中定义",
        "newMethodSignature": "__new__ 的签名为“{type}”",
        "newTypeClassNotAllowed": "不能将使用 NewType 创建的类用于实例和类检查",
        "noOverloadAssignable": "没有重载函数与“{type}”类型匹配",
        "noneNotAllowed": "None 不能参与实例检查或类检查",
        "orPatternMissingName": "缺少名称：{name}",
        "overloadIndex": "重载 {index} 是最接近的匹配项",
        "overloadNotAssignable": "“{name}”的一个或多个重载无法分配",
        "overloadSignature": "此处定义了重载签名",
        "overriddenMethod": "被覆写的方法",
        "overriddenSymbol": "被覆写的符号",
        "overrideInvariantMismatch": "覆写的“{overrideType}”类型与基类型“{baseType}”不同",
        "overrideIsInvariant": "可变量的类型应为不变（Invariant）",
        "overrideNoOverloadMatches": "没有与基类方法兼容的重载签名覆写",
        "overrideNotClassMethod": "覆写的方法没有一致与基类方法声明为类方法",
        "overrideNotInstanceMethod": "覆写的方法没有一致与基类方法声明为实例方法",
        "overrideNotStaticMethod": "覆写的方法没有一致与基类方法声明为静态方法",
        "overrideOverloadNoMatch": "覆写的方法未完全处理基类方法的所有重载",
        "overrideOverloadOrder": "覆写的重载方法必须与基类方法的顺序相同",
        "overrideParamKeywordNoDefault": "关键字参数“{name}”不匹配：基类方法参数具有默认参数值，覆写方法的参数不匹配",
        "overrideParamKeywordType": "关键字参数“{name}”类型不匹配：基类方法参数类型为“{baseType}”，覆写方法的参数类型为“{overrideType}”",
        "overrideParamName": "第 {index} 个参数名称不匹配：基类方法参数名称为“{baseName}”，覆写方法的参数名称为“{overrideName}”",
        "overrideParamNameExtra": "基类方法中缺少参数“{name}”",
        "overrideParamNameMissing": "覆写方法中缺少参数“{name}”",
        "overrideParamNamePositionOnly": "第 {index} 个参数不匹配：基类方法参数“{baseName}”是关键字参数，覆写方法参数为仅位置参数",
        "overrideParamNoDefault": "第 {index} 个参数不匹配：基类方法参数与覆写方法参数的默认值不匹配",
        "overrideParamType": "第 {index} 个参数类型不匹配：基类方法参数为类型“{baseType}”，覆写方法参数为类型“{overrideType}”",
        "overridePositionalParamCount": "位置参数个数不匹配：基类方法有 {baseCount} 个，但覆写方法有 {overrideCount} 个",
        "overrideReturnType": "返回类型不匹配：基类方法返回“{baseType}”类型，覆写方法返回“{overrideType}”类型",
        "overrideType": "基类将类型定义为“{type}”",
        "paramAssignment": "第 {index} 个参数：无法将“{sourceType}”类型赋值给“{destType}”类型",
        "paramSpecMissingInOverride": "覆写方法中缺少 ParamSpec 参数",
        "paramType": "参数为“{paramType}”类型",
        "privateImportFromPyTypedSource": "改为从“{module}”导入",
        "propertyAccessFromProtocolClass": "不能以类变量形式访问协议类中定义的属性",
        "propertyMethodIncompatible": "属性方法“{name}”不兼容",
        "propertyMethodMissing": "覆写中缺少属性方法“{name}”",
        "propertyMissingDeleter": "属性“{name}”未定义删除方法",
        "propertyMissingSetter": "属性“{name}”未定义赋值方法",
        "protocolIncompatible": "“{sourceType}”与协议“{destType}”不兼容",
        "protocolMemberMissing": "“{name}”不存在",
        "protocolRequiresRuntimeCheckable": "协议类必须为 @runtime_checkable 才能用于实例和类检查",
        "protocolSourceIsNotConcrete": "“{sourceType}”不是具体类类型，无法赋值给“{destType}”类型",
        "protocolUnsafeOverlap": "“{name}”的属性与协议具有相同的名称",
        "pyrightCommentIgnoreTip": "使用“# pyright: ignore[<diagnostic rules>]”取消单行诊断",
        "readOnlyAttribute": "“{name}”为只读属性",
        "seeClassDeclaration": "查看类声明",
        "seeDeclaration": "查看声明",
        "seeFunctionDeclaration": "查看函数声明",
        "seeMethodDeclaration": "查看方法声明",
        "seeParameterDeclaration": "查看参数声明",
        "seeTypeAliasDeclaration": "查看类型别名声明",
        "seeVariableDeclaration": "查看变量声明",
        "tupleAssignmentMismatch": "“{type}”类型与目标元组不兼容",
        "tupleEntryTypeMismatch": "元组项 {entry} 的类型不正确",
        "tupleSizeIndeterminateSrc": "元组大小不匹配；应为 {expected}，但得到不定长度元组",
        "tupleSizeIndeterminateSrcDest": "元组大小不匹配；至少应为 {expected}，但得到不定长度元组",
        "tupleSizeMismatch": "元组大小不匹配；应为 {expected}，但得到 {received}",
        "tupleSizeMismatchIndeterminateDest": "元组大小不匹配；至少应为 {expected}，但得到 {received}",
        "typeAliasInstanceCheck": "使用“type”语句创建的类型别名不能与实例检查和类检查一起使用",
        "typeAssignmentMismatch": "无法将“{sourceType}”类型赋值给“{destType}”类型",
        "typeBound": "“{sourceType}”类型与类型变量“{destType}”的绑定类型“{name}”不兼容",
        "typeConstrainedTypeVar": "“{type}”类型与限定类型变量“{name}”不兼容",
        "typeIncompatible": "“{sourceType}”与“{destType}”不兼容",
        "typeNotClass": "“{type}”不是类",
        "typeNotStringLiteral": "“{type}”不是字符串字面值",
        "typeOfSymbol": "“{name}”为“{type}”类型",
        "typeParamSpec": "“{type}”类型与 ParamSpec “{name}”不兼容",
        "typeUnsupported": "“{type}”类型不受支持",
        "typeVarDefaultOutOfScope": "类型变量“{name}”不在范围内",
        "typeVarIsContravariant": "类型参数“{name}”是逆变的，但“{sourceType}”不是“{destType}”的超类型",
        "typeVarIsCovariant": "类型参数“{name}”是协变的，但“{sourceType}”不是“{destType}”的子类型",
        "typeVarIsInvariant": "类型参数“{name}”是不变的，但“{sourceType}”与“{destType}”不同",
        "typeVarNotAllowed": "不允许对实例检查或类检查使用 TypeVar",
        "typeVarTupleRequiresKnownLength": "TypeVarTuple 不能绑定到长度未知的元组",
        "typeVarUnnecessarySuggestion": "请改用 {type}",
        "typeVarUnsolvableRemedy": "提供一个重载，该重载指定未提供参数时的返回类型",
        "typeVarsMissing": "缺少类型变量：{names}",
        "typedDictBaseClass": "类“{type}”不是 TypedDict",
        "typedDictClassNotAllowed": "不允许对实例或类检查使用 TypedDict 类",
        "typedDictClosedExtraNotAllowed": "无法添加项“{name}”",
        "typedDictClosedExtraTypeMismatch": "无法添加“{type}”类型的项“{name}”",
        "typedDictClosedFieldNotRequired": "无法添加项“{name}”，因为它必须是 NotRequired",
        "typedDictExtraFieldNotAllowed": "“{type}”中不存在“{name}”",
        "typedDictExtraFieldTypeMismatch": "“{name}”的类型与“{type}”中的“__extra_items__”类型不兼容",
        "typedDictFieldMissing": "“{type}”中缺少“{name}”",
        "typedDictFieldNotReadOnly": "“{name}”在“{type}”中不是只读的",
        "typedDictFieldNotRequired": "“{type}”中不需要“{name}”",
        "typedDictFieldRequired": "“{type}”中需要“{name}”",
        "typedDictFieldTypeMismatch": "类型“{type}”不可赋值给项“{name}”",
        "typedDictFieldUndefined": "“{name}”是类型“{type}”中的未定义项",
        "typedDictFinalMismatch": "“{sourceType}”与“{destType}”不兼容，因为 @final 不匹配",
        "typedDictKeyAccess": "使用 [\"{name}\"] 引用 TypedDict 中的项",
        "typedDictNotAllowed": "TypedDict 不能用于实例检查或类检查",
        "unhashableType": "“{type}”类型不可哈希",
        "uninitializedAbstractVariable": "实例变量“{name}”已在抽象基类“{classType}”中定义，但未初始化",
        "unreachableExcept": "“{exceptionType}”是“{parentType}”的子类",
        "useDictInstead": "使用 Dict[T1, T2] 表示字典类型",
        "useListInstead": "使用 List[T] 表示列表类型或 Union[T1, T2] 表示示联合类型",
        "useTupleInstead": "使用 tuple[T1, ..., Tn] 表示元组类型或使用 Union[T1, T2] 表示联合类型",
        "useTypeInstead": "改用 Type[T]",
        "varianceMismatchForClass": "类型参数“{typeVarName}”的差异与基类“{className}”不兼容",
        "varianceMismatchForTypeAlias": "类型参数“{typeVarName}”的差异与“{typeAliasParam}”不兼容"
    },
    "Service": {
        "longOperation": "枚举工作区源文件需要很长时间。请考虑打开子文件夹。[了解详细信息](https://aka.ms/workspace-too-many-files)"
    }
}