{
    "CodeAction": {
        "createTypeStub": "创建 Type Stub",
        "createTypeStubFor": "为“{moduleName}”创建 Type Stub",
        "executingCommand": "正在执行命令",
        "filesToAnalyzeCount": "{count} 个要分析的文件",
        "filesToAnalyzeOne": "1 个要分析的文件",
        "findingReferences": "正在查找引用",
        "organizeImports": "整理 Imports",
        "renameShadowedFile": "将“{oldFile}”重命名为“{newFile}”"
    },
    "Completion": {
        "autoImportDetail": "自动导入",
        "indexValueDetail": "索引值"
    },
    "Diagnostic": {
        "abstractMethodInvocation": "不能调用未实现的抽象方法“{method}”",
        "annotatedMetadataInconsistent": "Annotated metadata type \"{metadataType}\" is not compatible with type \"{type}\"",
        "annotatedParamCountMismatch": "参数标注数量不匹配: 应为 {expected} 个，但得到 {received} 个",
        "annotatedTypeArgMissing": "“Annotated”应有一个类型参数和至少一个标注",
        "annotationBytesString": "类型表达式不能使用字节字符串文本",
        "annotationFormatString": "类型表达式中不能使用 f-string",
        "annotationNotSupported": "不支持使用此语句作为类型标注",
        "annotationRawString": "类型表达式不能使用原始字符串文本",
        "annotationSpansStrings": "类型表达式不能跨越多个字符串字面值",
        "annotationStringEscape": "类型表达式不能包含转义字符",
        "argAssignment": "“{argType}”类型的实参无法赋值给“{paramType}”类型的形参",
        "argAssignmentFunction": "“{argType}”类型的实参无法赋值给函数“{functionName}”中“{paramType}”类型的形参",
        "argAssignmentParam": "“{argType}”类型的实参无法赋值给“{paramType}”类型的形参“{paramName}”",
        "argAssignmentParamFunction": "“{argType}”类型的实参无法赋值给函数“{functionName}”中“{paramType}”类型的形参“{paramName}”",
        "argMissingForParam": "{name} 没有传入值",
        "argMissingForParams": "{names} 没有传入值",
        "argMorePositionalExpectedCount": "还需要传入 {expected} 个位置参数",
        "argMorePositionalExpectedOne": "还需要传入 1 个位置参数",
        "argPositional": "需要传入位置参数",
        "argPositionalExpectedCount": "需要传入 {expected} 个位置参数",
        "argPositionalExpectedOne": "需要传入 1 个位置参数",
        "argTypePartiallyUnknown": "部分参数的类型未知（Unknown）",
        "argTypeAny": "参数类型为 Any",
        "argTypeUnknown": "参数类型未知（Unknown）",
        "assertAlwaysTrue": "断言（assert）的计算结果始终为 True",
        "assertTypeArgs": "“assert_type”需要传入两个位置参数",
        "assertTypeTypeMismatch": "“assert_type”不匹配：应是“{expected}”类型的值，但传入的值类型是“{received}”",
        "assignmentExprComprehension": "海象运算符赋值的变量名“{name}”不能与推导式使用的变量重名",
        "assignmentExprContext": "海象运算符只能在模块、函数或 lambda 中使用",
        "assignmentExprInSubscript": "在下标（value[...]）中使用海象表达式需要 Python 3.10 或更高版本",
        "assignmentInProtocol": "必须在类中显式声明协议类中声明的实例变量或类变量",
        "assignmentTargetExpr": "表达式不能被赋值",
        "asyncNotInAsyncFunction": "异步函数之外不允许使用“async for/with/...”",
        "awaitIllegal": "使用“await”需要 Python 为 3.5 或更高版本",
        "awaitNotAllowed": "类型标注中不能使用“await”",
        "awaitNotInAsync": "仅允许在异步函数内使用“await”",
        "backticksIllegal": "Python 3.x 中不支持使用反引号包围的表达式；请改用 repr(...)",
        "baseClassCircular": "类不能继承自身",
        "baseClassFinal": "基类“{type}”被 @final 标记，因此不能被子类继承",
        "baseClassIncompatible": "{type} 的基类之间不相互兼容",
        "baseClassInvalid": "类的参数必须是基类",
        "baseClassAny": "Any 类型的基类覆盖了派生类的类型",
        "baseClassMethodTypeIncompatible": "“{classType}”类的基类以不兼容的方式定义方法“{name}”",
        "baseClassUnknown": "未知类型的基类覆盖了派生类的类型",
        "baseClassVariableTypeIncompatible": "“{classType}”类的基类以不兼容的方式定义变量“{name}”",
        "binaryOperationNotAllowed": "类型标注中不允许使用二元运算符",
        "bindTypeMismatch": "无法绑定方法“{methodName}”，因为“{type}”不能赋值给参数“{paramName}”",
        "breakOutsideLoop": "“break”只能在循环中使用",
        "callableExtraArgs": "“Callable”只能传入两个类型参数",
        "callableFirstArg": "应为参数类型列表或“...”",
        "callableNotInstantiable": "无法实例化“{type}”类型",
        "callableSecondArg": "返回类型应为“Callable”的第二个类型参数",
        "casePatternIsIrrefutable": "只有最后一个 case 语句允许使用模式“_”",
        "classAlreadySpecialized": "“{type}”上的类型变量 (TypeVar) 已被特化",
        "classDecoratorTypeAny": "返回 Any 类型的类装饰器覆盖了原始类的类型",
        "classDecoratorTypeUnknown": "未标注返回类型的类装饰器会覆盖原始类的类型，因此已忽略此装饰器",
        "classDefinitionCycle": "“{name}”类存在循环定义",
        "classGetItemClsParam": "重写的 __class_getitem__ 方法应使用“cls”参数",
        "classMethodClsParam": "类方法应使用“cls”参数",
        "classNotRuntimeSubscriptable": "在“{name}”类上使用的下标将导致运行时异常，应将这整个类型标注写成字符串形式",
        "classPatternBuiltInArgPositional": "当使用类本身进行模式匹配时，随后的括号内部只能接受位置参数形式的子模式",
        "classPatternPositionalArgCount": "“{type}”类的位置模式太多：应为 {expected}，但收到了 {received}",
        "classPatternTypeAlias": "无法在类模式中使用“{type}”，因为它是特化过的类型别名",
        "classPropertyDeprecated": "装饰器 @classmethod + @property 的组合已在 Python 3.11 中弃用，并将在 Python 3.13 中删除",
        "classTypeParametersIllegal": "类的类型参数语法 (PEP 695) 需要 Python 3.12 或更高版本",
        "classVarFirstArgMissing": "“ClassVar”内应存在且仅存在一个类型参数",
        "classVarNotAllowed": "此上下文中不允许使用“ClassVar”",
        "classVarOverridesInstanceVar": "被标记为 ClassVar 的“{name}”覆盖了类“{className}”中的同名实例属性",
        "classVarTooManyArgs": "“ClassVar”内应存在且仅存在一个类型参数",
        "classVarWithTypeVar": "“ClassVar”的类型参数中不能包含类型变量 (TypeVar)",
        "clsSelfParamTypeMismatch": "参数“{name}”的类型必须是类“{classType}”或其基类",
        "codeTooComplexToAnalyze": "代码太过复杂以至于无法分析；请将其重构为多个小规模代码的组合，或减少条件代码路径来降低复杂度",
        "collectionAliasInstantiation": "无法实例化类型“{type}”，请改用“{alias}”",
        "comparisonAlwaysFalse": "条件的计算结果始终为 False，因为类型“{leftType}”和“{rightType}”之间不存在交集",
        "comparisonAlwaysTrue": "条件的计算结果始终为 True，因为类型“{leftType}”和“{rightType}”之间不存在交集",
        "comprehensionInDict": "字典推导式中不能混入其他字典项，建议使用形似“{**comprehension, key: value}”的形式",
        "comprehensionInSet": "集合推导式中不能混入其他集合项，建议使用形似“{*comprehension, item}”的形式",
        "concatenateContext": "该上下文中不允许使用“Concatenate”",
        "concatenateParamSpecMissing": "“Concatenate”的最后一个类型参数必须是 ParamSpec 或“...”",
        "concatenateTypeArgsMissing": "“Concatenate”中至少需要传入两个类型参数",
        "conditionalOperandInvalid": "非法的条件操作符类型 {type}",
        "constantRedefinition": "不能重新定义常量 “{name}” （名称全大写）",
        "constructorParametersMismatch": "“{classType}” 类中方法 __new__ 和 __init__ 的签名不匹配",
        "containmentAlwaysFalse": "表达式的计算结果始终为 False，因为类型 “{leftType}” 和 “{rightType}” 之间不存在交集",
        "containmentAlwaysTrue": "表达式的计算结果始终为 True，因为类型 “{leftType}” 和 “{rightType}” 之间不存在交集",
        "continueInFinally": "“continue” 不能在 finally 子句中使用",
        "continueOutsideLoop": "“continue” 只能在循环中使用",
        "coroutineInConditionalExpression": "条件表达式中使用未 await 的协程作为判断条件，其计算结果始终为 True",
        "dataClassBaseClassFrozen": "非冻结 (frozen=False) 的 dataclass 不能继承已冻结 (frozen=True) 的 dataclass",
        "dataClassBaseClassNotFrozen": "冻结 (frozen=True) 的 dataclass 不能继承非冻结 (frozen=False) 的 dataclass",
        "dataClassConverterFunction": "“{argType}”类型的参数不是“{fieldType}”类型的字段“{fieldName}”的合法转换器",
        "dataClassConverterOverloads": "“{funcName}”的重载不是“{fieldType}”类型的字段“{fieldName}”的合法转换器",
        "dataClassFieldInheritedDefault": "“{fieldName}”替代同名字段，但缺少默认值",
        "dataClassFieldWithDefault": "没有默认值的字段不能出现在具有默认值的字段之后",
        "dataClassFieldWithPrivateName": "dataclass 的字段不能使用私有名称",
        "dataClassFieldWithoutAnnotation": "不带类型标注的 dataclass 字段将导致运行时异常",
        "dataClassPostInitParamCount": "dataclass 中声明的方法 __post_init__ 参数数量不正确；InitVar 字段数为 {expected}",
        "dataClassPostInitType": "dataclass 中声明的方法 __post_init__ 方法中“{fieldName}”字段的参数类型不匹配",
        "dataClassSlotsOverwrite": "类中已定义 __slots__",
        "dataClassTransformExpectedBoolLiteral": "需要静态推导结果为 True 或 False 的表达式",
        "dataClassTransformFieldSpecifier": "需要类或函数的元组，但得到类型“{type}”",
        "dataClassTransformPositionalParam": "“dataclass_transform”的所有参数都必须是关键字参数",
        "dataClassTransformUnknownArgument": "“dataclass_transform”不支持参数“{name}”",
        "dataProtocolInSubclassCheck": "issubclass 调用中不允许使用数据协议（包括非方法属性）",
        "declaredReturnTypePartiallyUnknown": "声明的返回类型“{returnType}”部分未知",
        "declaredReturnTypeUnknown": "声明的返回类型未知",
        "defaultValueContainsCall": "参数默认值表达式中不允许调用函数或使用可变对象",
        "defaultValueNotAllowed": "“*”或“**”的参数不能有默认值",
        "delTargetExpr": "无法删除的表达式",
        "deprecatedClass": "“{name}”类已弃用",
        "deprecatedConstructor": "“{name}”类的构造函数已弃用",
        "deprecatedDescriptorDeleter": "“{name}”描述器的“__delete__”方法已弃用",
        "deprecatedDescriptorGetter": "“{name}”描述器的“__get__”方法已弃用",
        "deprecatedDescriptorSetter": "“{name}”描述器的“__set__”方法已弃用",
        "deprecatedFunction": "“{name}”函数已弃用",
        "deprecatedMethod": "“{className}”类中的“{name}”方法已弃用",
        "deprecatedPropertyDeleter": "“{name}”属性的 deleter 已弃用",
        "deprecatedPropertyGetter": "“{name}”属性的 getter 已弃用",
        "deprecatedPropertySetter": "“{name}”属性的 setter 已弃用",
        "deprecatedType": "此类型自 Python {version} 起已弃用；请改用“{replacement}”",
        "dictExpandIllegalInComprehension": "推导式中不允许展开字典表达式",
        "dictInAnnotation": "类型标注中不允许使用字典表达式",
        "dictKeyValuePairs": "字典项必须包含键值对",
        "dictUnpackIsNotMapping": "字典解包运算符需要 Mapping 对象",
        "dunderAllSymbolNotPresent": "“{name}”已在 __all__ 中声明，但未在模块中定义",
        "duplicateArgsParam": "应有且仅有一个“*”参数",
        "duplicateBaseClass": "不允许重复的基类",
        "duplicateCapturePatternTarget": "“{name}”捕获目标不能在同一模式中多次出现",
        "duplicateCatchAll": "应有且仅有一个能够捕获所有错误的 except 子句",
        "duplicateEnumMember": "重复的枚举声明“{name}”",
        "duplicateGenericAndProtocolBase": "应有且仅有一个 Generic[...] 或 Protocol[...] 基类",
        "duplicateImport": "“{importName}”被重复导入",
        "duplicateKeywordOnly": "应有且仅有一个“*”分隔出关键字参数",
        "duplicateKwargsParam": "应有且仅有一个可变关键字 (“**kwds”) 参数",
        "duplicateParam": "“{name}”参数声明重复",
        "duplicatePositionOnly": "函数参数中应有且仅有一个“/”",
        "duplicateStarPattern": "在序列形式的模式匹配中应有且仅有一个“*”项",
        "duplicateStarStarPattern": "应有且仅有一个“**”项",
        "duplicateUnpack": "仅允许使用一次 Unpack",
        "ellipsisAfterUnpacked": "“...”不能与解包了的 TypeVarTuple 或元组一起使用",
        "ellipsisContext": "“...”不允许在此上下文中使用",
        "ellipsisSecondArg": "“...”仅允许作为这两个参数中的第二个参数",
        "enumClassOverride": "“{name}”枚举类使用 @final 装饰，不能派生子类",
        "enumMemberDelete": "无法删除枚举成员“{name}”",
        "enumMemberSet": "无法分配枚举成员“{name}”",
        "enumMemberTypeAnnotation": "枚举成员不允许使用类型注释",
        "exceptionGroupIncompatible": "异常组语法（“except*”）需要使用 Python 3.11 或更高版本",
        "exceptionGroupTypeIncorrect": "Exception type in except* cannot derive from BaseGroupException",
        "exceptionTypeIncorrect": "“{type}”不派生自 BaseException",
        "exceptionTypeNotClass": "“{type}”不是有效的异常（Exception）类",
        "exceptionTypeNotInstantiable": "Exception “{type}”的构造函数需要一个或多个参数",
        "expectedAfterDecorator": "装饰器下方应存在函数或类声明",
        "expectedArrow": "应存在有“->”符号和随后的返回类型的类型注解",
        "expectedAsAfterException": "expect Exception 语句后只能有“as”",
        "expectedAssignRightHandExpr": "“=”右侧应为表达式",
        "expectedBinaryRightHandExpr": "运算符右侧应为表达式",
        "expectedBoolLiteral": "应为 True 或 False",
        "expectedCase": "应为“case”语句",
        "expectedClassName": "应填写类名",
        "expectedCloseBrace": "“{”未闭合",
        "expectedCloseBracket": "“[”未闭合",
        "expectedCloseParen": "“(”未闭合",
        "expectedColon": "应为“:”",
        "expectedComplexNumberLiteral": "模式匹配需要复数字面量",
        "expectedDecoratorExpr": "Python 3.9 之前不支持表达式形式的装饰器",
        "expectedDecoratorName": "应为装饰器名称",
        "expectedDecoratorNewline": "装饰器末尾应为换行",
        "expectedDelExpr": "“del”后应为表达式",
        "expectedElse": "应为“else”",
        "expectedEquals": "应为“=”",
        "expectedExceptionClass": "异常类或对象无效",
        "expectedExceptionObj": "应为异常对象、异常类或 None",
        "expectedExpr": "应为表达式",
        "expectedFunctionAfterAsync": "“async”后面应为函数定义",
        "expectedFunctionName": "“def”后应为函数名称",
        "expectedIdentifier": "应为标识符",
        "expectedImport": "应为“import”",
        "expectedImportAlias": "“as”后面应指定别称",
        "expectedImportSymbols": "“import”后应有符号名称",
        "expectedIn": "应有“in”",
        "expectedInExpr": "“in”后应有表达式",
        "expectedIndentedBlock": "应有缩进块",
        "expectedMemberName": "“.”后应有成员名称",
        "expectedModuleName": "应有模块名称",
        "expectedNameAfterAs": "“as”后应有符号名",
        "expectedNamedParameter": "关键字参数必须跟在“*”之后",
        "expectedNewline": "需要换行符",
        "expectedNewlineOrSemicolon": "语句必须用换行符或分号分隔",
        "expectedOpenParen": "应有“(”",
        "expectedParamName": "应为参数名称",
        "expectedPatternExpr": "应为模式表达式",
        "expectedPatternSubjectExpr": "应为模式主题表达式",
        "expectedPatternValue": "应为“a.b”形式的模式值表达式",
        "expectedReturnExpr": "“return”后应有表达式",
        "expectedSliceIndex": "应为索引或切片表达式",
        "expectedTypeNotString": "应为类型而非字符串字面值",
        "expectedTypeParameterName": "应为类型参数名称",
        "expectedYieldExpr": "yield 语句中应为表达式",
        "finalClassIsAbstract": "“{type}”类被标记为最终类，必须实现所有抽象符号",
        "finalContext": "不允许在此上下文中使用“Final”",
        "finalInLoop": "无法在循环中分配 \"Final\" 变量",
        "finalMethodOverride": "“{name}”方法无法重写在“{className}”类中定义的最终方法",
        "finalNonMethod": "不能将函数“{name}”标记为 @final，因为它不是方法",
        "finalReassigned": "“{name}”已声明为 Final，无法重新赋值",
        "finalRedeclaration": "“{name}”此前已声明为 Final",
        "finalRedeclarationBySubclass": "无法重新声明“{name}”，因为父类“{className}”将其声明为 Final",
        "finalTooManyArgs": "“Final”后应为单个类型参数",
        "finalUnassigned": "“{name}”声明为“Final”，但未赋值",
        "formatStringBrace": "格式化字符串字面值中不允许使用单个右大括号；请使用双右大括号",
        "formatStringBytes": "格式化字符串字面值不能为字节",
        "formatStringDebuggingIllegal": "格式化字符串调试说明符“=”需要 Python 3.8 或更高版本",
        "formatStringEscape": "Python 3.12 之前格式化字符串的表达式部分中不允许使用转义序列（反斜杠）",
        "formatStringExpectedConversion": "格式化字符串中“!”后缺少转换说明符",
        "formatStringIllegal": "格式化字符串字面值需要 Python 3.6 或更高版本",
        "formatStringInPattern": "模式中不允许使用格式化字符串",
        "formatStringNestedFormatSpecifier": "格式化字符串说明符内表达式嵌套太深",
        "formatStringNestedQuote": "在 Python 3.12 之前，嵌套的字符串不能使用与格式化字符串相同的引号字符",
        "formatStringUnicode": "格式化字符串字面值不能为 Unicode",
        "formatStringUnterminated": "格式化字符串中有未终止的表达式；需要“}”",
        "functionDecoratorTypeAny": "Any 类型的函数装饰器覆盖了函数类型",
        "functionDecoratorTypeUnknown": "未标类型的函数装饰器会覆盖函数类型，因此已忽略装饰器",
        "functionInConditionalExpression": "条件表达式中含有未调用的函数，其计算结果始终为 True",
        "functionTypeParametersIllegal": "函数类型参数语法需要 Python 3.12 或更高版本",
        "futureImportLocationNotAllowed": "__future__ 导入必须位于文件的开头",
        "generatorAsyncReturnType": "异步生成器函数的返回类型必须与“AsyncGenerator[{yieldType}, Any]”兼容",
        "generatorNotParenthesized": "不是唯一参数的生成器表达式必须带圆括号",
        "generatorSyncReturnType": "生成器函数的返回类型必须与“Generator[{yieldType}, Any, Any]”兼容",
        "genericBaseClassNotAllowed": "“Generic”基类不能与类型参数语法一起使用",
        "genericClassAssigned": "无法赋值泛型类类型",
        "genericClassDeleted": "无法删除泛型类类型",
        "genericInstanceVariableAccess": "通过类访问泛型实例变量是不明确的",
        "genericNotAllowed": "“Generic”在此上下文中无效",
        "genericTypeAliasBoundTypeVar": "类中的泛型类型别名不能使用绑定类型变量 {names}",
        "genericTypeArgMissing": "“Generic”需要至少一个类型参数",
        "genericTypeArgTypeVar": "“Generic”的类型参数必须是类型变量",
        "genericTypeArgUnique": "“Generic”的类型参数必须唯一",
        "globalReassignment": "“{name}”已在全局声明之前定义",
        "globalRedefinition": "“{name}”已全局声明",
        "implicitStringConcat": "不允许隐式字符串拼接",
        "importCycleDetected": "导入链中检测到循环导入",
        "importDepthExceeded": "导入链深度超过 {depth} 层",
        "importResolveFailure": "无法解析导入“{importName}”",
        "importSourceResolveFailure": "无法从源码解析导入“{importName}”",
        "importSymbolUnknown": "“{name}”是未知的导入符号",
        "incompatibleMethodOverride": "“{name}”方法以不兼容的方式重写了“{className}”类",
        "inconsistentIndent": "取消缩进量与之前的缩进不匹配",
        "inconsistentTabs": "缩进中混用了制表符和空格",
        "initMethodSelfParamTypeVar": "\"__init__\" 方法 “self” 参数的类型注释不能包含类范围的类型变量",
        "initMustReturnNone": "“__init__”的返回类型必须为 None",
        "initSubclassCallFailed": "__init_subclass__ 方法的关键字参数不正确",
        "initSubclassClsParam": "重写的 __init_subclass__ 应采用“cls”参数",
        "initVarNotAllowed": "此上下文中不允许使用“InitVar”",
        "instanceMethodSelfParam": "实例方法应采用“self”参数",
        "instanceVarOverridesClassVar": "实例变量“{name}”覆盖了“{className}”类中的同名类变量",
        "instantiateAbstract": "无法实例化“{type}抽象类”",
        "instantiateProtocol": "无法实例化协议类“{type}”",
        "internalBindError": "绑定“{file}”文件时发生内部错误：{message}",
        "internalParseError": "分析“{file}”文件时发生内部错误：{message}",
        "internalTypeCheckingError": "对“{file}”文件类型检查时发生内部错误：{message}",
        "invalidIdentifierChar": "标识符中的字符无效",
        "invalidStubStatement": "语句在类型存根文件中无意义",
        "invalidTokenChars": "形符中的字符“{text}”无效",
        "isInstanceInvalidType": "“isinstance”的第二个参数必须是单个类或由多个类构成的元组",
        "isSubclassInvalidType": "“issubclass”的第二个参数必须是单个类或由多个类构成的元组",
        "keyValueInSet": "集合内不允许使用键/值对",
        "keywordArgInTypeArgument": "关键字参数不能在类型参数列表中使用",
        "keywordArgShortcutIllegal": "关键字参数快捷方式需要 Python 3.14 或更高版本",
        "keywordOnlyAfterArgs": "“*”参数后不允许使用仅限关键字的参数分隔符",
        "keywordParameterMissing": "一个或多个关键字参数必须在“*”参数之后",
        "keywordSubscriptIllegal": "下标中不支持关键字参数",
        "lambdaReturnTypeAny": "lambda 的返回类型为 Any",
        "lambdaReturnTypePartiallyUnknown": "lambda 的返回类型“{returnType}”部分未知",
        "lambdaReturnTypeUnknown": "lambda 的返回类型未知",
        "listAssignmentMismatch": "无法将“{type}”类型的表达式赋值给目标列表",
        "listInAnnotation": "类型标注中不允许使用列表表达式",
        "literalEmptyArgs": "“Literal”后应有一个或多个类型参数",
        "literalNamedUnicodeEscape": "“文本”字符串批注不支持已命名的 unicode 转义序列",
        "literalNotAllowed": "如果没有类型参数，则“Literal”不能用于此上下文",
        "literalNotCallable": "无法实例化 Literal 类型",
        "literalUnsupportedType": "“Literal”的类型参数必须是字面值（None、int、bool、str 或 bytes）或枚举值",
        "matchIncompatible": "match 语句需要 Python 3.10 或更高版本",
        "matchIsNotExhaustive": "match 语句中的匹配条件不能彻底处理所有值",
        "maxParseDepthExceeded": "超出最大分析深度；请将表达式拆解为较小的子表达式",
        "memberAccess": "无法获取“{type}”类型的“{name}”成员",
        "memberDelete": "无法删除“{type}”类型的“{name}”成员",
        "memberSet": "无法为“{type}”类型的“{name}”成员赋值",
        "metaclassConflict": "派生类的元类必须是其所有基类的元类的子类",
        "metaclassDuplicate": "只能提供一个元类",
        "metaclassIsGeneric": "元类不能为泛型",
        "methodNotDefined": "未定义“{name}”方法",
        "methodNotDefinedOnType": "“{type}”类型上未定义“{name}”方法",
        "methodOrdering": "无法创建一致的方法排序",
        "methodOverridden": "“{name}”在不兼容“{type}”类型的“{className}”类中替代同名的方法",
        "methodReturnsNonObject": "“{name}”方法不返回对象",
        "missingSuperCall": "“{methodName}”方法不调用父类的同名方法",
        "mixingBytesAndStr": "Bytes 和 str 值无法串联",
        "moduleAsType": "模块不能用作类型",
        "moduleNotCallable": "模块不能调用",
        "moduleUnknownMember": "“{memberName}”不是“{moduleName}”模块的已知成员",
        "namedExceptAfterCatchAll": "全部捕获的 except 子句后不能出现命名的 except 子句",
        "namedParamAfterParamSpecArgs": "“{name}”关键字参数不能出现在 ParamSpec args 参数之后的签名中",
        "namedTupleEmptyName": "命名元组中的名称不能为空",
        "namedTupleEntryRedeclared": "无法重写“{name}”，因为父类“{className}”是命名的元组",
        "namedTupleFirstArg": "第一个参数应为命名元组的类名",
        "namedTupleMultipleInheritance": "NamedTuple 不支持多继承",
        "namedTupleNameKeyword": "字段名称不能是关键字",
        "namedTupleNameType": "应为指定每项名称和类型的二元元组",
        "namedTupleNameUnique": "命名元组中的名称必须唯一",
        "namedTupleNoTypes": "“namedtuple”不提供元组项的类型；请改用“NamedTuple”",
        "namedTupleSecondArg": "应将命名元组项列表作为第二个参数",
        "newClsParam": "重写的 __new__ 应接受“cls”参数",
        "newTypeAnyOrUnknown": "NewType 的第二个参数必须是已知类，而不是“Any”或未知类型",
        "newTypeBadName": "NewType 的第一个参数必须是字符串字面值",
        "newTypeLiteral": "NewType 不能与 Literal 类型一起使用",
        "newTypeNameMismatch": "必须将 NewType 赋值给同名变量",
        "newTypeNotAClass": "应为 NewType 的第二个参数的类",
        "newTypeParamCount": "NewType 需要两个位置参数",
        "newTypeProtocolClass": "NewType 不能与结构类型（协议类或 TypedDict 类）一起使用",
        "noOverload": "“{name}”的重载与提供的参数不匹配",
        "noReturnContainsReturn": "返回类型声明为“NoReturn”的函数不能包含 return 语句",
        "noReturnContainsYield": "返回类型声明为“NoReturn”的函数不能包含 yield 语句",
        "noReturnReturnsNone": "返回类型声明为“NoReturn”的函数无法返回“None”",
        "nonDefaultAfterDefault": "非默认参数不应位于默认参数后方",
        "nonLocalInModule": "不允许在模块层级使用非局部声明",
        "nonLocalNoBinding": "找不到非局部变量“{name}”的绑定",
        "nonLocalReassignment": "“{name}”已在非局部声明之前赋值",
        "nonLocalRedefinition": "“{name}”已声明为非局部变量",
        "noneNotCallable": "无法调用“None”类型的对象",
        "noneNotIterable": "不能迭代“None”类型的对象",
        "noneNotSubscriptable": "不能取“None”类型的对象的下标",
        "noneNotUsableWith": "“None”类型的对象不能与“with”一起使用",
        "noneOperator": "“None”不支持运算符“{operator}”",
        "noneUnknownMember": "“{name}”不是“None”的已知成员",
        "notRequiredArgCount": "“NotRequired”之后应为单个类型参数",
        "notRequiredNotInTypedDict": "此上下文中不允许使用“NotRequired”",
        "objectNotCallable": "“{type}”类型的对象不可调用",
        "obscuredClassDeclaration": "“{name}”类的声明被同名的声明覆盖",
        "obscuredFunctionDeclaration": "“{name}”函数的声明被同名声明覆盖",
        "obscuredMethodDeclaration": "“{name}”方法的声明被同名声明覆盖",
        "obscuredParameterDeclaration": "“{name}”参数的声明被同名声明覆盖",
        "obscuredTypeAliasDeclaration": "“{name}”类型别名的声明被同名声明覆盖",
        "obscuredVariableDeclaration": "“{name}”变量声明被同名声明覆盖",
        "operatorLessOrGreaterDeprecated": "Python 3 不支持“<>”运算符；请改用“!=”",
        "optionalExtraArgs": "“Optional”后面应有一个类型参数",
        "orPatternIrrefutable": "必定匹配模式仅允许作为“or”模式中的最后一个子模式",
        "orPatternMissingName": "“or”模式中的所有子节点必须以相同的名称为目标",
        "overlappingKeywordArgs": "类型化字典与以下关键字参数重复：{names}",
        "overlappingOverload": "永远不会使用“{name}”的重载 {obscured}，因为其参数与重载 {obscuredBy} 重叠",
        "overloadAbstractImplMismatch": "重载必须与实现的抽象状态匹配",
        "overloadAbstractMismatch": "重载必须全部为抽象重载或非抽象重载",
        "overloadClassMethodInconsistent": "“{name}”的重载使用 @classmethod 的方式不一致",
        "overloadFinalInconsistencyImpl": "“{name}”的重载被标记为 @final，但实现未被标记",
        "overloadFinalInconsistencyNoImpl": "“{name}”的 {index} 重载被标记为 @final，但重载 1 未被标记",
        "overloadImplementationMismatch": "重载实现与 {index} 重载的签名不一致",
        "overloadReturnTypeMismatch": "“{name}”的 {prevIndex} 重载与 {newIndex} 重载重复，并返回不兼容的类型",
        "overloadStaticMethodInconsistent": "“{name}”的重载使用 @staticmethod 的方式不一致",
        "overloadWithoutImplementation": "“{name}”重载缺少实现",
        "overriddenMethodNotFound": "“{name}”方法已标记为覆写，但基类中不存在同名方法",
        "overrideDecoratorMissing": "“{name}”方法未标记为覆写，但覆写了“{className}”类中的方法",
        "paramAfterKwargsParam": "“**”参数后不应再有参数",
        "paramAlreadyAssigned": "“{name}”参数已赋值",
        "paramAnnotationMissing": "“{name}”参数缺少类型标注",
        "paramAssignmentMismatch": "无法将“{sourceType}”类型的表达式赋值给“{paramType}”类型的参数",
        "paramNameMissing": "缺少名为“{name}”的参数",
        "paramSpecArgsKwargsUsage": "ParamSpec 的“args”和“kwargs”成员必须同时出现在函数签名中",
        "paramSpecArgsMissing": "缺少 ParamSpec “{type}”的参数",
        "paramSpecArgsUsage": "ParamSpec 的“args”成员仅在与 *args 参数一起使用时有效",
        "paramSpecAssignedName": "必须将 ParamSpec 赋值给名为“{name}”的变量",
        "paramSpecContext": "此上下文中不允许使用 ParamSpec",
        "paramSpecDefaultNotTuple": "ParamSpec 的默认值应为省略号、元组表达式或 ParamSpec",
        "paramSpecFirstArg": "应为 ParamSpec 第一个参数的名称",
        "paramSpecKwargsUsage": "ParamSpec 的“kwargs”成员仅在与 **kwargs 参数一起使用时有效",
        "paramSpecNotUsedByOuterScope": "ParamSpec “{name}”在此上下文中没有意义",
        "paramSpecUnknownArg": "ParamSpec 不支持多个参数",
        "paramSpecUnknownMember": "“{name}”不是 ParamSpec 的已知成员",
        "paramSpecUnknownParam": "“{name}”是 ParamSpec 的未知参数",
        "paramTypeAny": "“{paramName}”参数类型为 Any",
        "paramTypeCovariant": "参数类型中不能使用协变类型变量",
        "paramTypePartiallyUnknown": "“{paramName}”参数的类型部分未知",
        "paramTypeUnknown": "“{paramName}”参数的类型未知",
        "parenthesizedContextManagerIllegal": "“with”语句中的括号需要 Python 3.9 或更高版本",
        "patternNeverMatches": "主题类型“{type}”的模式永远不会匹配",
        "positionArgAfterNamedArg": "位置参数不能出现在关键字参数之后",
        "positionOnlyAfterArgs": "“*”参数后不允许使用仅位置参数分隔符",
        "positionOnlyAfterKeywordOnly": "“/”参数必须出现在“*”参数之前",
        "positionOnlyAfterNon": "非仅位置参数后面不允许仅位置参数",
        "positionOnlyFirstParam": "不允许将仅位置参数分隔符用作第一个参数",
        "positionOnlyIncompatible": "仅位置参数分隔符需要 Python 3.8 或更高版本",
        "privateImportFromPyTypedModule": "未从模块“{module}”导出“{name}”",
        "privateUsedOutsideOfClass": "私有符号“{name}”在声明它的类之外使用",
        "privateUsedOutsideOfModule": "私有符号“{name}”在声明它的模块之外使用",
        "propertyOverridden": "“{name}”错误地覆写了类“{className}”中的同名属性",
        "propertyStaticMethod": "属性 getter、setter 或 deleter 不允许使用静态方法",
        "protectedUsedOutsideOfClass": "“{name}”在声明它的类之外受到保护并被使用",
        "protocolBaseClass": "协议类“{classType}”不能派生自非协议类“{baseType}”",
        "protocolBaseClassWithTypeArgs": "使用类型参数语法时，协议类不允许使用类型参数",
        "protocolIllegal": "使用“Protocol”需要 Python 3.7 或更高版本",
        "protocolNotAllowed": "“Protocol”不能用于此上下文",
        "protocolTypeArgMustBeTypeParam": "“协议”的类型参数必须是类型参数",
        "protocolUnsafeOverlap": "类与“{name}”不安全地重叠，并且可能在运行时生成匹配项",
        "protocolVarianceContravariant": "“{class}”泛型协议中使用的“{variable}”应为逆变类型变量",
        "protocolVarianceCovariant": "“{class}”泛型协议中使用的“{variable}”应为协变类型变量",
        "protocolVarianceInvariant": "“{class}”泛型协议中使用的“{variable}”应为不变类型变量",
        "pyrightCommentInvalidDiagnosticBoolValue": "Pyright 注释指令后面必须跟有“=”和 true 或 false 值",
        "pyrightCommentInvalidDiagnosticSeverityValue": "Pyright 注释指令后面必须跟有“=”，并且值为 true、false、error、warning、information 或 none",
        "pyrightCommentMissingDirective": "Pyright 注释后面必须是指令（basic 或 strict）或诊断规则",
        "pyrightCommentNotOnOwnLine": "文件级别上控制设置的 Pyright 注释必须出现在其自己的行上",
        "pyrightCommentUnknownDiagnosticRule": "未知的 pyright 注释诊断规则“{rule}”",
        "pyrightCommentUnknownDiagnosticSeverityValue": "无效的 pyright 注释值“{value}”；应为 true、false、error、warning、information 或 none",
        "pyrightCommentUnknownDirective": "“{directive}”是 pyright 注释的未知指令；应为“strict”或“basic”",
        "readOnlyArgCount": "“ReadOnly”后应为单个类型参数",
        "readOnlyNotInTypedDict": "此上下文中不允许使用“ReadOnly”",
        "recursiveDefinition": "无法确定“{name}”的类型，因为它引用其自身",
        "relativeImportNotAllowed": "相对导入不能与“import .a”形式一起使用；改用“from . import a”",
        "requiredArgCount": "“Required”后应为单个类型参数",
        "requiredNotInTypedDict": "此上下文中不允许使用“Required”",
        "returnInAsyncGenerator": "异步生成器中不允许带返回值的 return 语句",
        "returnMissing": "返回类型声明为“{returnType}”的函数必须在所有代码路径上返回值",
        "returnOutsideFunction": "“return”只能在函数中使用",
        "returnTypeContravariant": "逆变类型变量不能用于返回类型",
        "returnTypeMismatch": "无法将“{exprType}”类型的表达式赋值给“{returnType}”返回类型",
        "returnTypePartiallyUnknown": "返回类型“{returnType}”部分未知",
        "returnTypeUnknown": "返回类型未知",
        "revealLocalsArgs": "“reveal_locals”调用应没有参数",
        "revealLocalsNone": "此范围内没有局部变量",
        "returnTypeAny": "返回类型为 Any",
        "revealTypeArgs": "“reveal_type”调用应为单个位置参数",
        "revealTypeExpectedTextArg": "函数“reveal_type”的“expected_text”参数必须是 str 字面值",
        "revealTypeExpectedTextMismatch": "类型字面值不匹配：应为“{expected}”，但得到“{received}”",
        "revealTypeExpectedTypeMismatch": "类型不匹配：应为“{expected}”但得到“{received}”",
        "selfTypeContext": "“Self”在此上下文中无效",
        "selfTypeMetaclass": "“Self”不能在元类（“type”的子类）中使用",
        "selfTypeWithTypedSelfOrCls": "“Self”不能在具有“self”或“cls”参数的函数中使用，该参数的类型标注不是“Self”",
        "setterGetterTypeMismatch": "属性的 setter 值类型不匹配 getter 返回类型",
        "singleOverload": "“{name}”被标记为重载，但缺少其他重载",
        "slotsAttributeError": "未在 __slots__ 中指定“{name}”",
        "slotsClassVarConflict": "“{name}”与 __slots__ 中声明的实例变量冲突",
        "starPatternInAsPattern": "不能给解包表达式起别名",
        "starPatternInOrPattern": "解包表达式不能与其他模式进行“或”操作",
        "starStarWildcardNotAllowed": "** 不能与通配符“_”一起使用",
        "staticClsSelfParam": "静态方法不应有“self”或“cls”参数",
        "stdlibModuleOverridden": "“{path}”覆盖了标准库模块“{name}”",
        "stringNonAsciiBytes": "不允许使用非 ASCII 字符（以字节为单位）字符串字面值",
        "stringNotSubscriptable": "字符串表达式不能在类型标注中下标；请将整个标注括在引号中",
        "stringUnsupportedEscape": "字符串文本中有不受支持的转义序列",
        "stringUnterminated": "字符串文本未终止",
        "stubFileMissing": "找不到“{importName}”的存根文件",
        "stubUsesGetAttr": "类型存根文件不完整；“__getattr__”会掩盖模块的类型错误",
        "sublistParamsIncompatible": "Python 3.x 不支持 sublist 参数",
        "superCallArgCount": "“super”调用不应多于两个参数",
        "superCallFirstArg": "应将类类型作为“super”调用的第一个参数，但收到“{type}”",
        "superCallSecondArg": "“super”调用的第二个参数必须是派生自“{type}”的对象或类",
        "superCallZeroArgForm": "“Super”调用的零参数形式仅在方法中有效",
        "superCallZeroArgFormStaticMethod": "“super”调用的零参数形式在静态方法中无效",
        "symbolIsPossiblyUnbound": "“{name}”可能未绑定",
        "symbolIsUnbound": "“{name}”未绑定",
        "symbolIsUndefined": "“{name}”未定义",
        "symbolOverridden": "“{name}”覆写了“{className}”类中的同名符号",
        "ternaryNotAllowed": "类型注释中不允许使用三元表达式",
        "totalOrderingMissingMethod": "类必须定义“__lt__”、“__le__”、“__gt__”或“__ge__”之一才能使用total_ordering",
        "trailingCommaInFromImport": "不允许使用尾随逗号，没有括号",
        "tryWithoutExcept": "Try 语句必须至少有一个 except 或 finally 子句",
        "tupleAssignmentMismatch": "无法将类型为“{type}”的表达式赋值给目标元组",
        "tupleInAnnotation": "类型标注中不允许元组表达式",
        "tupleIndexOutOfRange": "{type} 类型的索引值 {index} 超出范围",
        "typeAliasIllegalExpressionForm": "类型别名定义的表达式形式无效",
        "typeAliasIsRecursiveDirect": "类型别名“{name}”不能在其定义中使用自身",
        "typeAliasNotInModuleOrClass": "TypeAlias 只能在模块或类范围内定义",
        "typeAliasRedeclared": "声明为 TypeAlias 的“{name}”只能赋值一次",
        "typeAliasStatementBadScope": "type 语句只能在模块或类范围内使用",
        "typeAliasStatementIllegal": "类型别名语句需要 Python 3.12 或更高版本",
        "typeAliasTypeBaseClass": "“type”语句中定义的类型别名不能用作基类",
        "typeAliasTypeMustBeAssigned": "必须将 TypeAliasType 赋值给与类型别名同名的变量",
        "typeAliasTypeNameArg": "TypeAliasType 的第一个参数必须是表示类型别名名称的字符串字面值",
        "typeAliasTypeNameMismatch": "类型别名的名称必须与赋值到的变量的名称匹配",
        "typeAliasTypeParamInvalid": "类型参数列表必须是仅包含 TypeVar、TypeVarTuple 或 ParamSpec 的元组",
        "typeAnnotationCall": "类型表达式中不允许使用调用表达式",
        "typeAnnotationVariable": "类型表达式中不允许使用变量",
        "typeAnnotationWithCallable": "“type”的类型参数必须为类; 不支持可调用项",
        "typeAny": "“{name}”的类型为 Any",
        "typeArgListExpected": "应为 ParamSpec、省略号或类型列表",
        "typeArgListNotAllowed": "不允许此类型参数使用列表表达式",
        "typeArgsExpectingNone": "“{name}”类不应有类型参数",
        "typeArgsMismatchOne": "应为一个类型参数，但得到 {received}",
        "typeArgsMissingForAlias": "“{name}”泛型类型别名应有类型参数",
        "typeArgsMissingForClass": "“{name}”泛型类应有类型参数",
        "typeArgsTooFew": "为“{name}”提供的类型参数太少：应有 {expected} 个，但只有 {received} 个",
        "typeArgsTooMany": "为“{name}”提供的类型参数太多：应有 {expected} 个，但有 {received} 个",
        "typeAssignmentMismatch": "“{sourceType}”类型的表达式无法赋值给声明的“{destType}”类型",
        "typeAssignmentMismatchWildcard": "“{name}”导入符号的类型为“{sourceType}”，无法将其赋值给声明的“{destType}”类型",
        "typeCallNotAllowed": "type() 调用不应用于类型标注",
        "typeCheckOnly": "“{name}”标记为 @type_check_only，只能在类型注释中使用",
        "typeCommentDeprecated": "类型注释已弃用；请改用类型标注",
        "typeExpectedClass": "应为类型表达式，但得到“{type}”",
        "typeFormArgs": "\"TypeForm\" 接受单个位置参数",
        "typeGuardArgCount": "“TypeGuard”或“TypeIs”后应为单个类型参数",
        "typeGuardParamCount": "用户定义的类型保护器函数和方法必须至少有一个输入参数",
        "typeIsReturnType": "TypeIs 的返回类型“{returnType}”与值参数类型“{type}”不一致",
        "typeNotAwaitable": "“{type}”不能等待",
        "typeNotIntantiable": "“{type}”不能实例化",
        "typeNotIterable": "“{type}”不能迭代",
        "typeNotSpecializable": "“{type}”类型无法特化",
        "typeNotSubscriptable": "“{type}”类型的对象不能取下标",
        "typeNotSupportBinaryOperator": "“{leftType}”和“{rightType}”类型不支持“{operator}”运算符",
        "typeNotSupportBinaryOperatorBidirectional": "预期类型为“{expectedType}”时，类型“{leftType}”和“{rightType}”不支持运算符“{operator}”",
        "typeNotSupportUnaryOperator": "“{type}”类型不支持“{operator}”运算符",
        "typeNotSupportUnaryOperatorBidirectional": "预期类型为“{expectedType}”时，“{type}”类型不支持“{operator}”运算符",
        "typeNotUsableWith": "“{type}”类型的对象不能与“with”一起使用，因为它未实现{method}",
        "typeParameterBoundNotAllowed": "绑定或约束不能与可变类型参数或 ParamSpec 一起使用",
        "typeParameterConstraintTuple": "类型参数约束必须为含至少两个类型的元组",
        "typeParameterExistingTypeParameter": "“{name}”类型参数已使用",
        "typeParameterNotDeclared": "“{name}”类型参数未包含在“{container}”的类型参数列表中",
        "typeParametersMissing": "必须指定至少一个类型参数",
        "typePartiallyUnknown": "“{name}”的类型部分未知",
        "typeUnknown": "“{name}”类型未知",
        "typeVarAssignedName": "必须将 TypeVar 赋值给名为“{name}”的变量",
        "typeVarAssignmentMismatch": "无法将“{type}”类型赋值给类型变量“{name}”",
        "typeVarBoundAndConstrained": "TypeVar 不能同时绑定和约束",
        "typeVarBoundGeneric": "TypeVar 绑定类型不能是泛型",
        "typeVarConstraintGeneric": "TypeVar 约束类型不能是泛型",
        "typeVarDefaultBoundMismatch": "TypeVar 默认类型必须是绑定类型的子类型",
        "typeVarDefaultConstraintMismatch": "TypeVar 默认类型必须是受约束类型之一",
        "typeVarDefaultIllegal": "类型变量默认类型需要 Python 3.13 或更高版本",
        "typeVarDefaultInvalidTypeVar": "“{name}”类型参数的默认类型是指超出范围的一个或多个类型变量",
        "typeVarFirstArg": "TypeVar 的第一个参数应为其名称",
        "typeVarInvalidForMemberVariable": "属性类型不能使用作用域为本地方法的类型变量\"{name}\"",
        "typeVarNoMember": "TypeVar “{type}”没有“{name}”成员",
        "typeVarNotSubscriptable": "TypeVar “{type}”不能取下标",
        "typeVarNotUsedByOuterScope": "“{name}”类型变量在此上下文中没有意义",
        "typeVarPossiblyUnsolvable": "如果调用方没有为“{param}”形参提供实参，则“{name}”类型变量可能无法解析",
        "typeVarSingleConstraint": "TypeVar 必须有至少两种约束类型",
        "typeVarTupleConstraints": "TypeVarTuple 不能有值约束",
        "typeVarTupleContext": "此上下文中不允许使用 TypeVarTuple",
        "typeVarTupleDefaultNotUnpacked": "TypeVarTuple 默认类型必须是已解包的元组或 TypeVarTuple",
        "typeVarTupleMustBeUnpacked": "TypeVarTuple 值需要解包操作符",
        "typeVarTupleUnknownParam": "TypeVarTuple 没有“{name}”参数",
        "typeVarUnknownParam": "TypeVar 没有“{name}”参数",
        "typeVarUsedByOuterScope": "TypeVar “{name}”已被外部作用域使用",
        "typeVarUsedOnlyOnce": "TypeVar “{name}”在泛型函数签名中仅出现了一次",
        "typeVarVariance": "TypeVar 不能同时为协变和逆变",
        "typeVarWithDefaultFollowsVariadic": "TypeVar “{typeVarName}”具有默认值，不能跟在 TypeVarTuple “{variadicName}”之后",
        "typeVarWithoutDefault": "“{name}”不能出现在类型参数列表的“{other}”后面，因为它没有默认类型",
        "typeVarsNotInGenericOrProtocol": "Generic[] 或 Protocol[] 必须包括所有类型变量",
        "typedDictAccess": "无法访问 TypedDict 中的项",
        "typedDictAssignedName": "必须将 TypedDict 赋值给名为“{name}”的变量",
        "typedDictBadVar": "TypedDict 类只能包含类型标注",
        "typedDictBaseClass": "TypedDict 类的所有基类也必须是 TypedDict 类",
        "typedDictBoolParam": "“{name}”参数的值应为 True 或 False",
        "typedDictClosedExtras": "“{name}”基类是已关闭的 TypedDict；额外的项必须为“{type}类型”",
        "typedDictClosedNoExtras": "“{name}”基类是已关闭的 TypedDict；不允许使用额外的项",
        "typedDictDelete": "无法删除 TypedDict 中的项",
        "typedDictEmptyName": "TypedDict 中的名称不能为空",
        "typedDictEntryName": "字典项名称应为字符串字面值",
        "typedDictEntryUnique": "字典中的名称必须唯一",
        "typedDictExtraArgs": "不支持额外的 TypedDict 参数",
        "typedDictFieldNotRequiredRedefinition": "无法将 TypedDict 项“{name}”重新定义为 NotRequired",
        "typedDictFieldReadOnlyRedefinition": "无法将 TypedDict 项“{name}”重新定义为 ReadOnly",
        "typedDictFieldRequiredRedefinition": "无法将 TypedDict 项“{name}”重新定义为 Required",
        "typedDictFirstArg": "应将 TypedDict 类名作为第一个参数",
        "typedDictInitsubclassParameter": "TypedDict 不支持 __init_subclass__ 的“{name}”参数",
        "typedDictNotAllowed": "“TypedDict”不能用于此上下文",
        "typedDictSecondArgDict": "第二个参数应为 dict 或关键字参数",
        "typedDictSecondArgDictEntry": "应为简单字典项",
        "typedDictSet": "无法在 TypedDict 中赋值项",
        "unaccessedClass": "“{name}”类未使用",
        "unaccessedFunction": "“{name}”函数未使用",
        "unaccessedImport": "“{name}”导入未使用",
        "unaccessedSymbol": "未存取“{name}”",
        "unaccessedVariable": "变量“{name}”未使用",
        "unannotatedFunctionSkipped": "已跳过对未标类型的“{name}”函数的分析",
        "unaryOperationNotAllowed": "类型注释中不允许使用一元运算符",
        "unexpectedAsyncToken": "“def”、“with”或“for”应在“async”之后",
        "unexpectedExprToken": "表达式末尾有错误的形符",
        "unexpectedIndent": "缩进有错误",
        "unexpectedUnindent": "取消缩进有错误",
        "unhashableDictKey": "字典键必须可以哈希",
        "unhashableSetEntry": "集合项必须是可哈希",
        "uninitializedAbstractVariables": "抽象基类中定义的变量未在“{classType}”最终类中初始化",
        "uninitializedInstanceVariable": "未在类体或 __init__ 方法中初始化“{name}”实例变量",
        "unionForwardReferenceNotAllowed": "联合语法不能与字符串操作数一起使用;在整个表达式周围使用引号",
        "unionSyntaxIllegal": "联合的替代语法需要 Python 3.10 或更高版本",
        "unionTypeArgCount": "联合需要至少两个类型参数",
        "unionUnpackedTuple": "联合不能包含未打包的元组",
        "unionUnpackedTypeVarTuple": "联合不能含有已解包的 TypeVarTuple",
        "unnecessaryCast": "已为“{type}”类型，不需要调用“cast”",
        "unnecessaryIsInstanceAlways": "“{testType}”始终是“{classType}”的实例，不需要调用 isinstance",
        "unnecessaryIsSubclassAlways": "“{testType}”始终是“{classType}”的子类，不需要调用 issubclass",
        "unnecessaryPyrightIgnore": "无需“# pyright: ignore”注释",
        "unnecessaryPyrightIgnoreRule": "无需“# pyright: ignore”规则：“{name}”",
        "unnecessaryTypeIgnore": "无需“# type: ignore”注释",
        "unpackArgCount": "“Unpack”后应为单个类型参数",
        "unpackExpectedTypeVarTuple": "Unpack 需要 TypeVarTuple 或元组类型参数",
        "unpackExpectedTypedDict": "Unpack 需要 TypedDict 类型参数",
        "unpackIllegalInComprehension": "推导式中不允许解包操作",
        "unpackInAnnotation": "类型标注中不允许解包操作符",
        "unpackInDict": "字典中不允许解包操作",
        "unpackInSet": "集合内不允许解包操作符",
        "unpackNotAllowed": "此上下文中不允许使用 Unpack",
        "unpackOperatorNotAllowed": "此上下文中不允许解包操作",
        "unpackTuplesIllegal": "在 Python 3.8 之前，元组中不允许解包操作",
        "unpackedArgInTypeArgument": "无法在类型参数列表中使用已解包的参数",
        "unpackedArgWithVariadicParam": "未打包的参数不能用于 TypeVarTuple 参数",
        "unpackedDictArgumentNotMapping": "** 后面的参数表达式必须是具有“str”键类型的映射",
        "unpackedDictSubscriptIllegal": "不允许在下标中使用字典解包操作符",
        "unpackedSubscriptIllegal": "下标中的解包操作符需要 Python 3.11 或更高版本",
        "unpackedTypeVarTupleExpected": "应为未打包的 TypeVarTuple；使用 Unpack[{name1}] 或 *{name2}",
        "unpackedTypedDictArgument": "无法将解包的 TypedDict 参数与参数匹配",
        "unreachableCode": "代码无法访问",
        "unreachableCodeType": "类型分析指示代码不可访问",
        "unreachableExcept": "无法访问 Except 子句，因为已处理异常",
        "unsupportedDunderAllOperation": "不支持对“__all__”执行操作，因此导出的符号列表可能不正确",
        "unusedCallResult": "调用表达式的结果类型为“{type}”且未使用；如果这是有意为之，则赋值给变量“_”",
        "unusedCoroutine": "未使用异步函数调用的结果；使用“await”或将结果赋值给变量",
        "unusedExpression": "表达式值未使用",
        "varAnnotationIllegal": "变量的类型标注需要 Python 3.6 或更高版本；使用类型注释与以前的版本兼容",
        "variableFinalOverride": "变量“{name}”被标记为 Final，并替代类“{className}”中同名的非 Final 变量",
        "variadicTypeArgsTooMany": "类型参数列表最多可以有一个未打包的 TypeVarTuple 或元组",
        "variadicTypeParamTooManyAlias": "类型别名最多可以有一个 TypeVarTuple 类型参数，但收到多个 ({names})",
        "variadicTypeParamTooManyClass": "泛型类最多可以有一个 TypeVarTuple 类型参数，但收到多个 ({names})",
        "walrusIllegal": "运算符“:=”需要 Python 3.8 或更高版本",
        "walrusNotAllowed": "此上下文中不允许使用运算符“:=”，且不带括号",
        "wildcardInFunction": "类或函数中不允许使用通配符导入",
        "wildcardLibraryImport": "不允许从库中导入通配符",
        "wildcardPatternTypeAny": "通配符模式捕获的类型为 Any",
        "wildcardPatternTypePartiallyUnknown": "通配符模式捕获的类型部分未知",
        "wildcardPatternTypeUnknown": "通配符模式捕获的类型未知",
        "yieldFromIllegal": "使用“yield from”需要 Python 3.3 或更高版本",
        "yieldFromOutsideAsync": "async 函数中不允许使用 \"yield from\"",
        "yieldOutsideFunction": "不允许在函数或 lambda 之外使用“yield”",
        "yieldWithinComprehension": "不允许在推导式中使用“yield”",
        "zeroCaseStatementsFound": "Match 语句必须至少包含一个 case 语句",
        "zeroLengthTupleNotAllowed": "此上下文中不允许使用零长度元组",
        "pyrightIgnoreCommentWithoutRule": "`pyright: ignore` 注释必须指定具体规则（例如 `# pyright: ignore[ruleName]`）",
        "typeIgnoreCommentWithoutRule": "`type: ignore` 注释必须指定具体规则（例如 `# type: ignore[ruleName]`）"
    },
    "DiagnosticAddendum": {
        "annotatedNotAllowed": "“已标注”特殊窗体不能与实例和类检查一起使用",
        "argParam": "参数对应于参数“{paramName}”",
        "argParamFunction": "参数对应于函数“{functionName}”中的参数“{paramName}”",
        "argsParamMissing": "参数“*{paramName}”没有相应的参数",
        "argsPositionOnly": "仅位置参数不匹配；应为 {expected}，但收到 {received}",
        "argumentType": "参数类型为“{type}”",
        "argumentTypes": "参数类型：（{types}）",
        "assignToNone": "无法将类型赋值给类型“None”",
        "asyncHelp": "是否表示“async with”?",
        "baseClassIncompatible": "基类“{baseClass}”与类型“{type}”不兼容",
        "baseClassIncompatibleSubclass": "基类“{baseClass}”派生自与类型“{type}”不兼容的“{subclass}”",
        "baseClassOverriddenType": "基类“{baseClass}”提供被替代的类型“{type}”",
        "baseClassOverridesType": "基类“{baseClass}”替代类型{type}”",
        "bytesTypePromotions": "将 disableBytesTypePromotions 设置为 false，以启用“bytearray”和“memoryview”的类型提升行为",
        "conditionalRequiresBool": "类型“{operandType}”的方法__bool__返回类型“{boolReturnType}”而不是“bool”",
        "dataClassFieldLocation": "字段声明",
        "dataClassFrozen": "“{name}”已冻结",
        "dataProtocolUnsupported": "“{name}”是数据协议",
        "descriptorAccessBindingFailed": "无法绑定描述符类“{className}”的方法“{name}”",
        "descriptorAccessCallFailed": "无法为描述符类“{className}”调用方法“{name}”",
        "finalMethod": "Final 方法",
        "functionParamDefaultMissing": "参数“{name}”缺少默认参数",
        "functionParamName": "参数名称不匹配:“{destName}” versus “{srcName}”",
        "functionParamPositionOnly": "仅位置参数不匹配; 参数“{name}”并非仅限位置",
        "functionReturnTypeMismatch": "函数返回类型“{sourceType}”与类型“{destType}”不兼容",
        "functionTooFewParams": "函数接受的位置参数太少；应为 {expected}，但收到 {received}",
        "functionTooManyParams": "函数接受太多位置参数；应为 {expected}，但收到 {received}",
        "genericClassNotAllowed": "不允许对实例或类检查使用具有类型参数的泛型类型",
        "incompatibleDeleter": "属性deleter 方法不兼容",
        "incompatibleGetter": "属性 getter 方法不兼容",
        "incompatibleSetter": "属性 setter 方法不兼容",
        "initMethodLocation": "__init__方法已在类“{type}”中定义",
        "initMethodSignature": "__init__的签名为“{type}”",
        "initSubclassLocation": "__init_subclass__ 方法在类“{name}”中定义",
        "invariantSuggestionDict": "请考虑从“dict”切换到“Mapping”(在值类型中为协变)",
        "invariantSuggestionList": "考虑从“list”切换到“Sequence”(协变)",
        "invariantSuggestionSet": "请考虑从“set”切换到“Container”，后者是协变的",
        "isinstanceClassNotSupported": "实例和类检查不支持“{type}”",
        "keyNotRequired": "“{type}”中“{name}”不是必需的密钥，因此访问可能会导致运行时异常",
        "keyReadOnly": "“{name}”是“{type}”中的只读密钥",
        "keyRequiredDeleted": "“{name}”是必需的密钥，无法删除",
        "keyUndefined": "“{name}”不是“{type}”中定义的密钥",
        "kwargsParamMissing": "参数“**{paramName}”没有相应的参数",
        "listAssignmentMismatch": "类型“{type}”与目标列表不兼容",
        "literalAssignmentMismatch": "无法将“{sourceType}”赋值给类型“{destType}”",
        "matchIsNotExhaustiveHint": "如果未进行详尽处理，请添加“case _: pass”",
        "matchIsNotExhaustiveType": "未处理的类型:“{type}”",
        "memberAssignment": "无法将“{type}”类型的表达式赋值给类“{classType}”的成员“{name}”",
        "memberIsAbstract": "未实现“{type}.{name}”",
        "memberIsAbstractMore": "还有 {count} 个...",
        "memberIsClassVarInProtocol": "“{name}”在协议中定义为 ClassVar",
        "memberIsInitVar": "成员“{name}”是仅初始字段",
        "memberIsInvariant": "“{name}”是固定的，因为它是可变的",
        "memberIsNotClassVarInClass": "“{name}”必须定义为 ClassVar 才能与协议兼容",
        "memberIsNotClassVarInProtocol": "“{name}”未在协议中定义为 ClassVar",
        "memberIsNotReadOnlyInProtocol": "“{name}”在协议中不是只读的",
        "memberIsReadOnlyInProtocol": "“{name}”在协议中是只读的",
        "memberIsWritableInProtocol": "“{name}”在协议中是可写入的",
        "memberSetClassVar": "无法通过类实例赋值成员“{name}”，因为它是 ClassVar",
        "memberTypeMismatch": "“{name}”是不兼容的类型",
        "memberUnknown": "成员“{name}”未知",
        "metaclassConflict": "元类“{metaclass1}”与“{metaclass2}”存在冲突",
        "missingDeleter": "缺少属性 deleter方法",
        "missingGetter": "缺少属性 getter 方法",
        "missingSetter": "缺少属性 setter 方法",
        "namedParamMissingInDest": "额外参数“{name}”",
        "namedParamMissingInSource": "缺少关键字参数“{name}”",
        "namedParamTypeMismatch": "类型为“{sourceType}”的关键字参数“{name}”与类型“{destType}”不兼容",
        "namedTupleNotAllowed": "不能对实例或类检查使用 NamedTuple",
        "newMethodLocation": "__new__方法已在类“{type}”中定义",
        "newMethodSignature": "__new__的签名为“{type}”",
        "newTypeClassNotAllowed": "不能将使用 NewType 创建的类用于实例和类检查",
        "noOverloadAssignable": "没有重载函数与类型“{type}”匹配",
        "noneNotAllowed": "不能对实例或类检查使用 None",
        "orPatternMissingName": "缺少名称: {name}",
        "overloadIndex": "重载 {index} 是最接近的匹配项",
        "overloadNotAssignable": "无法赋值“{name}”的一个或多个重载",
        "overloadSignature": "此处定义了重载签名",
        "overriddenMethod": "替代的方法",
        "overriddenSymbol": "替代符号",
        "overrideInvariantMismatch": "替代类型“{overrideType}”与基类型“{baseType}”不同",
        "overrideIsInvariant": "变量是可变的，因此其类型是固定的",
        "overrideNoOverloadMatches": "替代中没有与基本方法兼容的重载签名",
        "overrideNotClassMethod": "基方法声明为 classmethod，但替代不是",
        "overrideNotInstanceMethod": "基方法声明为实例方法，但替代不是",
        "overrideNotStaticMethod": "基方法声明为 staticmethod，但替代不是",
        "overrideOverloadNoMatch": "替代不处理基方法的所有重载",
        "overrideOverloadOrder": "替代方法的重载必须与基方法的顺序相同",
        "overrideParamKeywordNoDefault": "关键字参数“{name}”不匹配: 基参数具有默认参数值，替代参数不匹配",
        "overrideParamKeywordType": "关键字参数“{name}”类型不匹配: 基参数是类型“{baseType}”，替代参数为类型“{overrideType}”",
        "overrideParamName": "参数{index}名称不匹配: 基参数命名为“{baseName}”，替代参数命名为“{overrideName}”",
        "overrideParamNameExtra": "基数中缺少参数“{name}”",
        "overrideParamNameMissing": "替代中缺少参数“{name}”",
        "overrideParamNamePositionOnly": "参数 {index} 不匹配: 基参数“{baseName}”是关键字参数，替代参数为仅位置参数",
        "overrideParamNoDefault": "参数 {index} 不匹配: 基参数具有默认参数值，替代参数不匹配",
        "overrideParamType": "参数 {index} 类型不匹配: 基参数为类型“{baseType}”，替代参数为类型“{overrideType}”",
        "overridePositionalParamCount": "位置参数计数不匹配；基方法具有 {baseCount}，但替代具有 {overrideCount}",
        "overrideReturnType": "返回类型不匹配:基方法返回类型“{baseType}”，替代返回类型“{overrideType}”",
        "overrideType": "基类将类型定义为“{type}”",
        "paramAssignment": "参数 {index}: 无法将类型“{sourceType}”赋值给类型“{destType}”",
        "paramSpecMissingInOverride": "替代方法中缺少 ParamSpec 参数",
        "paramType": "参数类型为“{paramType}”",
        "privateImportFromPyTypedSource": "改为从“{module}”导入",
        "propertyAccessFromProtocolClass": "不能以类变量形式访问协议类中定义的属性",
        "propertyMethodIncompatible": "属性方法“{name}”不兼容",
        "propertyMethodMissing": "替代中缺少属性方法“{name}”",
        "propertyMissingDeleter": "属性“{name}”没有定义的删除程序",
        "propertyMissingSetter": "属性“{name}”没有定义的资源库",
        "protocolIncompatible": "“{sourceType}”与协议“{destType}”不兼容",
        "protocolMemberMissing": "“{name}”不存在",
        "protocolRequiresRuntimeCheckable": "协议类必须为 @runtime_checkable 才能用于实例和类检查",
        "protocolSourceIsNotConcrete": "“{sourceType}”不是具体类类型，无法赋值给类型“{destType}”",
        "protocolUnsafeOverlap": "“{name}”的属性与协议具有相同的名称",
        "pyrightCommentIgnoreTip": "使用“# pyright: ignore[<diagnostic rules>]”取消单行诊断",
        "readOnlyAttribute": "属性“{name}”为只读",
        "seeClassDeclaration": "查看类声明",
        "seeDeclaration": "参见声明",
        "seeFunctionDeclaration": "请参阅函数声明",
        "seeMethodDeclaration": "请参阅方法声明",
        "seeParameterDeclaration": "请参阅参数声明",
        "seeTypeAliasDeclaration": "请参阅类型别名声明",
        "seeVariableDeclaration": "查看变量声明",
        "tupleAssignmentMismatch": "类型“{type}”与目标元组不兼容",
        "tupleEntryTypeMismatch": "元组项 {entry} 的类型不正确",
        "tupleSizeIndeterminateSrc": "元组大小不匹配；应为 {expected}，但收到不确定的",
        "tupleSizeIndeterminateSrcDest": "元组大小不匹配；应为 {expected} 或更多，但收到不确定的值",
        "tupleSizeMismatch": "元组大小不匹配；应为 {expected}，但收到 {received}",
        "tupleSizeMismatchIndeterminateDest": "元组大小不匹配；应为 {expected} 或更多，但收到 {received}",
        "typeAliasInstanceCheck": "使用“type”语句创建的类型别名不能与实例和类检查一起使用",
        "typeAssignmentMismatch": "无法将类型“{sourceType}”赋值给类型“{destType}”",
        "typeBound": "类型“{sourceType}”与类型变量“{destType}”的绑定类型“{name}”不兼容",
        "typeConstrainedTypeVar": "类型“{type}”与受约束的类型变量“{name}”不兼容",
        "typeIncompatible": "“{sourceType}”与“{destType}”不兼容",
        "typeNotClass": "“{type}”不是类",
        "typeNotStringLiteral": "“{type}”不是字符串字面值",
        "typeOfSymbol": "“{name}”的类型为“{type}”",
        "typeParamSpec": "类型“{type}”与 ParamSpec “{name}”不兼容",
        "typeUnsupported": "类型“{type}”不受支持",
        "typeVarDefaultOutOfScope": "类型变量“{name}”不在范围内",
        "typeVarIsContravariant": "类型参数“{name}”是逆变的，但“{sourceType}”不是“{destType}”的超类型",
        "typeVarIsCovariant": "类型参数“{name}”是协变的，但“{sourceType}”不是“{destType}”的子类型",
        "typeVarIsInvariant": "类型参数“{name}”是固定的，但“{sourceType}”与“{destType}”不同",
        "typeVarNotAllowed": "不允许对实例或类检查使用 TypeVar",
        "typeVarTupleRequiresKnownLength": "TypeVarTuple 不能绑定到长度未知的 tuple",
        "typeVarUnnecessarySuggestion": "请改用 {type}",
        "typeVarUnsolvableRemedy": "提供一个重载，该重载指定未提供参数时的返回类型",
        "typeVarsMissing": "缺少类型变量: {names}",
        "typedDictBaseClass": "类“{type}”不是 TypedDict",
        "typedDictClassNotAllowed": "不允许对实例或类检查使用 TypedDict 类",
        "typedDictClosedExtraNotAllowed": "无法添加项“{name}”",
        "typedDictClosedExtraTypeMismatch": "无法添加“{type}”类型的项“{name}”",
        "typedDictClosedFieldNotRequired": "无法添加项“{name}”，因为它必须是 NotRequired",
        "typedDictExtraFieldNotAllowed": "“{type}”中不存在“{name}”",
        "typedDictExtraFieldTypeMismatch": "“{name}”的类型与“{type}”中的“__extra_items__”类型不兼容",
        "typedDictFieldMissing": "“{type}”中缺少“{name}”",
        "typedDictFieldNotReadOnly": "“{name}”在“{type}”中不是只读的",
        "typedDictFieldNotRequired": "“{type}”中不需要“{name}”",
        "typedDictFieldRequired": "“{type}”中需要“{name}”",
        "typedDictFieldTypeMismatch": "类型“{type}”不可赋值给项“{name}”",
        "typedDictFieldUndefined": "“{name}”是类型“{type}”中的未定义项",
        "typedDictFinalMismatch": "“{sourceType}”与“{destType}”不兼容，因为@final不匹配",
        "typedDictKeyAccess": "使用 [\"{name}\"] 引用 TypedDict 中的项",
        "typedDictNotAllowed": "不能对实例或类检查使用 TypedDict",
        "unhashableType": "类型“{type}”不可哈希",
        "uninitializedAbstractVariable": "实例变量“{name}”在抽象基类“{classType}”中定义，但未初始化",
        "unreachableExcept": "“{exceptionType}”是“{parentType}”的子类",
        "useDictInstead": "使用 Dict[T1, T2] 指示字典类型",
        "useListInstead": "使用 List[T] 指示列表类型或 Union[T1, T2] 以指示联合类型",
        "useTupleInstead": "使用 tuple[T1, ..., Tn] 指示元组类型或使用 Union[T1, T2] 指示联合类型",
        "useTypeInstead": "改用类型[T]",
        "varianceMismatchForClass": "类型参数“{typeVarName}”的差异与基类“{className}”不兼容",
        "varianceMismatchForTypeAlias": "类型参数“{typeVarName}”的差异与“{typeAliasParam}”不兼容"
    },
    "Service": {
        "longOperation": "枚举工作区源文件需要很长时间。请考虑打开子文件夹。[了解详细信息](https://aka.ms/workspace-too-many-files)"
    }
}